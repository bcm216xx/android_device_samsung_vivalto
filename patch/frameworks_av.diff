diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba920..b9a6d4a 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -67,6 +67,9 @@ private:
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
 
+    status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);     
+
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff --git a/include/media/stagefright/ExtendedCodec.h b/include/media/stagefright/ExtendedCodec.h
new file mode 100644
index 0000000..d8c5dbb
--- /dev/null
+++ b/include/media/stagefright/ExtendedCodec.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright (c) 2013 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef EXTENDED_CODEC_H_
+#define EXTENDED_CODEC_H_
+
+#include <android/native_window.h>
+#include <media/IOMX.h>
+#include <media/MediaCodecInfo.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/AString.h>
+#include <utils/threads.h>
+
+#include <OMX_Audio.h>
+
+namespace android {
+
+struct MediaCodecList;
+struct OMXCodec;
+
+enum{
+    kRequiresWMAProComponent = 0x40000000,
+};
+
+
+struct ExtendedCodec {
+
+    enum {
+        kPortIndexInput  = 0,
+        kPortIndexOutput = 1
+    };
+    static status_t convertMetaDataToMessage(
+            const sp<MetaData> &meta, sp<AMessage> *format);
+
+    static uint32_t getComponentQuirks (
+            const sp<MediaCodecInfo> &info);
+
+    static status_t setAudioFormat(
+            const sp<MetaData> &meta, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder);
+
+    static status_t setAudioFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder);
+
+    static status_t setVideoFormat(
+            const sp<MetaData> &meta, const char *mime,
+            OMX_VIDEO_CODINGTYPE *compressionFormat);
+
+    static status_t setVideoFormat(
+            const sp<AMessage> &msg, const char *mime,
+            OMX_VIDEO_CODINGTYPE *compressionFormat);
+
+    static status_t getSupportedAudioFormatInfo(
+            const AString* mime,
+            sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID,
+            int portIndex,
+            int* channelCount,
+            int* sampleRate);
+
+    static status_t handleSupportedAudioFormats(
+            int format, AString* mime);
+
+    static status_t handleSupportedVideoFormats(
+            int format, AString* mime);
+
+    static bool checkIfCompressionHEVC(int format);
+
+    static status_t setupHEVCEncoderParameters(
+            const sp<MetaData> &meta, const sp<IOMX> &omx,
+            IOMX::node_id node, const char* componentName,
+            int portIndex, const sp<OMXCodec> &target);
+
+    static const char* overrideComponentName(
+            uint32_t quirks, const sp<MetaData> &meta,
+            const char *mime, bool isEncoder);
+
+    static void overrideComponentName(
+            uint32_t quirks, const sp<AMessage> &msg,
+            AString* componentName, AString* mime,
+            int32_t isEncoder);
+
+    static void overrideMimeType(
+        const sp<AMessage> &msg, AString* mime);
+
+    static void getRawCodecSpecificData(
+            const sp<MetaData> &meta,
+            const void* &data,
+            size_t& size);
+
+    static sp<ABuffer> getRawCodecSpecificData(
+            const sp<AMessage> &msg);
+
+    static void getAacCodecSpecificData(
+            const sp<MetaData> &meta,
+            const void* &data,
+            size_t& size);
+
+    static sp<ABuffer> getAacCodecSpecificData(
+            const sp<AMessage> &msg);
+
+    static status_t setSupportedRole(
+            const sp<IOMX> &omx, IOMX::node_id node,
+            bool isEncoder, const char *mime);
+
+    static void configureFramePackingFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, const char* componentName);
+
+    static void configureFramePackingFormat(
+            const sp<MetaData> &meta, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, const char* componentName);
+
+    static void configureVideoDecoder(
+            const sp<MetaData> &meta, const char* mime,
+            sp<IOMX> OMXhandle, const uint32_t flags,
+            IOMX::node_id nodeID, const char* componentName);
+
+    static void configureVideoDecoder(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle, const uint32_t flags,
+            IOMX::node_id nodeID, const char* componentName);
+
+    static void enableSmoothStreaming(
+            const sp<IOMX> &omx, IOMX::node_id nodeID, bool* isEnabled,
+            const char* componentName);
+
+    static bool useHWAACDecoder(const char *mime);
+
+    static bool isSourcePauseRequired(const char *componentName);
+
+    static const char* getMsgKey(int key );
+
+private:
+
+    static status_t setWMAFormat(
+            const sp<MetaData> &meta, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, bool isEncoder );
+
+    static status_t setWMAFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, bool isEncoder );
+
+    static void setEVRCFormat(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+            bool isEncoder );
+
+    static void setQCELPFormat(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+            bool isEncoder );
+
+#ifdef QCOM_ADDITIONAL_CODECS
+    static void setAC3Format(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID);
+#endif
+
+    static status_t setDIVXFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID, int port_index);
+
+    static status_t setAMRWBPLUSFormat(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID);
+
+};
+
+}
+#endif /*EXTENDED_CODEC_H_ */
+
diff --git a/include/media/stagefright/ExtendedStats.h b/include/media/stagefright/ExtendedStats.h
new file mode 100755
index 0000000..f744358
--- /dev/null
+++ b/include/media/stagefright/ExtendedStats.h
@@ -0,0 +1,292 @@
+/* Copyright (c) 2013 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EXTENDED_STATS_H_
+#define EXTENDED_STATS_H_
+
+#include <inttypes.h>
+#include <media/stagefright/foundation/AString.h>
+#include <utils/KeyedVector.h>
+#include <utils/Mutex.h>
+#include <utils/RefBase.h>
+#include <utils/StrongPointer.h>
+
+#define MEDIA_EXTENDED_STATS "MediaExtendedStats"
+
+#define STATS_PROFILE_START_LATENCY "Total startup latency"
+#define STATS_PROFILE_ALLOCATE_NODE(isVideo) (isVideo != 0 ? "\tAllocate node (video)" : "\tAllocate node (audio)")
+#define STATS_PROFILE_ALLOCATE_INPUT(isVideo) (isVideo != 0 ? "\tAllocate input buffer (video)" : "\tAllocate input buffer (audio)")
+#define STATS_PROFILE_ALLOCATE_OUTPUT(isVideo) (isVideo != 0 ? "\tAllocate output buffer (video)" : "\tAllocate output buffer (audio)")
+#define STATS_PROFILE_CONFIGURE_CODEC(isVideo) (isVideo != 0 ? "\tConfigure codec (video)" : "\tConfigure codec (audio)")
+#define STATS_PROFILE_FIRST_BUFFER(isVideo) (isVideo != 0 ? "Time to process first buffer (video)" : "Time to process first buffer (audio)")
+#define STATS_PROFILE_PREPARE "Prepare"
+#define STATS_PROFILE_SET_DATA_SOURCE "Set data source"
+#define STATS_PROFILE_PAUSE "Pause"
+#define STATS_PROFILE_SEEK "Seek"
+#define STATS_PROFILE_RESUME "Resume"
+
+#define STATS_PROFILE_SET_CAMERA_SOURCE "Set camera source"
+#define STATS_PROFILE_SET_ENCODER(isVideo) (isVideo != 0 ? "Set video encoder" : "Set audio encoder")
+#define STATS_PROFILE_STOP "Stop"
+#define STATS_BITRATE "Video Bitrate"
+#define STATS_PROFILE_SF_RECORDER_START_LATENCY "\tStagefrightRecorder start latency"
+#define STATS_PROFILE_CAMERA_SOURCE_START_LATENCY "\tCamera source start latency"
+#define STATS_PROFILE_RECONFIGURE "\tReconfigure latency"
+
+namespace android {
+
+/*
+ * This class provides support for profiling events and dumping aggregate
+ * statistics. It may be used to profile latencies at startup, seek, resume
+ * and to report dropped frames etc.
+ */
+typedef int64_t statsDataType;
+class MediaExtendedStats;
+
+class ExtendedStats : public RefBase {
+
+public:
+
+    enum {
+        MEDIA_STATS_FLAG = 'MeSt',
+    };
+
+    explicit ExtendedStats(const char* id, pid_t tid);
+
+    // Evaluative item; associated with an operation
+    struct LogEntry : public RefBase {
+        LogEntry();
+        virtual ~LogEntry() { mData = 0;}
+        virtual void insert(statsDataType) { }
+        virtual void dump(const char* label) const;
+        virtual void reset() {mData = 0;}
+        inline statsDataType data() const { return mData; }
+    protected:
+        statsDataType mData;
+    };
+
+    // Supported type of MediaExtendedStats
+    enum StatsType {
+        PLAYER,
+        RECORDER,
+    };
+
+    // Supported evaluations (and hence possible variants of 'LogEntry's)
+    enum LogType {
+        AVERAGE = 1 << 0,
+        MOVING_AVERAGE = 1 << 1,
+        PROFILE = 1 << 2,
+    };
+
+    enum {
+        PROFILE_START = 1,
+        PROFILE_START_ONCE,
+        PROFILE_STOP,
+    };
+
+    static const size_t kMaxStringLength = 1024;
+    static const int32_t kMaxWindowSize = 120;
+
+    struct AutoProfile {
+        AutoProfile(const char* eventName, sp<MediaExtendedStats> mediaExtendedStats = NULL,
+                bool condition = true, bool profileOnce = false);
+        ~AutoProfile();
+
+        private:
+            AString mEventName;
+            sp<ExtendedStats::LogEntry> mLog;
+            sp<ExtendedStats> mStats;
+            bool mCondition;
+    };
+
+    ~ExtendedStats();
+    void log(LogType type, const char* key, statsDataType value, bool condition = true);
+    virtual void dump(const char* key = NULL);
+    virtual void reset(const char* key);
+    virtual void clear();
+
+    static int64_t getSystemTime() {
+        struct timeval tv;
+        gettimeofday(&tv, NULL);
+        return (int64_t)tv.tv_sec * 1E6 + tv.tv_usec;
+    }
+
+    static sp<LogEntry> createLogEntry(LogType type, int32_t windowSize);
+
+    //only profile once, as opposed to up to kMaxOccurrences
+    inline void profileStartOnce(const char* name, bool condition = true) {
+        log(PROFILE, name, PROFILE_START_ONCE, condition);
+    }
+
+    //wrapper function to start profiling latency
+    inline void profileStart(const char* name, bool condition = true) {
+        log(PROFILE, name, PROFILE_START, condition);
+    }
+
+    //wrapper function to stop profiling. Name must match the name from profileStart
+    inline void profileStop(const char* name) {
+        log(PROFILE, name, PROFILE_STOP);
+    }
+
+    static MediaExtendedStats* Create(enum StatsType statsType, const char* name, pid_t tid);
+
+    //wrapper function to set window size.
+    inline void setWindowSize(int32_t windowSize) {
+        mWindowSize = windowSize;
+    }
+
+private:
+    sp<LogEntry> getLogEntry(const char *key, LogType type);
+
+protected:
+    KeyedVector<AString, sp<LogEntry> > mLogEntry;
+    Mutex mLock;
+
+    ExtendedStats(const ExtendedStats&) {}
+    AString mName;
+    pid_t mTid;
+
+    int32_t mWindowSize;
+};
+
+inline ExtendedStats::LogType operator| (ExtendedStats::LogType a, ExtendedStats::LogType b) {
+    return static_cast<ExtendedStats::LogType>(static_cast<int>(a) | static_cast<int>(b));
+}
+
+/**************************** MediaExtendedStats *********************/
+
+class MediaExtendedStats : public RefBase {
+public:
+    explicit MediaExtendedStats(const char* name, pid_t tid);
+
+    void logFrameDropped();
+    void logDimensions(int32_t width, int32_t height);
+    void logBitRate(int64_t frameSize, int64_t timestamp);
+
+    //only profile once, as opposed to up to kMaxOccurrences
+    inline void profileStartOnce(const char* name, bool condition = true) {
+        mProfileTimes->profileStartOnce(name, condition);
+    }
+
+    //wrapper function to start profiling latency
+    inline void profileStart(const char* name, bool condition = true) {
+        mProfileTimes->profileStart(name, condition);
+    }
+
+    //wrapper function to stop profiling. Name must match the name from profileStart
+    inline void profileStop(const char* name) {
+        mProfileTimes->profileStop(name);
+    }
+
+    sp<ExtendedStats> getProfileTimes() {
+        return mProfileTimes;
+    }
+    virtual void reset();
+
+    virtual void notifyPause(int64_t pauseTimeUs) = 0;
+    virtual void dump() = 0;
+
+    int32_t setFrameRate(int32_t frameRate) {
+        mFrameRate = frameRate;
+        mProfileTimes->setWindowSize(mFrameRate);
+    }
+
+protected:
+    AString mName;
+    pid_t mTid;
+
+    int64_t mCurrentConsecutiveFramesDropped;
+    int64_t mMaxConsecutiveFramesDropped;
+    int64_t mNumChainedDrops;
+    int64_t mFramesDropped;
+
+    int64_t mLastPauseTime;
+
+    Vector<int32_t> mWidthDimensions;
+    Vector<int32_t> mHeightDimensions;
+
+    sp<ExtendedStats> mProfileTimes;
+    int32_t mFrameRate;
+    Mutex mLock;
+
+    /* helper functions */
+    void resetConsecutiveFramesDropped();
+
+    virtual ~MediaExtendedStats();
+};
+
+/************************* PlayerExtendedStats *************************/
+
+class PlayerExtendedStats : public MediaExtendedStats {
+
+public:
+    explicit PlayerExtendedStats(const char* name, pid_t tid);
+
+    void logFrameRendered();
+
+    //functions to alert the logger of discontinuities in playback
+    void notifyPlaying(bool isPlaying);
+    void notifySeek(int64_t seekTimeUs);
+    void notifySeekDone();
+    void notifyEOS();
+
+    virtual void reset();
+    virtual void dump();
+    virtual void notifyPause(int64_t pauseTimeUs);
+
+private:
+    int64_t mFramesRendered;
+
+    int64_t mTotalPlayingTime;
+    int64_t mStartPlayingTime;
+    int64_t mLastSeekTime;
+
+    bool mEOS;
+    bool mPlaying;
+    bool mPaused; //used as a flag for seeking while paused
+
+    void updateTotalPlayingTime(bool wasPlaying);
+};
+
+class RecorderExtendedStats : public MediaExtendedStats {
+public:
+    explicit RecorderExtendedStats(const char* name, pid_t tid);
+
+    void logFrameEncoded();
+    void logRecordingDuration(int64_t duration);
+
+    virtual void reset();
+    virtual void dump();
+    virtual void notifyPause(int64_t pauseTimeUs);
+
+private:
+    int64_t mFramesEncoded;
+    int64_t mTotalRecordingTime;
+};
+
+}
+#endif  //EXTENDED_STATS_H_
diff --git a/include/media/stagefright/ExtendedWriter.h b/include/media/stagefright/ExtendedWriter.h
new file mode 100644
index 0000000..23944b0
--- /dev/null
+++ b/include/media/stagefright/ExtendedWriter.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution, Apache license notifications and license are retained
+ * for attribution purposes only.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef EXTENDED_WRITER_H_
+
+#define EXTENDED_WRITER_H_
+
+#include <stdio.h>
+
+#include <media/stagefright/MediaWriter.h>
+#include <utils/threads.h>
+#include <cutils/log.h>
+
+#define LITERAL_TO_STRING_INTERNAL(x)    #x
+#define LITERAL_TO_STRING(x) LITERAL_TO_STRING_INTERNAL(x)
+
+#define CHECK_EQ(x,y)                                                   \
+    LOG_ALWAYS_FATAL_IF(                                                \
+            (x) != (y),                                                 \
+            __FILE__ ":" LITERAL_TO_STRING(__LINE__) " " #x " != " #y)
+
+#define CHECK(x)                                                        \
+    LOG_ALWAYS_FATAL_IF(                                                \
+            !(x),                                                       \
+            __FILE__ ":" LITERAL_TO_STRING(__LINE__) " " #x)
+
+namespace android {
+
+struct MediaSource;
+struct MetaData;
+
+struct ExtendedWriter : public MediaWriter {
+    ExtendedWriter(const char *filename);
+    ExtendedWriter(int fd);
+
+    status_t initCheck() const;
+
+    virtual status_t addSource(const sp<MediaSource> &source);
+    virtual bool reachedEOS();
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual status_t pause();
+
+protected:
+    virtual ~ExtendedWriter();
+
+private:
+    FILE *mFile;
+    status_t mInitCheck;
+    sp<MediaSource> mSource;
+    bool mStarted;
+    volatile bool mPaused;
+    volatile bool mResumed;
+    volatile bool mDone;
+    volatile bool mReachedEOS;
+    pthread_t mThread;
+    int64_t mEstimatedSizeBytes;
+    int64_t mEstimatedDurationUs;
+
+    int32_t mFormat;
+
+    //QCP/EVRC header
+    struct QCPEVRCHeader
+    {
+        /* RIFF Section */
+        char riff[4];
+        unsigned int s_riff;
+        char qlcm[4];
+
+        /* Format chunk */
+        char fmt[4];
+        unsigned int s_fmt;
+        char mjr;
+        char mnr;
+        unsigned int data1;
+
+        /* UNIQUE ID of the codec */
+        unsigned short data2;
+        unsigned short data3;
+        char data4[8];
+        unsigned short ver;
+
+        /* Codec Info */
+        char name[80];
+        unsigned short abps;
+
+        /* average bits per sec of the codec */
+        unsigned short bytes_per_pkt;
+        unsigned short samp_per_block;
+        unsigned short samp_per_sec;
+        unsigned short bits_per_samp;
+        unsigned char vr_num_of_rates;
+
+        /* Rate Header fmt info */
+        unsigned char rvd1[3];
+        unsigned short vr_bytes_per_pkt[8];
+        unsigned int rvd2[5];
+
+        /* Vrat chunk */
+        unsigned char vrat[4];
+        unsigned int s_vrat;
+        unsigned int v_rate;
+        unsigned int size_in_pkts;
+
+        /* Data chunk */
+        unsigned char data[4];
+        unsigned int s_data;
+    } __attribute__ ((packed));
+
+    struct QCPEVRCHeader mHeader;
+    off_t mOffset; //note off_t
+
+    static void *ThreadWrapper(void *);
+    status_t threadFunc();
+    bool exceedsFileSizeLimit();
+    bool exceedsFileDurationLimit();
+
+    ExtendedWriter(const ExtendedWriter &);
+    ExtendedWriter &operator=(const ExtendedWriter &);
+
+    status_t writeQCPHeader( );
+    status_t writeEVRCHeader( );
+};
+
+}  // namespace android
+
+#endif  // AMR_WRITER_H_
diff --git a/include/media/stagefright/FFMPEGSoftCodec.h b/include/media/stagefright/FFMPEGSoftCodec.h
new file mode 100644
index 0000000..95354e7
--- /dev/null
+++ b/include/media/stagefright/FFMPEGSoftCodec.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef FFMPEG_SOFT_CODEC_H_
+#define FFMPEG_SOFT_CODEC_H_
+
+#include <media/IOMX.h>
+#include <media/MediaCodecInfo.h>
+
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/AString.h>
+
+#include <media/stagefright/MetaData.h>
+
+#include <OMX_Audio.h>
+#include <OMX_Video.h>
+
+namespace android {
+
+struct MediaCodecList;
+struct OMXCodec;
+
+struct FFMPEGSoftCodec {
+
+    enum {
+        kPortIndexInput  = 0,
+        kPortIndexOutput = 1
+    };
+    static void convertMessageToMetaData(
+            const sp<AMessage> &msg, sp<MetaData> &meta);
+
+    static const char* overrideComponentName(
+            uint32_t quirks, const sp<MetaData> &meta,
+            const char *mime, bool isEncoder);
+
+    static void overrideComponentName(
+            uint32_t quirks, const sp<AMessage> &msg,
+            AString* componentName, AString* mime,
+            int32_t isEncoder);
+
+    static status_t setSupportedRole(
+            const sp<IOMX> &omx, IOMX::node_id node,
+            bool isEncoder, const char *mime);
+
+    static status_t setAudioFormat(
+            const sp<MetaData> &meta, const char* mime,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+            bool isEncoder);
+
+    static status_t setAudioFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+            bool isEncoder);
+
+    static status_t setVideoFormat(
+            const sp<MetaData> &meta, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder, OMX_VIDEO_CODINGTYPE *compressionFormat);
+
+    static status_t setVideoFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder, OMX_VIDEO_CODINGTYPE *compressionFormat);
+
+    static status_t handleSupportedAudioFormats(
+            int format, AString* mime);
+
+    static status_t handleSupportedVideoFormats(
+            int format, AString* mime);
+
+private:
+    static const char* getMsgKey(int key);
+
+    static status_t setWMVFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setRVFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setFFmpegVideoFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setRawAudioFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setWMAFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setVORBISFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setRAFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setFLACFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setMP2Format(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setAC3Format(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setAPEFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setDTSFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+    static status_t setFFmpegAudioFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID);
+
+};
+
+}
+#endif
diff --git a/include/media/stagefright/MediaCodecList.h b/include/media/stagefright/MediaCodecList.h
index c2bbe4d..ac7b053 100644
--- a/include/media/stagefright/MediaCodecList.h
+++ b/include/media/stagefright/MediaCodecList.h
@@ -45,6 +45,10 @@ struct MediaCodecList : public BnMediaCodecList {
     virtual size_t countCodecs() const;
 
     virtual sp<MediaCodecInfo> getCodecInfo(size_t index) const {
+        if (index >= mCodecInfos.size()) {
+            ALOGE("b/24445127");
+            return NULL;
+        }
         return mCodecInfos.itemAt(index);
     }
 
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 13695d5..bab6432 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2014 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef MEDIA_DEFS_H_
@@ -27,6 +46,7 @@ extern const char *MEDIA_MIMETYPE_VIDEO_VP9;
 extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_HEVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
+extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4_DP;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
@@ -64,6 +84,49 @@ extern const char *MEDIA_MIMETYPE_TEXT_SUBRIP;
 extern const char *MEDIA_MIMETYPE_TEXT_VTT;
 extern const char *MEDIA_MIMETYPE_TEXT_CEA_608;
 
+#ifdef DOLBY_UDC
+extern const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC;
+extern const char *MEDIA_MIMETYPE_AUDIO_EAC3;
+#endif // DOLBY_END
+
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX311;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX4;
+extern const char *MEDIA_MIMETYPE_VIDEO_FLV1;
+extern const char *MEDIA_MIMETYPE_VIDEO_MJPEG;
+extern const char *MEDIA_MIMETYPE_VIDEO_RV;
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
+extern const char *MEDIA_MIMETYPE_VIDEO_HEVC;
+extern const char *MEDIA_MIMETYPE_VIDEO_FFMPEG;
+
+extern const char *MEDIA_MIMETYPE_AUDIO_AC3;
+extern const char *MEDIA_MIMETYPE_AUDIO_APE;
+extern const char *MEDIA_MIMETYPE_AUDIO_DTS;
+extern const char *MEDIA_MIMETYPE_AUDIO_PCM;
+extern const char *MEDIA_MIMETYPE_AUDIO_RA;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
+extern const char *MEDIA_MIMETYPE_AUDIO_FFMPEG;
+
+extern const char *MEDIA_MIMETYPE_CONTAINER_APE;
+extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
+extern const char *MEDIA_MIMETYPE_CONTAINER_DIVX;
+extern const char *MEDIA_MIMETYPE_CONTAINER_DTS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_FLAC;
+extern const char *MEDIA_MIMETYPE_CONTAINER_FLV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MOV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MP2;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MPG;
+extern const char *MEDIA_MIMETYPE_CONTAINER_RA;
+extern const char *MEDIA_MIMETYPE_CONTAINER_RM;
+extern const char *MEDIA_MIMETYPE_CONTAINER_TS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WEBM;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WMA;
+extern const char *MEDIA_MIMETYPE_CONTAINER_WMV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_VC1;
+extern const char *MEDIA_MIMETYPE_CONTAINER_HEVC;
+extern const char *MEDIA_MIMETYPE_CONTAINER_FFMPEG;
+
 }  // namespace android
 
 #endif  // MEDIA_DEFS_H_
diff --git a/include/media/stagefright/MediaExtractor.h b/include/media/stagefright/MediaExtractor.h
index 183933a..d630990 100644
--- a/include/media/stagefright/MediaExtractor.h
+++ b/include/media/stagefright/MediaExtractor.h
@@ -19,6 +19,7 @@
 #define MEDIA_EXTRACTOR_H_
 
 #include <utils/RefBase.h>
+#include <media/stagefright/DataSource.h>
 
 namespace android {
 
@@ -28,6 +29,18 @@ class MetaData;
 
 class MediaExtractor : public RefBase {
 public:
+    typedef MediaExtractor *(*CreateFunc)(const sp<DataSource> &source,
+            const char *mime, const sp<AMessage> &meta);
+
+    struct Plugin {
+        DataSource::SnifferFunc sniff;
+        CreateFunc create;
+    };
+
+    static Plugin *getPlugin() {
+        return &sPlugin;
+    }
+
     static sp<MediaExtractor> Create(
             const sp<DataSource> &source, const char *mime = NULL);
 
@@ -74,6 +87,7 @@ protected:
 
 private:
     bool mIsDrm;
+    static Plugin sPlugin;
 
     MediaExtractor(const MediaExtractor &);
     MediaExtractor &operator=(const MediaExtractor &);
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index 3f42790..3ac567a 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -1,6 +1,9 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
  *
+ * Copyright (c) 2009-2013, The Linux Foundation. All rights reserved.
+ * Not a Contribution
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -50,6 +53,10 @@ enum {
     kKeySampleRate        = 'srte',  // int32_t (audio sampling rate Hz)
     kKeyFrameRate         = 'frmR',  // int32_t (video frame rate fps)
     kKeyBitRate           = 'brte',  // int32_t (bps)
+    kKeyCodecId           = 'cdid',  // int32_t
+    kKeyBitsPerSample     = 'sbit',  // int32_t (DUPE of kKeySampleBits)
+    kKeyCodedSampleBits   = 'cosb',  // int32_t
+    kKeySampleFormat      = 'sfmt',  // int32_t
     kKeyESDS              = 'esds',  // raw data
     kKeyAACProfile        = 'aacp',  // int32_t
     kKeyAVCC              = 'avcc',  // raw data
@@ -126,6 +133,23 @@ enum {
 
     kKeyIsUnreadable      = 'unre',  // bool (int32_t)
 
+    kKeyRawCodecSpecificData = 'rcsd',  // raw data - added to support mmParser
+    kKeyDivXVersion       = 'DivX',  // int32_t
+    kKeyDivXDrm           = 'QDrm',  // void *
+    kKeyWMAEncodeOpt      = 'eopt',  // int32_t
+    kKeyWMABlockAlign     = 'blka',  // int32_t
+    kKeyWMAVersion        = 'wmav',  // int32_t
+    kKeyWMAAdvEncOpt1     = 'ade1',  // int16_t
+    kKeyWMAAdvEncOpt2     = 'ade2',  // int32_t
+    kKeyWMAFormatTag      = 'fmtt',  // int64_t
+    kKeyWMABitspersample  = 'bsps',  // int64_t
+    kKeyWMAVirPktSize     = 'vpks',  // int64_t
+    kKeyWMVProfile        = 'wmvp',  // int32_t
+
+    kKeyWMVVersion        = 'wmvv',  // int32_t
+    kKeyRVVersion         = '#rvv',  // int32_t
+    kKeyBlockAlign        = 'blk',   // int32_t , should be different from kKeyWMABlockAlign
+
     // An indication that a video buffer has been rendered.
     kKeyRendered          = 'rend',  // bool (int32_t)
 
@@ -173,6 +197,11 @@ enum {
     kKeyTrackIsDefault    = 'dflt', // bool (int32_t)
     // Similar to MediaFormat.KEY_IS_FORCED_SUBTITLE but pertains to av tracks as well.
     kKeyTrackIsForced     = 'frcd', // bool (int32_t)
+
+    kKeyTunnelException   = 'Ntnl', // not tunnel
+    // Indicate if it is OK to hold on to the MediaBuffer and not
+    // release it immediately
+    kKeyCanDeferRelease   = 'drel', // bool (int32_t)
 };
 
 enum {
@@ -182,6 +211,32 @@ enum {
     kTypeD263        = 'd263',
 };
 
+enum {
+    kTypeDivXVer_3_11,
+    kTypeDivXVer_4,
+    kTypeDivXVer_5,
+    kTypeDivXVer_6,
+};
+
+enum {
+    kTypeWMA,
+    kTypeWMAPro,
+    kTypeWMALossLess,
+};
+
+enum {
+    kTypeWMVVer_7, // WMV1
+    kTypeWMVVer_8, // WMV2
+    kTypeWMVVer_9, // WMV3
+};
+
+// http://en.wikipedia.org/wiki/RealVideo
+enum {
+    kTypeRVVer_G2, // rv20: RealVideo G2
+    kTypeRVVer_8,  // rv30: RealVideo 8
+    kTypeRVVer_9,  // rv40: RealVideo 9
+};
+
 class MetaData : public RefBase {
 public:
     MetaData();
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index e341160..d0ef913 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -100,6 +100,7 @@ struct OMXCodec : public MediaSource,
         kSupportsMultipleFramesPerInputBuffer = 1024,
         kRequiresLargerEncoderOutputBuffer    = 2048,
         kOutputBuffersAreUnreadable           = 4096,
+        kRequiresGlobalFlush                  = 0x20000000, // 2^29
     };
 
     struct CodecNameAndQuirks {
@@ -139,12 +140,16 @@ private:
         EXECUTING_TO_IDLE,
         IDLE_TO_LOADED,
         RECONFIGURING,
+        PAUSING,
+        FLUSHING,
+        PAUSED,
         ERROR
     };
 
     enum {
         kPortIndexInput  = 0,
-        kPortIndexOutput = 1
+        kPortIndexOutput = 1,
+        kPortIndexBoth   = -1,
     };
 
     enum PortStatus {
@@ -169,6 +174,7 @@ private:
         size_t mSize;
         void *mData;
         MediaBuffer *mMediaBuffer;
+        bool mOutputCropChanged;
     };
 
     struct CodecSpecificData {
@@ -265,6 +271,8 @@ private:
     status_t setupH263EncoderParameters(const sp<MetaData>& meta);
     status_t setupMPEG4EncoderParameters(const sp<MetaData>& meta);
     status_t setupAVCEncoderParameters(const sp<MetaData>& meta);
+    status_t setFFmpegVideoFormat(const sp<MetaData> &inputFormat);
+    status_t setFFmpegAudioFormat(const sp<MetaData> &inputFormat);
     status_t findTargetColorFormat(
             const sp<MetaData>& meta, OMX_COLOR_FORMATTYPE *colorFormat);
 
@@ -350,6 +358,7 @@ private:
     status_t applyRotation();
     status_t waitForBufferFilled_l();
 
+    status_t resumeLocked(bool drainInputBuf);
     int64_t getDecodingTimeUs();
 
     status_t parseHEVCCodecSpecificData(
@@ -363,6 +372,10 @@ private:
 
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
+
+    int32_t mNumBFrames;
+    bool mInSmoothStreamingMode;
+    bool mOutputCropChanged;
 };
 
 struct CodecCapabilities {
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 85e98f1..8cec056 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -40,6 +40,7 @@
 #include <media/stagefright/NativeWindowWrapper.h>
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
 
 #include <media/hardware/HardwareAPI.h>
 
@@ -631,11 +632,27 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         return err;
     }
 
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    status_t omxresults;
+    
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            omxresults = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            if (omxresults != OK) {
+            }
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;   
+        break;
+        default:
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;   
+        break;
+    }
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -1144,7 +1161,11 @@ status_t ACodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
-        return ERROR_UNSUPPORTED;
+        status_t err = BAD_VALUE;
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
+        }
+        return err;
     }
 
     const char *role =
@@ -1445,7 +1466,8 @@ status_t ACodec::configureCodec(
     if (video) {
         // determine need for software renderer
         bool usingSwRenderer = false;
-        if (haveNativeWindow && mComponentName.startsWith("OMX.google.")) {
+        if (haveNativeWindow && (mComponentName.startsWith("OMX.google.") ||
+                                 mComponentName.startsWith("OMX.ffmpeg."))) {
             usingSwRenderer = true;
             haveNativeWindow = false;
         }
@@ -1655,6 +1677,21 @@ status_t ACodec::configureCodec(
         } else {
             err = setupEAC3Codec(encoder, numChannels, sampleRate);
         }
+    } else {
+        if (encoder) {
+            int32_t numChannels, sampleRate;
+            if (msg->findInt32("channel-count", &numChannels)
+                  && msg->findInt32("sample-rate", &sampleRate)) {
+                setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+            }
+        }
+        if(!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setAudioFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder);
+        }
+        if (err != OK) {
+            return err;
+        }
     }
 
     if (err != OK) {
@@ -1680,6 +1717,8 @@ status_t ACodec::configureCodec(
         err = setMinBufferSize(kPortIndexInput, (size_t)maxInputSize);
     } else if (!strcmp("OMX.Nvidia.aac.decoder", mComponentName.c_str())) {
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
+    } else if (!strncmp(mComponentName.c_str(), "OMX.brcm.video.h264.hw.decoder", 30)) {
+        setMinBufferSize(kPortIndexInput, (1080 * 720 * 3) / 2);
     }
 
     mBaseOutputFormat = outputFormat;
@@ -2348,6 +2387,16 @@ status_t ACodec::setupVideoDecoder(
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            return err;
+        }
+    }
+
+    if (err != OK) {
         return err;
     }
 
@@ -2498,6 +2547,16 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            return err;
+        }
+    }
+
+    if (err != OK) {
         return err;
     }
 
@@ -3833,6 +3892,22 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                 }
 
                 default:
+                    AString mimeType;
+                    status_t err = ERROR_UNSUPPORTED;
+
+                    if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+                        err = FFMPEGSoftCodec::handleSupportedAudioFormats(
+                                audioDef->eEncoding, &mimeType);
+                    }
+                    if (err == OK) {
+                        int channelCount = 0;
+                        int sampleRate = 0;
+                        notify->setString("mime", mimeType.c_str());
+                        notify->setInt32("channel-count", channelCount);
+                        notify->setInt32("sample-rate", sampleRate);
+                        break;
+                    }
+
                     ALOGE("UNKNOWN AUDIO CODING: %d\n", audioDef->eEncoding);
                     TRESPASS();
             }
@@ -5071,6 +5146,20 @@ bool ACodec::LoadedState::onConfigureComponent(
         return false;
     }
 
+    sp<RefBase> obj;
+    if (msg->findObject("native-window", &obj)
+            && strncmp("OMX.google.", mCodec->mComponentName.c_str(), 11)
+            && strncmp("OMX.ffmpeg.", mCodec->mComponentName.c_str(), 11)) {
+        sp<NativeWindowWrapper> nativeWindow(
+                static_cast<NativeWindowWrapper *>(obj.get()));
+        CHECK(nativeWindow != NULL);
+        mCodec->mNativeWindow = nativeWindow->getNativeWindow();
+        native_window_set_scaling_mode(
+                mCodec->mNativeWindow.get(),
+                NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
+    }
+    CHECK_EQ((status_t)OK, mCodec->initNativeWindow());
+
     {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", CodecBase::kWhatComponentConfigured);
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 193f8a7..c97e8d0 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -44,6 +44,7 @@ LOCAL_SRC_FILES:=                         \
         NuMediaExtractor.cpp              \
         OMXClient.cpp                     \
         OMXCodec.cpp                      \
+        ExtendedCodec.cpp                 \
         OggExtractor.cpp                  \
         SampleIterator.cpp                \
         SampleTable.cpp                   \
@@ -60,6 +61,10 @@ LOCAL_SRC_FILES:=                         \
         WVMExtractor.cpp                  \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
+        ExtendedExtractor.cpp             \
+        ExtendedUtils.cpp                 \
+        ExtendedStats.cpp                 \
+        FFMPEGSoftCodec.cpp               \
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
@@ -118,6 +123,10 @@ LOCAL_SHARED_LIBRARIES += \
         libstagefright_foundation \
         libdl
 
+# FFMPEG plugin
+LOCAL_C_INCLUDES += \
+        $(TOP)/external/stagefright-plugins/include
+
 LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE:= libstagefright
diff --git a/media/libstagefright/ExtendedCodec.cpp b/media/libstagefright/ExtendedCodec.cpp
new file mode 100644
index 0000000..e157e13
--- /dev/null
+++ b/media/libstagefright/ExtendedCodec.cpp
@@ -0,0 +1,1505 @@
+/*
+ * Copyright (c) 2013 - 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ExtendedCodec"
+#include <utils/Log.h>
+#include <cutils/properties.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaCodecList.h>
+
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/ExtendedCodec.h>
+#include <media/stagefright/OMXCodec.h>
+
+#include <media/stagefright/FFMPEGSoftCodec.h>
+
+#define ARG_TOUCH(x) (void)x
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+#include <QCMetaData.h>
+#include <QCMediaDefs.h>
+#include <OMX_QCOMExtns.h>
+#include <OMX_Component.h>
+#include <OMX_VideoExt.h>
+#include <OMX_IndexExt.h>
+#include <QOMX_AudioExtensions.h>
+#include <QOMX_AudioIndexExtensions.h>
+#include "include/ExtendedUtils.h"
+#endif
+
+namespace android {
+enum MetaKeyType{
+    INT32, INT64, STRING, DATA, CSD
+};
+
+struct MetaKeyEntry{
+    int MetaKey;
+    const char* MsgKey;
+    MetaKeyType KeyType;
+};
+
+static const MetaKeyEntry MetaKeyTable[] {
+#if ENABLE_AV_ENHANCEMENTS
+   {kKeyAacCodecSpecificData , "aac-codec-specific-data", CSD},
+   {kKeyDivXVersion          , "divx-version"           , INT32},  // int32_t
+   {kKeyDivXDrm              , "divx-drm"               , DATA},  // void *
+   {kKeyWMAEncodeOpt         , "wma-encode-opt"         , INT32},  // int32_t
+   {kKeyWMABlockAlign        , "wma-block-align"        , INT32},  // int32_t
+   {kKeyWMAAdvEncOpt1        , "wma-adv-enc-opt1"       , INT32},  // int16_t
+   {kKeyWMAAdvEncOpt2        , "wma-adv-enc-opt2"       , INT32},  // int32_t
+   {kKeyWMAFormatTag         , "wma-format-tag"         , INT32},  // int32_t
+   {kKeyWMABitspersample     , "wma-bits-per-sample"    , INT32},  // int32_t
+   {kKeyWMAVirPktSize        , "wma-vir-pkt-size"       , INT32},  // int32_t
+   {kKeyWMAChannelMask       , "wma-channel-mask"       , INT32},  // int32_t
+   {kKeyFileFormat           , "file-format"            , STRING},  // cstring
+
+   {kkeyAacFormatAdif        , "aac-format-adif"        , INT32},  // bool (int32_t)
+   {kkeyAacFormatLtp         , "aac-format-ltp"         , INT32},
+
+   //DTS subtype
+   {kKeyDTSSubtype           , "dts-subtype"            , INT32},  //int32_t
+
+   //Extractor sets this
+   {kKeyUseArbitraryMode     , "use-arbitrary-mode"     , INT32},  //bool (int32_t)
+   {kKeySmoothStreaming      , "smooth-streaming"       , INT32},  //bool (int32_t)
+   {kKeyHFR                  , "hfr"                    , INT32},  // int32_t
+#endif
+
+   {kKeyBitRate              , "bitrate"                , INT32},
+   {kKeySampleRate           , "sample-rate"            , INT32},
+   {kKeyChannelCount         , "channel-count"          , INT32},
+   {kKeyRawCodecSpecificData , "raw-codec-specific-data", CSD},
+
+   {kKeyBitsPerSample        , "bits-per-sample"        , INT32},
+   {kKeyCodecId              , "codec-id"               , INT32},
+   {kKeySampleFormat         , "sample-format"          , INT32},
+   {kKeyBlockAlign           , "block-align"            , INT32},
+   {kKeyCodedSampleBits      , "coded-sample-bits"      , INT32},
+   {kKeyAACAOT               , "aac-profile"            , INT32},
+   {kKeyRVVersion            , "rv-version"             , INT32},
+   {kKeyWMAVersion           , "wma-version"            , INT32},  // int32_t
+   {kKeyWMVVersion           , "wmv-version"            , INT32},
+};
+
+const char* ExtendedCodec::getMsgKey(int key) {
+    static const size_t numMetaKeys =
+                     sizeof(MetaKeyTable) / sizeof(MetaKeyTable[0]);
+    size_t i;
+    for (i = 0; i < numMetaKeys; ++i) {
+        if (key == MetaKeyTable[i].MetaKey) {
+            return MetaKeyTable[i].MsgKey;
+        }
+    }
+    return "unknown";
+}
+
+status_t ExtendedCodec::convertMetaDataToMessage(
+        const sp<MetaData> &meta, sp<AMessage> *format) {
+    const char * str_val;
+    int32_t int32_val;
+    int64_t int64_val;
+    uint32_t data_type;
+    const void * data;
+    size_t size;
+    static const size_t numMetaKeys =
+                     sizeof(MetaKeyTable) / sizeof(MetaKeyTable[0]);
+    size_t i;
+    for (i = 0; i < numMetaKeys; ++i) {
+        if (MetaKeyTable[i].KeyType == INT32 &&
+            meta->findInt32(MetaKeyTable[i].MetaKey, &int32_val)) {
+            ALOGV("found metakey %s of type int32", MetaKeyTable[i].MsgKey);
+            format->get()->setInt32(MetaKeyTable[i].MsgKey, int32_val);
+        } else if (MetaKeyTable[i].KeyType == INT64 &&
+                 meta->findInt64(MetaKeyTable[i].MetaKey, &int64_val)) {
+            ALOGV("found metakey %s of type int64", MetaKeyTable[i].MsgKey);
+            format->get()->setInt64(MetaKeyTable[i].MsgKey, int64_val);
+        } else if (MetaKeyTable[i].KeyType == STRING &&
+                 meta->findCString(MetaKeyTable[i].MetaKey, &str_val)) {
+            ALOGV("found metakey %s of type string", MetaKeyTable[i].MsgKey);
+            format->get()->setString(MetaKeyTable[i].MsgKey, str_val);
+        } else if ( (MetaKeyTable[i].KeyType == DATA ||
+                   MetaKeyTable[i].KeyType == CSD) &&
+                   meta->findData(MetaKeyTable[i].MetaKey, &data_type, &data, &size)) {
+            ALOGV("found metakey %s of type data", MetaKeyTable[i].MsgKey);
+            if (MetaKeyTable[i].KeyType == CSD) {
+                const char *mime;
+                CHECK(meta->findCString(kKeyMIMEType, &mime));
+                if (strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {
+                    sp<ABuffer> buffer = new ABuffer(size);
+                    memcpy(buffer->data(), data, size);
+                    buffer->meta()->setInt32("csd", true);
+                    buffer->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-0", buffer);
+                } else {
+                    const uint8_t *ptr = (const uint8_t *)data;
+                    CHECK(size >= 8);
+                    int seqLength = 0, picLength = 0;
+                    for (size_t i = 4; i < (size - 4); i++)
+                    {
+                        if ((*(ptr + i) == 0) && (*(ptr + i + 1) == 0) &&
+                           (*(ptr + i + 2) == 0) && (*(ptr + i + 3) == 1))
+                            seqLength = i;
+                    }
+                    sp<ABuffer> buffer = new ABuffer(seqLength);
+                    memcpy(buffer->data(), data, seqLength);
+                    buffer->meta()->setInt32("csd", true);
+                    buffer->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-0", buffer);
+                    picLength=size-seqLength;
+                    sp<ABuffer> buffer1 = new ABuffer(picLength);
+                    memcpy(buffer1->data(), (const uint8_t *)data + seqLength, picLength);
+                    buffer1->meta()->setInt32("csd", true);
+                    buffer1->meta()->setInt64("timeUs", 0);
+                    format->get()->setBuffer("csd-1", buffer1);
+                }
+            } else {
+                sp<ABuffer> buffer = new ABuffer(size);
+                memcpy(buffer->data(), data, size);
+                format->get()->setBuffer(MetaKeyTable[i].MsgKey, buffer);
+            }
+        }
+    }
+    return OK;
+}
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+
+uint32_t ExtendedCodec::getComponentQuirks(
+        const sp<MediaCodecInfo> &info) {
+    uint32_t quirks = 0;
+
+    if (info->hasQuirk("requires-wma-pro-component")) {
+        quirks |= kRequiresWMAProComponent;
+    }
+    return quirks;
+}
+
+const char* ExtendedCodec::overrideComponentName(
+        uint32_t quirks, const sp<MetaData> &meta, const char *mime, bool isEncoder) {
+
+    const char* componentName = FFMPEGSoftCodec::overrideComponentName(quirks, meta, mime, isEncoder);
+
+    if (quirks & kRequiresWMAProComponent)
+    {
+       int32_t version = 0;
+       if ((meta->findInt32(kKeyWMAVersion, &version))) {
+          if (version==kTypeWMA) {
+             componentName = "OMX.qcom.audio.decoder.wma";
+          } else if (version==kTypeWMAPro) {
+             componentName = "OMX.qcom.audio.decoder.wma10Pro";
+          } else if (version==kTypeWMALossLess) {
+             componentName = "OMX.qcom.audio.decoder.wmaLossLess";
+          }
+       }
+    }
+
+    return componentName;
+}
+
+void ExtendedCodec::overrideComponentName(
+        uint32_t quirks, const sp<AMessage> &msg, AString* componentName, AString* mime, int32_t isEncoder) {
+
+    FFMPEGSoftCodec::overrideComponentName(quirks, msg, componentName, mime, isEncoder);
+
+    if (quirks & kRequiresWMAProComponent)
+    {
+       int32_t version = 0;
+       if ((msg->findInt32(getMsgKey(kKeyWMAVersion), &version))) {
+          if (version==kTypeWMA) {
+             componentName->setTo("OMX.qcom.audio.decoder.wma");
+          } else if (version==kTypeWMAPro) {
+             componentName->setTo("OMX.qcom.audio.decoder.wma10Pro");
+          } else if (version==kTypeWMALossLess) {
+             componentName->setTo("OMX.qcom.audio.decoder.wmaLossLess");
+          }
+       }
+    }
+}
+
+void ExtendedCodec::overrideMimeType(
+        const sp<AMessage> &msg, AString* mime) {
+
+    if (!strncmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_WMA,
+         strlen(MEDIA_MIMETYPE_AUDIO_WMA))) {
+        int32_t WMAVersion = 0;
+        if ((msg->findInt32(getMsgKey(kKeyWMAVersion), &WMAVersion))) {
+            if (WMAVersion==kTypeWMA) {
+                //no need to update mime type
+            } else if (WMAVersion==kTypeWMAPro) {
+                mime->setTo("audio/x-ms-wma-pro");
+            } else if (WMAVersion==kTypeWMALossLess) {
+                mime->setTo("audio/x-ms-wma-lossless");
+            } else {
+                ALOGE("could not set valid wma mime type");
+            }
+        }
+    }
+}
+
+template<class T>
+static void InitOMXParams(T *params) {
+    params->nSize = sizeof(T);
+    params->nVersion.s.nVersionMajor = 1;
+    params->nVersion.s.nVersionMinor = 0;
+    params->nVersion.s.nRevision = 0;
+    params->nVersion.s.nStep = 0;
+}
+
+status_t ExtendedCodec::setDIVXFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, int port_index) {
+    status_t err = OK;
+
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime) ||
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime) ||
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+        ALOGV("Setting the QOMX_VIDEO_PARAM_DIVXTYPE params ");
+        QOMX_VIDEO_PARAM_DIVXTYPE paramDivX;
+        InitOMXParams(&paramDivX);
+        paramDivX.nPortIndex = port_index;
+        int32_t DivxVersion = 0;
+        if (!msg->findInt32(getMsgKey(kKeyDivXVersion), &DivxVersion)) {
+            DivxVersion = kTypeDivXVer_4;
+            ALOGW("Divx version key missing, initializing the version to %d", DivxVersion);
+        }
+        ALOGV("Divx Version Type %d", DivxVersion);
+
+        if (DivxVersion == kTypeDivXVer_4) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat4;
+        } else if (DivxVersion == kTypeDivXVer_5) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat5;
+        } else if (DivxVersion == kTypeDivXVer_6) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat6;
+        } else if (DivxVersion == kTypeDivXVer_3_11 ) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat311;
+        } else {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormatUnused;
+        }
+        paramDivX.eProfile = (QOMX_VIDEO_DIVXPROFILETYPE)0;    //Not used for now.
+
+        err =  OMXhandle->setParameter(nodeID,
+                         (OMX_INDEXTYPE)OMX_QcomIndexParamVideoDivx,
+                         &paramDivX, sizeof(paramDivX));
+    }
+
+    return err;
+}
+
+void ExtendedCodec::getRawCodecSpecificData(
+        const sp<MetaData> &meta, const void* &data, size_t &size) {
+    uint32_t type = 0;
+    size = 0;
+    if (meta->findData(kKeyRawCodecSpecificData, &type, &data, &size)) {
+        ALOGV("OMXCodec::configureCodec found kKeyRawCodecSpecificData of size %d\n", size);
+    }
+}
+
+sp<ABuffer> ExtendedCodec::getRawCodecSpecificData(
+        const sp<AMessage> &msg) {
+    sp<ABuffer> buffer;
+    if (msg->findBuffer(getMsgKey(kKeyRawCodecSpecificData), &buffer)) {
+        ALOGV("ACodec found kKeyRawCodecSpecificData of size %d\n", buffer->size());
+        return buffer;
+    }
+    return NULL;
+}
+
+void ExtendedCodec::getAacCodecSpecificData(
+        const sp<MetaData> &meta, const void* &data, size_t &size) {
+    uint32_t type = 0;
+    size = 0;
+    if (meta->findData(kKeyAacCodecSpecificData, &type, &data, &size)) {
+        ALOGV("OMXCodec::configureCodec found kKeyAacCodecSpecificData of size %d\n", size);
+    }
+}
+
+sp<ABuffer> ExtendedCodec::getAacCodecSpecificData(
+        const sp<AMessage> &msg) {
+    sp<ABuffer> buffer;
+    if (msg->findBuffer(getMsgKey(kKeyAacCodecSpecificData), &buffer)) {
+        ALOGV("ACodec found kKeyAacCodecSpecificData of size %d\n", buffer->size());
+        return buffer;
+    }
+    return NULL;
+}
+
+status_t ExtendedCodec::setAudioFormat(
+        const sp<MetaData> &meta, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    return setAudioFormat(msg, mime, OMXhandle, nodeID, isEncoder);
+}
+
+status_t ExtendedCodec::setAudioFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    ALOGV("setAudioFormat called");
+    status_t err = OK;
+
+#ifdef USE_QCOM_AC3
+    if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_EAC3, mime)) {
+        int32_t numChannels, sampleRate;
+        CHECK(msg->findInt32("channel-count", &numChannels));
+        CHECK(msg->findInt32("sample-rate", &sampleRate));
+        /* Commenting following call as AC3 soft decoder does not
+         need it and it causes issue with playback*/
+        //setAC3Format(numChannels, sampleRate, OMXhandle, nodeID);
+    } else
+#endif
+    if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_EVRC, mime)) {
+        int32_t numChannels, sampleRate;
+        CHECK(msg->findInt32("channel-count", &numChannels));
+        CHECK(msg->findInt32("sample-rate", &sampleRate));
+        setEVRCFormat(numChannels, sampleRate, OMXhandle, nodeID, isEncoder );
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_QCELP, mime)) {
+        int32_t numChannels, sampleRate;
+        CHECK(msg->findInt32("channel-count", &numChannels));
+        CHECK(msg->findInt32("sample-rate", &sampleRate));
+        setQCELPFormat(numChannels, sampleRate, OMXhandle, nodeID, isEncoder);
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_WMA, mime))  {
+        err = setWMAFormat(msg, OMXhandle, nodeID, isEncoder);
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS, mime)) {
+        int32_t numChannels, sampleRate;
+        CHECK(msg->findInt32("channel-count", &numChannels));
+        CHECK(msg->findInt32("sample-rate", &sampleRate));
+        err = setAMRWBPLUSFormat(numChannels, sampleRate, OMXhandle, nodeID);
+    }
+    return err;
+}
+
+status_t ExtendedCodec::setVideoFormat(
+        const sp<MetaData> &meta, const char* mime,
+        OMX_VIDEO_CODINGTYPE *compressionFormat) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    return setVideoFormat(msg, mime, compressionFormat);
+}
+
+status_t ExtendedCodec::setVideoFormat(
+        const sp<AMessage> &msg, const char* mime,
+        OMX_VIDEO_CODINGTYPE *compressionFormat) {
+    status_t retVal = OK;
+    ALOGV("setVideoFormat: %s", msg->debugString(0).c_str());
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
+        *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
+        *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+        *compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
+        *compressionFormat = OMX_VIDEO_CodingWMV;
+#ifdef QCOM_ADDITIONAL_CODECS
+    } else if (!strcasecmp(MEDIA_MIMETYPE_CONTAINER_MPEG2, mime)) {
+        *compressionFormat = OMX_VIDEO_CodingMPEG2;
+#endif
+    } else {
+        retVal = BAD_VALUE;
+    }
+
+    return retVal;
+}
+
+status_t ExtendedCodec::setSupportedRole(
+        const sp<IOMX> &omx, IOMX::node_id node,
+        bool isEncoder, const char *mime) {
+    ALOGV("setSupportedRole Called %s", mime);
+    struct MimeToRole {
+        const char *mime;
+        const char *decoderRole;
+        const char *encoderRole;
+    };
+
+    static const MimeToRole kQCMimeToRole[] = {
+        { MEDIA_MIMETYPE_AUDIO_EVRC,
+          "audio_decoder.evrchw", "audio_encoder.evrc" },
+        { MEDIA_MIMETYPE_AUDIO_QCELP,
+          "audio_decoder,qcelp13Hw", "audio_encoder.qcelp13" },
+        { MEDIA_MIMETYPE_VIDEO_DIVX,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX4,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX311,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_WMV,
+          "video_decoder.vc1",  NULL },
+#ifdef USE_QCOM_AC3
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+          "audio_decoder.ac3", NULL },
+#endif
+        { MEDIA_MIMETYPE_AUDIO_WMA,
+          "audio_decoder.wma", NULL },
+        { MEDIA_MIMETYPE_VIDEO_HEVC,
+          "video_decoder.hevc", "video_encoder.hevc" },
+        };
+
+    static const size_t kNumMimeToRole =
+                     sizeof(kQCMimeToRole) / sizeof(kQCMimeToRole[0]);
+
+    size_t i;
+    for (i = 0; i < kNumMimeToRole; ++i) {
+        if (!strcasecmp(mime, kQCMimeToRole[i].mime)) {
+            break;
+        }
+    }
+
+    if (i == kNumMimeToRole) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    const char *role =
+        isEncoder ? kQCMimeToRole[i].encoderRole
+                  : kQCMimeToRole[i].decoderRole;
+
+    if (role != NULL) {
+        OMX_PARAM_COMPONENTROLETYPE roleParams;
+        InitOMXParams(&roleParams);
+
+        strlcpy((char *)roleParams.cRole,
+                role, OMX_MAX_STRINGNAME_SIZE);
+
+        status_t err = omx->setParameter(
+                node, OMX_IndexParamStandardComponentRole,
+                &roleParams, sizeof(roleParams));
+
+        if (err != OK) {
+            ALOGW("Failed to set standard component role '%s'.", role);
+            return err;
+        }
+    }
+    return OK;
+}
+
+status_t ExtendedCodec::getSupportedAudioFormatInfo(
+        const AString* mime,
+        sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID,
+        int portIndex,
+        int* channelCount,
+        int* sampleRate) {
+    status_t retVal = OK;
+    if (!strncmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_QCELP, strlen(MEDIA_MIMETYPE_AUDIO_QCELP))) {
+        OMX_AUDIO_PARAM_QCELP13TYPE params;
+        InitOMXParams(&params);
+        params.nPortIndex = portIndex;
+        CHECK_EQ(OMXhandle->getParameter(
+                   nodeID, OMX_IndexParamAudioQcelp13, &params, sizeof(params)), (status_t)OK);
+        *channelCount = params.nChannels;
+        /* QCELP supports only 8k sample rate*/
+        *sampleRate = 8000;
+    } else if (!strncmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_EVRC, strlen(MEDIA_MIMETYPE_AUDIO_EVRC))) {
+        OMX_AUDIO_PARAM_EVRCTYPE params;
+        InitOMXParams(&params);
+        params.nPortIndex = portIndex;
+        CHECK_EQ(OMXhandle->getParameter(
+                   nodeID, OMX_IndexParamAudioEvrc, &params, sizeof(params)), (status_t)OK);
+        *channelCount = params.nChannels;
+        /* EVRC supports only 8k sample rate*/
+        *sampleRate = 8000;
+    } else if (!strncmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS, strlen(MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS))) {
+        OMX_INDEXTYPE index;
+        QOMX_AUDIO_PARAM_AMRWBPLUSTYPE params;
+
+        InitOMXParams(&params);
+        params.nPortIndex = portIndex;
+        OMXhandle->getExtensionIndex(nodeID, OMX_QCOM_INDEX_PARAM_AMRWBPLUS, &index);
+        CHECK_EQ(OMXhandle->getParameter(nodeID, index, &params, sizeof(params)),(status_t)OK);
+        *channelCount = params.nChannels;
+        *sampleRate = params.nSampleRate;
+    } else if (!strncmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_WMA, strlen(MEDIA_MIMETYPE_AUDIO_WMA))) {
+        status_t err = OK;
+        OMX_INDEXTYPE index;
+        OMX_AUDIO_PARAM_WMATYPE paramWMA;
+        QOMX_AUDIO_PARAM_WMA10PROTYPE paramWMA10;
+
+        InitOMXParams(&paramWMA);
+        paramWMA.nPortIndex = portIndex;
+        err = OMXhandle->getParameter(
+                   nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+        if(err == OK) {
+            ALOGV("WMA format");
+            *channelCount = paramWMA.nChannels;
+            *sampleRate = paramWMA.nSamplingRate;
+        } else {
+            InitOMXParams(&paramWMA10);
+            paramWMA10.nPortIndex = portIndex;
+            OMXhandle->getExtensionIndex(nodeID,"OMX.Qualcomm.index.audio.wma10Pro",&index);
+            CHECK_EQ(OMXhandle->getParameter(nodeID, index, &paramWMA10, sizeof(paramWMA10)),(status_t)OK);
+            ALOGV("WMA10 format");
+            *channelCount = paramWMA10.nChannels;
+            *sampleRate = paramWMA10.nSamplingRate;
+        }
+    } else {
+        retVal = BAD_VALUE;
+    }
+    return retVal;
+}
+
+status_t ExtendedCodec::handleSupportedAudioFormats(int format, AString* mime) {
+    ALOGV("handleSupportedAudioFormats called for format:%x",format);
+    status_t retVal = OK;
+    if (format == OMX_AUDIO_CodingQCELP13 ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_QCELP;
+    } else if (format == OMX_AUDIO_CodingEVRC ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_EVRC;
+    } else if (format == OMX_AUDIO_CodingWMA ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_WMA;
+    } else if (format == QOMX_IndexParamAudioAmrWbPlus ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS;
+    } else {
+        retVal = BAD_VALUE;
+    }
+    return retVal;
+}
+
+status_t ExtendedCodec::setupHEVCEncoderParameters(
+            const sp<MetaData> &meta, const sp<IOMX> &omx,
+            IOMX::node_id node, const char* componentName,
+            int portIndex, const sp<OMXCodec> &target) {
+    int32_t iFramesInterval, frameRate, bitRate;
+    bool success = meta->findInt32(kKeyBitRate, &bitRate);
+    success = success && meta->findInt32(kKeyFrameRate, &frameRate);
+    success = success && meta->findInt32(kKeyIFramesInterval, &iFramesInterval);
+    if(!success) {
+        ALOGE("Error: failed to find bitRate / frameRate / iFramesInterval");
+        return UNKNOWN_ERROR;
+    }
+
+    OMX_VIDEO_PARAM_HEVCTYPE h265type;
+    InitOMXParams(&h265type);
+    h265type.nPortIndex = portIndex;
+
+    status_t err = omx->getParameter(
+            node, (OMX_INDEXTYPE)OMX_IndexParamVideoHevc, &h265type, sizeof(h265type));
+    if (err != OK) {
+        ALOGE("Error: getParameter IndexParamVideoHevc failed");
+        return UNKNOWN_ERROR;
+    }
+
+    // Check profile and level parameters
+    CodecProfileLevel defaultProfileLevel, profileLevel;
+    defaultProfileLevel.mProfile = h265type.eProfile;
+    defaultProfileLevel.mLevel = h265type.eLevel;
+    err = target->getVideoProfileLevel(meta, defaultProfileLevel, profileLevel);
+    if (err != OK) {
+        ALOGE("Error: failed to get Profile / Level");
+        return err;
+    }
+
+    h265type.eProfile = static_cast<OMX_VIDEO_HEVCPROFILETYPE>(profileLevel.mProfile);
+    h265type.eLevel = static_cast<OMX_VIDEO_HEVCLEVELTYPE>(profileLevel.mLevel);
+
+    if (h265type.eProfile == OMX_VIDEO_HEVCProfileMain ||
+        h265type.eProfile == OMX_VIDEO_HEVCProfileMain10){
+        ALOGI("Profile type is %d", h265type.eProfile);
+    } else {
+        ALOGW("Use main profile instead of %d for HEVC recording",
+            h265type.eProfile);
+        h265type.eProfile = OMX_VIDEO_HEVCProfileMain;
+    }
+
+    return err;
+}
+
+status_t ExtendedCodec::handleSupportedVideoFormats(int format, AString* mime) {
+    ALOGV("handleSupportedVideoFormats called");
+    status_t retVal = OK;
+    if (format == QOMX_VIDEO_CodingHevc) {
+        *mime = MEDIA_MIMETYPE_VIDEO_HEVC;
+    } else {
+        retVal = BAD_VALUE;
+    }
+    return retVal;
+}
+
+bool ExtendedCodec::checkIfCompressionHEVC(int format) {
+    bool retVal = false;
+    if (format == QOMX_VIDEO_CodingHevc) {
+        retVal = true;
+    }
+    return retVal;
+}
+
+void ExtendedCodec::configureFramePackingFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+        const char* componentName) {
+    //ignore non QC components
+    if (strncmp(componentName, "OMX.qcom.", 9)) {
+        return;
+    }
+
+    int32_t mode = 0;
+    OMX_QCOM_PARAM_PORTDEFINITIONTYPE portFmt;
+    portFmt.nPortIndex = kPortIndexInput;
+
+    if (msg->findInt32(getMsgKey(kKeyUseArbitraryMode), &mode) && mode) {
+        ALOGI("Decoder will be in arbitrary mode");
+        portFmt.nFramePackingFormat = OMX_QCOM_FramePacking_Arbitrary;
+    } else {
+        ALOGI("Decoder will be in frame by frame mode");
+        portFmt.nFramePackingFormat = OMX_QCOM_FramePacking_OnlyOneCompleteFrame;
+    }
+    status_t err = OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_QcomIndexPortDefn,
+            (void *)&portFmt, sizeof(portFmt));
+    if (err != OK) {
+        ALOGW("Failed to set frame packing format on component");
+    }
+}
+
+void ExtendedCodec::configureFramePackingFormat(
+        const sp<MetaData> &meta, sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+        const char* componentName) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    configureFramePackingFormat(msg, OMXhandle, nodeID, componentName);
+}
+
+void ExtendedCodec::configureVideoDecoder(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        const uint32_t flags, IOMX::node_id nodeID, const char* componentName ) {
+    if ((strncmp(componentName, "OMX.qcom.", 9)) && (strncmp(componentName, "OMX.ittiam.", 11))) {
+        //do nothing for non QC component
+        return;
+    }
+
+    configureFramePackingFormat(msg, OMXhandle, nodeID, componentName);
+
+    setDIVXFormat(msg, mime, OMXhandle, nodeID, kPortIndexOutput);
+    AString fileFormat;
+    const char *fileFormatCStr = NULL;
+    bool success = msg->findString(getMsgKey(kKeyFileFormat), &fileFormat);
+    if (success) {
+        fileFormatCStr = fileFormat.c_str();
+    }
+
+    // Enable timestamp reordering for mpeg4 and vc1 codec types, the AVI file
+    // type, and hevc content in the ts container
+    bool tsReorder = false;
+    const char* roleVC1 = "OMX.qcom.video.decoder.vc1";
+    const char* roleMPEG4 = "OMX.qcom.video.decoder.mpeg4";
+    const char* roleHEVC = "OMX.qcom.video.decoder.hevc";
+    if (!strncmp(componentName, roleVC1, strlen(roleVC1)) ||
+            !strncmp(componentName, roleMPEG4, strlen(roleMPEG4))) {
+        // The codec requires timestamp reordering
+        tsReorder = true;
+    } else if (fileFormatCStr!= NULL) {
+        // Check for containers that support timestamp reordering
+        ALOGV("Container format = %s", fileFormatCStr);
+        if (!strncmp(fileFormatCStr, "video/avi", 9)) {
+            // The container requires timestamp reordering
+            tsReorder = true;
+        } else if (!strncmp(fileFormatCStr, MEDIA_MIMETYPE_CONTAINER_MPEG2TS,
+                strlen(MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) &&
+                !strncmp(componentName, roleHEVC, strlen(roleHEVC))) {
+            // HEVC content in the TS container requires timestamp reordering
+            tsReorder = true;
+        }
+    }
+
+    if (tsReorder) {
+        ALOGI("Enabling timestamp reordering");
+        QOMX_INDEXTIMESTAMPREORDER reorder;
+        InitOMXParams(&reorder);
+        reorder.nPortIndex = kPortIndexOutput;
+        reorder.bEnable = OMX_TRUE;
+        status_t err = OMXhandle->setParameter(nodeID,
+                       (OMX_INDEXTYPE)OMX_QcomIndexParamEnableTimeStampReorder,
+                       (void *)&reorder, sizeof(reorder));
+
+        if (err != OK) {
+            ALOGW("Failed to enable timestamp reordering");
+        }
+    }
+
+    // Enable Sync-frame decode mode for thumbnails
+    if (flags & OMXCodec::kClientNeedsFramebuffer) {
+        ALOGV("Enabling thumbnail mode.");
+        QOMX_ENABLETYPE enableType;
+        OMX_INDEXTYPE indexType;
+
+        status_t err = OMXhandle->getExtensionIndex(
+                nodeID, OMX_QCOM_INDEX_PARAM_VIDEO_SYNCFRAMEDECODINGMODE,
+                &indexType);
+        if (err != OK) {
+            ALOGW("Failed to get extension for SYNCFRAMEDECODINGMODE");
+            return;
+        }
+
+        enableType.bEnable = OMX_TRUE;
+        err = OMXhandle->setParameter(nodeID,indexType,
+                   (void *)&enableType, sizeof(enableType));
+        if (err != OK) {
+            ALOGW("Failed to get extension for SYNCFRAMEDECODINGMODE");
+            return;
+        }
+        ALOGI("Thumbnail mode enabled.");
+    }
+
+    // MediaCodec clients can request decoder extradata by setting
+    // "enable-extradata-<type>" in MediaFormat.
+    // Following <type>s are supported:
+    //    "user" => user-extradata
+    int extraDataRequested = 0;
+    if (msg->findInt32("enable-extradata-user", &extraDataRequested) &&
+            extraDataRequested == 1) {
+        ALOGI("[%s] User-extradata requested", componentName);
+        QOMX_ENABLETYPE enableType;
+        enableType.bEnable = OMX_TRUE;
+
+        status_t err = OMXhandle->setParameter(
+                nodeID, (OMX_INDEXTYPE)OMX_QcomIndexEnableExtnUserData,
+                (OMX_PTR)&enableType, sizeof(enableType));
+        if (err != OK) {
+            ALOGW("[%s] Failed to enable user-extradata", componentName);
+        }
+    }
+}
+
+void ExtendedCodec::configureVideoDecoder(
+        const sp<MetaData> &meta, const char* mime, sp<IOMX> OMXhandle,
+        const uint32_t flags, IOMX::node_id nodeID, const char* componentName ) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    configureVideoDecoder(msg, mime, OMXhandle, flags, nodeID, componentName);
+}
+
+void ExtendedCodec::enableSmoothStreaming(
+        const sp<IOMX> &omx, IOMX::node_id nodeID, bool* isEnabled,
+        const char* componentName) {
+    *isEnabled = false;
+
+    if (!ExtendedUtils::ShellProp::isSmoothStreamingEnabled()) {
+        return;
+    }
+
+    //ignore non QC components
+    if (strncmp(componentName, "OMX.qcom.", 9)) {
+        return;
+    }
+    if (strstr(componentName, ".secure")) {
+        char prop[PROPERTY_VALUE_MAX] = {0};
+        property_get("mm.disable.sec_smoothstreaming", prop, "0");
+        if (!strncmp(prop, "true", 4) || atoi(prop)) {
+            ALOGI("Smoothstreaming not enabled for secure Sessions");
+            return;
+        }
+    }
+    status_t err = omx->setParameter(
+            nodeID,
+            (OMX_INDEXTYPE)OMX_QcomIndexParamEnableSmoothStreaming,
+            &err, sizeof(status_t));
+    if (err != OK) {
+        ALOGE("Failed to enable Smoothstreaming!");
+        return;
+    }
+    *isEnabled = true;
+    ALOGI("Smoothstreaming Enabled");
+    return;
+}
+
+//private methods
+void ExtendedCodec::setEVRCFormat(
+        int32_t numChannels, int32_t sampleRate, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    ALOGV("setEVRCFormat called");
+
+    ARG_TOUCH(sampleRate);
+    if (isEncoder) {
+        CHECK(numChannels == 1);
+        //////////////// input port ////////////////////
+        //handle->setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+        //////////////// output port ////////////////////
+        // format
+        OMX_AUDIO_PARAM_PORTFORMATTYPE format;
+        format.nPortIndex = kPortIndexOutput;
+        format.nIndex = 0;
+        status_t err = OMX_ErrorNone;
+        while (OMX_ErrorNone == err) {
+            CHECK_EQ(OMXhandle->getParameter(nodeID, OMX_IndexParamAudioPortFormat,
+                    &format, sizeof(format)), (status_t)OK);
+            if (format.eEncoding == OMX_AUDIO_CodingEVRC) {
+                break;
+            }
+            format.nIndex++;
+        }
+        CHECK_EQ((status_t)OK, err);
+        CHECK_EQ(OMXhandle->setParameter(nodeID, OMX_IndexParamAudioPortFormat,
+                &format, sizeof(format)), (status_t)OK);
+
+        // port definition
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        def.format.audio.cMIMEType = NULL;
+        CHECK_EQ(OMXhandle->getParameter(nodeID, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+        def.format.audio.bFlagErrorConcealment = OMX_TRUE;
+        def.format.audio.eEncoding = OMX_AUDIO_CodingEVRC;
+        CHECK_EQ(OMXhandle->setParameter(nodeID, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+
+        // profile
+        OMX_AUDIO_PARAM_EVRCTYPE profile;
+        InitOMXParams(&profile);
+        profile.nPortIndex = kPortIndexOutput;
+        CHECK_EQ(OMXhandle->getParameter(nodeID, OMX_IndexParamAudioEvrc,
+                &profile, sizeof(profile)), (status_t)OK);
+        profile.nChannels = numChannels;
+        CHECK_EQ(OMXhandle->setParameter(nodeID, OMX_IndexParamAudioEvrc,
+                &profile, sizeof(profile)), (status_t)OK);
+    } else {
+        ALOGI("EVRC decoder \n");
+    }
+}
+
+void ExtendedCodec::setQCELPFormat(
+        int32_t numChannels, int32_t sampleRate, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+
+    ARG_TOUCH(sampleRate);
+    if (isEncoder) {
+        CHECK(numChannels == 1);
+        //////////////// input port ////////////////////
+        //handle->setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+        //////////////// output port ////////////////////
+        // format
+        OMX_AUDIO_PARAM_PORTFORMATTYPE format;
+        format.nPortIndex = kPortIndexOutput;
+        format.nIndex = 0;
+        status_t err = OMX_ErrorNone;
+        while (OMX_ErrorNone == err) {
+            CHECK_EQ(OMXhandle->getParameter(nodeID, OMX_IndexParamAudioPortFormat,
+                    &format, sizeof(format)), (status_t)OK);
+            if (format.eEncoding == OMX_AUDIO_CodingQCELP13) {
+                break;
+            }
+            format.nIndex++;
+        }
+        CHECK_EQ((status_t)OK, err);
+        CHECK_EQ(OMXhandle->setParameter(nodeID, OMX_IndexParamAudioPortFormat,
+                &format, sizeof(format)), (status_t)OK);
+
+        // port definition
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        def.format.audio.cMIMEType = NULL;
+        CHECK_EQ(OMXhandle->getParameter(nodeID, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+        def.format.audio.bFlagErrorConcealment = OMX_TRUE;
+        def.format.audio.eEncoding = OMX_AUDIO_CodingQCELP13;
+        CHECK_EQ(OMXhandle->setParameter(nodeID, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+
+        // profile
+        OMX_AUDIO_PARAM_QCELP13TYPE profile;
+        InitOMXParams(&profile);
+        profile.nPortIndex = kPortIndexOutput;
+        CHECK_EQ(OMXhandle->getParameter(nodeID, OMX_IndexParamAudioQcelp13,
+                &profile, sizeof(profile)), (status_t)OK);
+        profile.nChannels = numChannels;
+        CHECK_EQ(OMXhandle->setParameter(nodeID, OMX_IndexParamAudioQcelp13,
+                &profile, sizeof(profile)), (status_t)OK);
+    }
+    else {
+        ALOGI("QCELP decoder \n");
+    }
+}
+
+status_t ExtendedCodec::setWMAFormat(
+        const sp<MetaData> &meta, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    return setWMAFormat(msg, OMXhandle, nodeID, isEncoder);
+}
+
+status_t ExtendedCodec::setWMAFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    ALOGV("setWMAFormat Called");
+
+    if (isEncoder) {
+        ALOGE("WMA encoding not supported");
+        return OK;
+    } else {
+        int32_t version;
+        OMX_AUDIO_PARAM_WMATYPE paramWMA;
+        QOMX_AUDIO_PARAM_WMA10PROTYPE paramWMA10;
+        CHECK(msg->findInt32(getMsgKey(kKeyWMAVersion), &version));
+        int32_t numChannels;
+        int32_t bitRate;
+        int32_t sampleRate;
+        int32_t encodeOptions;
+        int32_t blockAlign;
+        int32_t bitspersample;
+        int32_t formattag;
+        int32_t advencopt1;
+        int32_t advencopt2;
+        int32_t VirtualPktSize;
+        if (version==kTypeWMAPro || version==kTypeWMALossLess) {
+            CHECK(msg->findInt32(getMsgKey(kKeyWMABitspersample), &bitspersample));
+            CHECK(msg->findInt32(getMsgKey(kKeyWMAFormatTag), &formattag));
+            CHECK(msg->findInt32(getMsgKey(kKeyWMAAdvEncOpt1), &advencopt1));
+            CHECK(msg->findInt32(getMsgKey(kKeyWMAAdvEncOpt2), &advencopt2));
+            CHECK(msg->findInt32(getMsgKey(kKeyWMAVirPktSize), &VirtualPktSize));
+        }
+        if (version==kTypeWMA) {
+            InitOMXParams(&paramWMA);
+            paramWMA.nPortIndex = kPortIndexInput;
+        } else if (version==kTypeWMAPro || version==kTypeWMALossLess) {
+            InitOMXParams(&paramWMA10);
+            paramWMA10.nPortIndex = kPortIndexInput;
+        }
+        CHECK(msg->findInt32("channel-count", &numChannels));
+        CHECK(msg->findInt32("sample-rate", &sampleRate));
+        CHECK(msg->findInt32(getMsgKey(kKeyBitRate), &bitRate));
+        if (!msg->findInt32(getMsgKey(kKeyWMAEncodeOpt), &encodeOptions)) {
+            ALOGE("Unsupported encode options");
+            return ERROR_UNSUPPORTED;
+        }
+        CHECK(msg->findInt32(getMsgKey(kKeyWMABlockAlign), &blockAlign));
+        ALOGV("Channels: %d, SampleRate: %d, BitRate; %d"
+                   "EncodeOptions: %d, blockAlign: %d", numChannels,
+                   sampleRate, bitRate, encodeOptions, blockAlign);
+        if (sampleRate>48000 || numChannels>2)
+        {
+            ALOGE("Unsupported samplerate/channels");
+            return ERROR_UNSUPPORTED;
+        }
+        if (version==kTypeWMAPro || version==kTypeWMALossLess)
+        {
+            ALOGV("Bitspersample: %d, wmaformattag: %d,"
+                       "advencopt1: %d, advencopt2: %d VirtualPktSize %d", bitspersample,
+                       formattag, advencopt1, advencopt2, VirtualPktSize);
+        }
+        status_t err = OK;
+        OMX_INDEXTYPE index;
+        if (version==kTypeWMA) {
+            err = OMXhandle->getParameter(
+                   nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+        } else if (version==kTypeWMAPro || version==kTypeWMALossLess) {
+            OMXhandle->getExtensionIndex(nodeID,"OMX.Qualcomm.index.audio.wma10Pro",&index);
+            err = OMXhandle->getParameter(
+                   nodeID, index, &paramWMA10, sizeof(paramWMA10));
+        }
+        CHECK_EQ(err, (status_t)OK);
+        if (version==kTypeWMA) {
+            paramWMA.nChannels = numChannels;
+            paramWMA.nSamplingRate = sampleRate;
+            paramWMA.nEncodeOptions = encodeOptions;
+            paramWMA.nBitRate = bitRate;
+            paramWMA.nBlockAlign = blockAlign;
+        } else if (version==kTypeWMAPro || version==kTypeWMALossLess) {
+            paramWMA10.nChannels = numChannels;
+            paramWMA10.nSamplingRate = sampleRate;
+            paramWMA10.nEncodeOptions = encodeOptions;
+            paramWMA10.nBitRate = bitRate;
+            paramWMA10.nBlockAlign = blockAlign;
+        }
+        if (version==kTypeWMAPro || version==kTypeWMALossLess) {
+            paramWMA10.advancedEncodeOpt = advencopt1;
+            paramWMA10.advancedEncodeOpt2 = advencopt2;
+            paramWMA10.formatTag = formattag;
+            paramWMA10.validBitsPerSample = bitspersample;
+            paramWMA10.nVirtualPktSize = VirtualPktSize;
+        }
+        if (version==kTypeWMA) {
+            err = OMXhandle->setParameter(
+                  nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+        } else if (version==kTypeWMAPro || version==kTypeWMALossLess) {
+           err = OMXhandle->setParameter(
+                 nodeID, index, &paramWMA10, sizeof(paramWMA10));
+        }
+        return err;
+    }
+    return OK;
+}
+
+#ifdef QCOM_ADDITIONAL_CODECS
+void ExtendedCodec::setAC3Format(
+        int32_t numChannels, int32_t sampleRate, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID) {
+    QOMX_AUDIO_PARAM_AC3TYPE profileAC3;
+    QOMX_AUDIO_PARAM_AC3PP profileAC3PP;
+    OMX_INDEXTYPE indexTypeAC3;
+    OMX_INDEXTYPE indexTypeAC3PP;
+    OMX_PARAM_PORTDEFINITIONTYPE portParam;
+
+    //configure input port
+    ALOGV("setAC3Format samplerate %d, numChannels %d", sampleRate, numChannels);
+    InitOMXParams(&portParam);
+    portParam.nPortIndex = 0;
+    status_t err = OMXhandle->getParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+    err = OMXhandle->setParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+
+    //configure output port
+    portParam.nPortIndex = 1;
+    err = OMXhandle->getParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+    err = OMXhandle->setParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+
+    err = OMXhandle->getExtensionIndex(nodeID, OMX_QCOM_INDEX_PARAM_AC3TYPE, &indexTypeAC3);
+
+    InitOMXParams(&profileAC3);
+    profileAC3.nPortIndex = kPortIndexInput;
+    err = OMXhandle->getParameter(nodeID, indexTypeAC3, &profileAC3, sizeof(profileAC3));
+    CHECK_EQ(err,(status_t)OK);
+
+    profileAC3.nSamplingRate  =  sampleRate;
+    profileAC3.nChannels      =  2;
+    profileAC3.eChannelConfig =  OMX_AUDIO_AC3_CHANNEL_CONFIG_2_0;
+
+    ALOGV("numChannels = %d, profileAC3.nChannels = %d", numChannels, profileAC3.nChannels);
+
+    err = OMXhandle->setParameter(nodeID, indexTypeAC3, &profileAC3, sizeof(profileAC3));
+    CHECK_EQ(err,(status_t)OK);
+
+    //for output port
+    OMX_AUDIO_PARAM_PCMMODETYPE profilePcm;
+    InitOMXParams(&profilePcm);
+    profilePcm.nPortIndex = kPortIndexOutput;
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioPcm, &profilePcm, sizeof(profilePcm));
+    CHECK_EQ(err, (status_t)OK);
+
+    profilePcm.nSamplingRate  =  sampleRate;
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioPcm, &profilePcm, sizeof(profilePcm));
+    CHECK_EQ(err, (status_t)OK);
+    OMXhandle->getExtensionIndex(nodeID, OMX_QCOM_INDEX_PARAM_AC3PP, &indexTypeAC3PP);
+
+    InitOMXParams(&profileAC3PP);
+    profileAC3PP.nPortIndex = kPortIndexInput;
+    err = OMXhandle->getParameter(
+            nodeID, indexTypeAC3PP, &profileAC3PP, sizeof(profileAC3PP));
+    CHECK_EQ(err, (status_t)OK);
+
+    int i;
+    int channel_routing[6] = {0};
+
+    for (i=0; i<6; i++) {
+        channel_routing[i] = -1;
+    }
+    for (i=0; i<6; i++) {
+        profileAC3PP.eChannelRouting[i] =  (OMX_AUDIO_AC3_CHANNEL_ROUTING)channel_routing[i];
+    }
+
+    profileAC3PP.eChannelRouting[0] =  OMX_AUDIO_AC3_CHANNEL_LEFT;
+    profileAC3PP.eChannelRouting[1] =  OMX_AUDIO_AC3_CHANNEL_RIGHT;
+    err = OMXhandle->setParameter(nodeID, indexTypeAC3PP, &profileAC3PP, sizeof(profileAC3PP));
+    CHECK_EQ(err, (status_t)OK);
+}
+#endif
+
+status_t ExtendedCodec::setAMRWBPLUSFormat(
+        int32_t numChannels, int32_t sampleRate, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID) {
+
+    QOMX_AUDIO_PARAM_AMRWBPLUSTYPE profileAMRWBPlus;
+    OMX_INDEXTYPE indexTypeAMRWBPlus;
+    OMX_PARAM_PORTDEFINITIONTYPE portParam;
+
+    ALOGV("AMRWB+ setformat sampleRate:%d numChannels:%d",sampleRate,numChannels);
+
+    //configure input port
+    InitOMXParams(&portParam);
+    portParam.nPortIndex = kPortIndexInput;
+    status_t err = OMXhandle->getParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+    err = OMXhandle->setParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+
+    //configure output port
+    portParam.nPortIndex = kPortIndexOutput;
+    err = OMXhandle->getParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+    err = OMXhandle->setParameter(
+       nodeID, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, (status_t)OK);
+
+    err = OMXhandle->getExtensionIndex(nodeID, OMX_QCOM_INDEX_PARAM_AMRWBPLUS, &indexTypeAMRWBPlus);
+
+    //for input port
+    InitOMXParams(&profileAMRWBPlus);
+    profileAMRWBPlus.nPortIndex = kPortIndexInput;
+    err = OMXhandle->getParameter(nodeID, indexTypeAMRWBPlus, &profileAMRWBPlus, sizeof(profileAMRWBPlus));
+    CHECK_EQ(err,(status_t)OK);
+
+    profileAMRWBPlus.nSampleRate = sampleRate;
+    profileAMRWBPlus.nChannels = numChannels;
+    err = OMXhandle->setParameter(nodeID, indexTypeAMRWBPlus, &profileAMRWBPlus, sizeof(profileAMRWBPlus));
+    CHECK_EQ(err,(status_t)OK);
+
+    //for output port
+    OMX_AUDIO_PARAM_PCMMODETYPE profilePcm;
+    InitOMXParams(&profilePcm);
+    profilePcm.nPortIndex = kPortIndexOutput;
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioPcm, &profilePcm, sizeof(profilePcm));
+    CHECK_EQ(err, (status_t)OK);
+
+    profilePcm.nSamplingRate = sampleRate;
+    profilePcm.nChannels = numChannels;
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioPcm, &profilePcm, sizeof(profilePcm));
+    CHECK_EQ(err, (status_t)OK);
+
+    return err;
+}
+
+bool ExtendedCodec::useHWAACDecoder(const char *mime) {
+    char value[PROPERTY_VALUE_MAX] = {0};
+    int aaccodectype = 0;
+    aaccodectype = property_get("media.aaccodectype", value, NULL);
+    if (aaccodectype && !strncmp("0", value, 1) &&
+        !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+        ALOGI("Using Hardware AAC Decoder");
+        return true;
+    }
+    return false;
+}
+
+bool ExtendedCodec::isSourcePauseRequired(const char *componentName) {
+    /* pause is required for hardware component to release adsp resources */
+    if (!strncmp(componentName, "OMX.qcom.", 9)) {
+        return true;
+    }
+    return false;
+}
+
+#else
+
+    uint32_t ExtendedCodec::getComponentQuirks (
+            const sp<MediaCodecInfo> &info) {
+        ARG_TOUCH(info);
+        return 0;
+    }
+
+    status_t ExtendedCodec::setDIVXFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID, int port_index) {
+        ARG_TOUCH(msg);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(port_index);
+        return OK;
+    }
+
+    status_t ExtendedCodec::setAudioFormat(
+            const sp<MetaData> &meta, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(isEncoder);
+        return OK;
+    }
+
+    status_t ExtendedCodec::setAudioFormat(
+            const sp<AMessage> &msg, const char* mime,
+            sp<IOMX> OMXhandle,IOMX::node_id nodeID,
+            bool isEncoder) {
+        ARG_TOUCH(msg);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(isEncoder);
+        return OK;
+    }
+
+    status_t ExtendedCodec::setVideoFormat(
+            const sp<AMessage> &msg, const char* mime,
+            OMX_VIDEO_CODINGTYPE *compressionFormat) {
+        ARG_TOUCH(mime);
+        ARG_TOUCH(compressionFormat);
+        return ERROR_UNSUPPORTED;
+    }
+
+    status_t ExtendedCodec::getSupportedAudioFormatInfo(
+            const AString* mime,
+            sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID,
+            int portIndex,
+            int* channelCount,
+            int* sampleRate) {
+        ARG_TOUCH(mime);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(portIndex);
+        ARG_TOUCH(channelCount);
+        return OK;
+    }
+
+    status_t ExtendedCodec::handleSupportedAudioFormats(
+            int format, AString* meta) {
+        ARG_TOUCH(format);
+        ARG_TOUCH(meta);
+        return UNKNOWN_ERROR;
+    }
+
+    bool ExtendedCodec::checkIfCompressionHEVC(int format) {
+        ARG_TOUCH(format);
+        return false;
+    }
+
+    status_t ExtendedCodec::handleSupportedVideoFormats(
+            int format, AString* meta) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(format);
+        return UNKNOWN_ERROR;
+    }
+
+    status_t ExtendedCodec::setupHEVCEncoderParameters(
+            const sp<MetaData> &meta, const sp<IOMX> &omx,
+            IOMX::node_id node, const char* componentName,
+            int portIndex, const sp<OMXCodec> &target) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(omx);
+        ARG_TOUCH(node);
+        ARG_TOUCH(componentName);
+        ARG_TOUCH(portIndex);
+        ARG_TOUCH(target);
+        return UNKNOWN_ERROR;
+    }
+
+    const char* ExtendedCodec::overrideComponentName (
+            uint32_t quirks, const sp<MetaData> &meta, const char *mime, bool isEncoder) {
+        ARG_TOUCH(quirks);
+        ARG_TOUCH(meta);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(isEncoder);
+        return FFMPEGSoftCodec::overrideComponentName(quirks, meta, mime, isEncoder);
+    }
+
+    void ExtendedCodec::overrideComponentName(
+            uint32_t quirks, const sp<AMessage> &msg,
+            AString* componentName, AString* mime,
+            int32_t isEncoder) {
+        ARG_TOUCH(quirks);
+        ARG_TOUCH(msg);
+        ARG_TOUCH(componentName);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(isEncoder);
+        return FFMPEGSoftCodec::overrideComponentName(quirks, msg, componentName, mime, isEncoder);
+    }
+
+    void ExtendedCodec::overrideMimeType(
+        const sp<AMessage> &msg, AString* mime) {
+        ARG_TOUCH(msg);
+        ARG_TOUCH(mime);
+    }
+
+    void ExtendedCodec::getRawCodecSpecificData(
+        const sp<MetaData> &meta, const void* &data, size_t &size) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(data);
+        size = 0;
+    }
+
+    sp<ABuffer> ExtendedCodec::getRawCodecSpecificData(
+            const sp<AMessage> &msg) {
+        ARG_TOUCH(msg);
+        return NULL;
+    }
+
+    void ExtendedCodec::getAacCodecSpecificData(
+            const sp<MetaData> &meta,
+            const void* &data,
+            size_t& size) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(data);
+        size = 0;
+        return;
+    }
+
+    sp<ABuffer> ExtendedCodec::getAacCodecSpecificData(
+            const sp<AMessage> &msg) {
+        ARG_TOUCH(msg);
+        return NULL;
+    }
+
+
+    status_t ExtendedCodec::setSupportedRole(
+            const sp<IOMX> &omx, IOMX::node_id node,
+            bool isEncoder, const char *mime) {
+        ARG_TOUCH(omx);
+        ARG_TOUCH(node);
+        ARG_TOUCH(isEncoder);
+        ARG_TOUCH(mime);
+        return BAD_VALUE;
+    }
+
+    status_t ExtendedCodec::setWMAFormat(
+            const sp<MetaData> &meta, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, bool isEncoder) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(isEncoder);
+        return OK;
+    }
+
+    status_t ExtendedCodec::setWMAFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, bool isEncoder) {
+        ARG_TOUCH(msg);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(isEncoder);
+        return OK;
+    }
+
+    void ExtendedCodec::setEVRCFormat(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+            bool isEncoder) {
+        ARG_TOUCH(numChannels);
+        ARG_TOUCH(sampleRate);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(isEncoder);
+    }
+
+    void ExtendedCodec::setQCELPFormat(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID,
+            bool isEncoder) {
+        ARG_TOUCH(numChannels);
+        ARG_TOUCH(sampleRate);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(isEncoder);
+    }
+
+#ifdef QCOM_ADDITIONAL_CODECS
+    void ExtendedCodec::setAC3Format(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID) {
+        ARG_TOUCH(numChannels);
+        ARG_TOUCH(sampleRate);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+    }
+#endif
+
+    status_t ExtendedCodec::setAMRWBPLUSFormat(
+            int32_t numChannels, int32_t sampleRate,
+            sp<IOMX> OMXhandle, IOMX::node_id nodeID) {
+        ARG_TOUCH(numChannels);
+        ARG_TOUCH(sampleRate);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        return OK;
+    }
+
+    void ExtendedCodec::configureFramePackingFormat(
+            const sp<AMessage> &msg, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, const char* componentName) {
+        ARG_TOUCH(msg);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(componentName);
+    }
+
+    void ExtendedCodec::configureFramePackingFormat(
+            const sp<MetaData> &meta, sp<IOMX> OMXhandle,
+            IOMX::node_id nodeID, const char* componentName) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(componentName);
+    }
+
+    void ExtendedCodec::configureVideoDecoder(
+        const sp<MetaData> &meta, const char* mime, sp<IOMX> OMXhandle,
+        const uint32_t flags, IOMX::node_id nodeID, const char* componentName) {
+        ARG_TOUCH(meta);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(flags);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(componentName);
+    }
+
+    void ExtendedCodec::configureVideoDecoder(
+        const sp<AMessage> &msg, const char* mime,  sp<IOMX> OMXhandle,
+        const uint32_t flags, IOMX::node_id nodeID, const char* componentName) {
+        ARG_TOUCH(msg);
+        ARG_TOUCH(mime);
+        ARG_TOUCH(OMXhandle);
+        ARG_TOUCH(flags);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(componentName);
+    }
+
+    bool ExtendedCodec::useHWAACDecoder(const char *mime) {
+        ARG_TOUCH(mime);
+        return false;
+    }
+
+    void ExtendedCodec::enableSmoothStreaming(
+            const sp<IOMX> &omx, IOMX::node_id nodeID, bool* isEnabled,
+            const char* componentName) {
+        ARG_TOUCH(omx);
+        ARG_TOUCH(nodeID);
+        ARG_TOUCH(componentName);
+        *isEnabled = false;
+        return;
+    }
+
+    bool ExtendedCodec::isSourcePauseRequired(const char *componentName) {
+        return false;
+    }
+#endif //ENABLE_AV_ENHANCEMENTS
+} //namespace android
diff --git a/media/libstagefright/ExtendedExtractor.cpp b/media/libstagefright/ExtendedExtractor.cpp
new file mode 100644
index 0000000..305563d
--- /dev/null
+++ b/media/libstagefright/ExtendedExtractor.cpp
@@ -0,0 +1,151 @@
+/*Copyright (c) 2012 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ExtendedExtractor"
+#include <utils/Log.h>
+#include <dlfcn.h>  // for dlopen/dlclose
+#include "include/ExtendedExtractor.h"
+
+#define ARG_TOUCH(x) (void)x
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+
+namespace android {
+
+static const char* EXTENDED_EXTRACTOR_LIB = "libExtendedExtractor.so";
+static const char* EXTENDED_EXTRACTOR_CREATE = "CreateExtractor";
+static const char* EXTENDED_EXTRACTOR_SNIFF = "SniffExtendedExtractor";
+
+typedef MediaExtractor* (*ExtendedExtractorCreate)
+                            (const sp<DataSource> &source, const char* mime);
+
+typedef bool (*ExtendedExtractorSniff)
+                 (const sp<DataSource> &source, String8 *mimeType,
+                 float *confidence,sp<AMessage> *meta);
+
+static void* loadExtendedExtractorLib() {
+    static void* extendedExtractorLib = NULL;
+    static bool alreadyTriedToLoadLib = false;
+
+    if(!alreadyTriedToLoadLib) {
+        alreadyTriedToLoadLib = true;
+
+        extendedExtractorLib = ::dlopen(EXTENDED_EXTRACTOR_LIB, RTLD_LAZY);
+
+        if(extendedExtractorLib == NULL) {
+            ALOGV("Failed to load %s, dlerror = %s \n",
+                EXTENDED_EXTRACTOR_LIB, dlerror());
+        }
+    }
+
+    return extendedExtractorLib;
+}
+
+MediaExtractor* ExtendedExtractor::Create (
+        const sp<DataSource> &source, const char *mime) {
+    static ExtendedExtractorCreate create = NULL;
+    static bool alreadyTriedToFindCreateFunction = false;
+    MediaExtractor* extractor = NULL;
+
+    if (!alreadyTriedToFindCreateFunction) {
+        void *extendedExtractorLib = loadExtendedExtractorLib();
+
+        if (extendedExtractorLib != NULL) {
+            create = (ExtendedExtractorCreate) dlsym (
+                    extendedExtractorLib, EXTENDED_EXTRACTOR_CREATE);
+            alreadyTriedToFindCreateFunction = true;
+        }
+    }
+
+    if (create == NULL) {
+        ALOGE ("Failed to find symbol : %s, dlerror = %s",
+            EXTENDED_EXTRACTOR_CREATE, dlerror());
+        return NULL;
+    }
+
+    extractor = create (source, mime);
+    if (extractor == NULL) {
+        ALOGE("Failed to instantiate extractor \n");
+    }
+
+    return extractor;
+}
+
+bool ExtendedExtractor::Sniff (
+        const sp<DataSource> &source, String8 *mimeType,
+        float *confidence,sp<AMessage> *meta) {
+    void *extendedExtractorLib = loadExtendedExtractorLib();
+    bool retVal = false;
+
+    if (extendedExtractorLib != NULL) {
+       ExtendedExtractorSniff sniff = (ExtendedExtractorSniff) dlsym (
+               extendedExtractorLib, EXTENDED_EXTRACTOR_SNIFF);
+
+        if (sniff == NULL) {
+            ALOGE ("Failed to find symbol : %s, dlerror = %s",
+                EXTENDED_EXTRACTOR_SNIFF, dlerror());
+            return retVal;
+        }
+
+       retVal = sniff (source, mimeType, confidence, meta);
+
+       if(!retVal) {
+           ALOGV("Sniff Failed");
+       }
+    }
+    return retVal;
+}
+
+}  // namespace android
+
+#else //ENABLE_AV_ENHANCEMENTS
+
+namespace android {
+
+MediaExtractor* ExtendedExtractor::Create (
+        const sp<DataSource> &source, const char *mime) {
+    ARG_TOUCH(source);
+    ARG_TOUCH(mime);
+    return NULL;
+}
+bool ExtendedExtractor::Sniff (
+        const sp<DataSource> &source, String8 *mimeType,
+        float *confidence, sp<AMessage> *meta) {
+    ARG_TOUCH(source);
+    ARG_TOUCH(mimeType);
+    ARG_TOUCH(confidence);
+    ARG_TOUCH(meta);
+    *confidence = 0.0;
+    return false;
+}
+
+}  // namespace android
+
+#endif //ENABLE_AV_ENHANCEMENTS
+
diff --git a/media/libstagefright/ExtendedMediaDefs.cpp b/media/libstagefright/ExtendedMediaDefs.cpp
new file mode 100644
index 0000000..40df171
--- /dev/null
+++ b/media/libstagefright/ExtendedMediaDefs.cpp
@@ -0,0 +1,57 @@
+/*Copyright (c) 2012 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <QCMediaDefs.h>
+
+namespace android {
+
+const char *MEDIA_MIMETYPE_AUDIO_EVRC = "audio/evrc";
+
+const char *MEDIA_MIMETYPE_CONTAINER_AAC = "audio/aac";
+const char *MEDIA_MIMETYPE_CONTAINER_QCP = "audio/vnd.qcelp";
+
+const char *MEDIA_MIMETYPE_CONTAINER_MPEG2 = "video/mp2";
+
+const char *MEDIA_MIMETYPE_CONTAINER_3G2 = "video/3g2";
+
+const char *MEDIA_MIMETYPE_AUDIO_DTS_LBR = "audio/dts-lbr";
+const char *MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS = "audio/amr-wb-plus";
+const char *MEDIA_MIMETYPE_CONTAINER_QCAMR_NB = "audio/qc-amr";
+const char *MEDIA_MIMETYPE_CONTAINER_QCAMR_WB = "audio/qc-amr-wb";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG = "audio/qc-mpeg";
+const char *MEDIA_MIMETYPE_CONTAINER_QCWAV = "audio/qc-wav";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG2TS = "video/qc-mp2ts";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG2PS = "video/qc-mp2ps";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG4 = "video/qc-mp4";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMATROSKA = "video/qc-matroska";
+const char *MEDIA_MIMETYPE_CONTAINER_QCOGG = "video/qc-ogg";
+const char *MEDIA_MIMETYPE_CONTAINER_QCFLV = "video/qc-flv";
+const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8"; //backward compatibility
+const char *MEDIA_MIMETYPE_CONTAINER_QTIFLAC = "audio/qti-flac";
+
+}  // namespace android
diff --git a/media/libstagefright/ExtendedStats.cpp b/media/libstagefright/ExtendedStats.cpp
new file mode 100644
index 0000000..c1e1719
--- /dev/null
+++ b/media/libstagefright/ExtendedStats.cpp
@@ -0,0 +1,629 @@
+/*Copyright (c) 2013 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ExtendedStats"
+#include <ctype.h>
+#include <inttypes.h>
+#include <media/stagefright/ExtendedStats.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <utils/Errors.h>
+#include <utils/Log.h>
+#include <cutils/properties.h>
+
+namespace android {
+
+/* constructors and destructors */
+ExtendedStats::ExtendedStats(const char *id, pid_t tid) {
+    clear();
+    mName.setTo(id);
+    mTid = tid;
+}
+
+ExtendedStats::~ExtendedStats() {
+    clear();
+}
+
+ExtendedStats::LogEntry::LogEntry()
+    : mData(0) {
+}
+
+void ExtendedStats::LogEntry::dump(const char* label) const {
+    ALOGI("%s : %" PRId64 "", label, mData);
+}
+
+// Running-average of inserted values
+struct Average : public ExtendedStats::LogEntry {
+    void insert(statsDataType value) {
+        mN++;
+        mSum += value;
+        mData = mSum / mN;
+    }
+    Average() {
+        mN = 0;
+        mSum = 0;
+    }
+    int32_t mN;
+    int64_t mSum;
+};
+
+// Moving-average of inserted values
+struct MovingAverage : public ExtendedStats::LogEntry {
+    static const int32_t kMaxWindowSize = ExtendedStats::kMaxWindowSize;
+    void insert(statsDataType value) {
+        Mutex::Autolock lock(mLock);
+        // pipeline is full, drop the tail and pick the head.
+        if (mHead == mTail) {
+            mSum -= mDataPoints[mTail];
+            mTail = advance(mTail);
+        }
+        mSum += value;
+        mDataPoints[mHead] = value;
+        mCount++;
+        mHead = advance(mHead);
+        mData = mSum / ((mCount > mNWindow) ? mNWindow : mCount);
+        mPeak = (mData > mPeak) ? mData : mPeak;
+    }
+    MovingAverage(int32_t window) {
+        mNWindow = (window < 1) ? 1 :
+                (window > kMaxWindowSize) ? kMaxWindowSize : window;
+        ALOGI("Creating MovingAverage of window size : %d\n", mNWindow);
+        reset();
+    }
+    void reset() {
+        Mutex::Autolock lock(mLock);
+        mData = 0;
+        mHead = 0;
+        mTail = mNWindow - 1;
+        mSum = 0;
+        mCount = 0;
+        mPeak = 0;
+        memset(mDataPoints, 0x0, sizeof(mDataPoints));
+    }
+    void dump(const char* label) const {
+        ALOGI("Avg %s : %" PRId64 "", label, mData);
+        ALOGI("Peak %s : %" PRId64 "", label, mPeak);
+    }
+
+    private:
+    int32_t mNWindow;
+    int32_t mHead;
+    int32_t mTail;
+    int64_t mSum;
+    int64_t mDataPoints[kMaxWindowSize];
+    int32_t mCount;
+    int32_t mPeak;
+    int32_t advance(int32_t index) {
+         return ++index % mNWindow;
+    }
+    Mutex mLock;
+};
+
+// Saves inserted values in a bound array
+struct Archive : public ExtendedStats::LogEntry {
+
+    Archive() : mIndex(0), mCache() /* zeroes out mCache */ { }
+
+    static const int kMaxOccurrences = 8;
+
+    virtual void insert(statsDataType value) {
+        if (mIndex >= kMaxOccurrences)
+            mIndex = kMaxOccurrences - 1;
+        mCache[mIndex++] = value;
+    }
+    void dump(const char* label) const {
+        if (mIndex != 0) {
+            char temp[ExtendedStats::kMaxStringLength] = {0};
+
+            for(int i = 0; i < mIndex; ++i) {
+                snprintf(temp + strlen(temp), ExtendedStats::kMaxStringLength, "\t%" PRId64 "", mCache[i]);
+            }
+
+            ALOGI("%s: %s", label, temp);
+        }
+    }
+protected:
+    int32_t mIndex;
+    statsDataType mCache[kMaxOccurrences];
+};
+
+// Profiles and saves the delay between insertion of START and STOP
+struct TimeProfile : Archive {
+    TimeProfile(): mStartingTimeIndex(0), mStartTimesCache() {}
+    ~TimeProfile() {}
+
+    virtual void insert(statsDataType value) {
+        if (value == ExtendedStats::PROFILE_START) {
+            if (mStartingTimeIndex >= kMaxOccurrences) {
+                mStartingTimeIndex = kMaxOccurrences - 1;
+            }
+            mStartTimesCache[mStartingTimeIndex++] = ExtendedStats::getSystemTime();
+        } else if (value == ExtendedStats::PROFILE_START_ONCE) {
+            //only profile first occurrence
+            if (mStartingTimeIndex == 0)  {
+                mStartTimesCache[mStartingTimeIndex++] = ExtendedStats::getSystemTime();
+            }
+        } else if (value == ExtendedStats::PROFILE_STOP) {
+            if (mIndex >= kMaxOccurrences) {
+                mIndex = kMaxOccurrences - 1;
+            }
+            if (mStartTimesCache[mIndex] != 0) { //i.e. we've called START before
+                mCache[mIndex] = ExtendedStats::getSystemTime() - mStartTimesCache[mIndex];
+                mIndex++;
+            }
+        }
+    }
+    void dump(const char* label) const {
+        if (mIndex != 0) {
+            char temp[ExtendedStats::kMaxStringLength] = {0};
+
+            for(int i = 0; i < mIndex; ++i) {
+                snprintf(temp + strlen(temp),
+                    ExtendedStats::kMaxStringLength, "\t%0.2f", mCache[i] / 1E3);
+            }
+
+            ALOGI("%s (ms): %s", label, temp);
+        }
+    }
+
+private:
+    int32_t mStartingTimeIndex;
+    statsDataType mStartTimesCache[kMaxOccurrences];
+};
+
+//static
+// LogEntry factory
+sp<ExtendedStats::LogEntry> ExtendedStats::createLogEntry(LogType type, int32_t windowSize) {
+    switch(type) {
+        case AVERAGE:
+            return new Average();
+        case PROFILE:
+            return new TimeProfile();
+        case MOVING_AVERAGE:
+            return new MovingAverage(windowSize);
+        default:
+           return new LogEntry();
+    }
+}
+
+sp<ExtendedStats::LogEntry> ExtendedStats::getLogEntry(const char *key,
+        LogType type) {
+    if (!key)
+        return NULL;
+
+    ssize_t idx = mLogEntry.indexOfKey(key);
+
+    /* if this entry doesn't exist, add it in the log and return it */
+    if (idx < 0) {
+        sp<LogEntry> logEntry = createLogEntry(type, mWindowSize);
+        mLogEntry.add(key, logEntry);
+        return logEntry;
+    } else {
+        return mLogEntry.valueAt(idx);
+    }
+}
+
+void ExtendedStats::log(LogType type, const char* key, statsDataType value, bool condition) {
+
+    Mutex::Autolock lock(mLock);
+    if ( !condition || !key)
+        return;
+
+    getLogEntry(key, type)->insert(value);
+}
+
+void ExtendedStats::dump(const char* key) {
+    // If no key is provided, print all
+    // TBD: print label and sentinels
+    Mutex::Autolock lock(mLock);
+    if (key) {
+        ssize_t idx = mLogEntry.indexOfKey(key);
+        if (idx >= 0) {
+            mLogEntry.valueAt(idx)->dump(key);
+        }
+    } else {
+        ALOGI("----------------------------------------------------");
+        ALOGI(" %s ", mName.c_str());
+        for (size_t i = 0; i < mLogEntry.size(); ++i) {
+            mLogEntry.valueAt(i)->dump(mLogEntry.keyAt(i).c_str());
+        }
+        ALOGI("----------------------------------------------------");
+    }
+}
+
+void ExtendedStats::reset(const char* key) {
+    Mutex::Autolock lock(mLock);
+    if (key) {
+        ssize_t idx = mLogEntry.indexOfKey(key);
+        if (idx >= 0) {
+            mLogEntry.valueAt(idx)->reset();
+        }
+    }
+}
+
+void ExtendedStats::clear() {
+    Mutex::Autolock lock(mLock);
+    mLogEntry.clear();
+    mTid = -1;
+    mWindowSize = kMaxWindowSize;
+    mName = "";
+}
+
+ExtendedStats::AutoProfile::AutoProfile(
+        const char* name, sp<MediaExtendedStats> mediaExtendedStats,
+        bool condition, bool profileOnce)
+    : mEventName(name),
+      mStats(NULL),
+      mCondition(condition) {
+
+    if (mediaExtendedStats != NULL) {
+        mStats = mediaExtendedStats->getProfileTimes();
+    }
+
+    if (condition && name && mStats != NULL) {
+        if (profileOnce)
+            mStats->profileStartOnce(name);
+        else
+            mStats->profileStart(name);
+    }
+}
+
+ExtendedStats::AutoProfile::~AutoProfile() {
+    if (mCondition && mStats != NULL) {
+        mStats->profileStop(mEventName.c_str());
+    }
+}
+
+MediaExtendedStats* ExtendedStats::Create(
+        enum StatsType statsType, const char* name, pid_t tid) {
+
+    char value[PROPERTY_VALUE_MAX];
+    property_get("persist.debug.sf.extendedstats", value, "0");
+    if (atoi(value)) {
+        switch (statsType) {
+            case PLAYER:
+                return new PlayerExtendedStats(name, tid);
+            case RECORDER:
+                return new RecorderExtendedStats(name, tid);
+        }
+    }
+    return NULL;
+}
+
+
+/***************************** MediaExtendedStats ************************/
+
+MediaExtendedStats::MediaExtendedStats(const char* name, pid_t tid) {
+
+    mName = name;
+    mTid = tid;
+    mProfileTimes = new ExtendedStats(mName.c_str(), mTid);
+
+    reset();
+}
+/** helper methods **/
+
+void MediaExtendedStats::resetConsecutiveFramesDropped() {
+    if (mCurrentConsecutiveFramesDropped > mMaxConsecutiveFramesDropped)
+        mMaxConsecutiveFramesDropped = mCurrentConsecutiveFramesDropped;
+
+    mCurrentConsecutiveFramesDropped = 0;
+}
+
+/** MediaExtendedStats methods **/
+
+void MediaExtendedStats::reset() {
+    Mutex::Autolock lock(mLock);
+
+    mCurrentConsecutiveFramesDropped = 0;
+    mMaxConsecutiveFramesDropped = 0;
+    mNumChainedDrops = 0;
+    mFramesDropped = 0;
+    mLastPauseTime = 0;
+
+    mWidthDimensions.clear();
+    mHeightDimensions.clear();
+
+    mFrameRate = 30;
+    mProfileTimes->clear();
+}
+
+
+void MediaExtendedStats::logFrameDropped() {
+    mFramesDropped++;
+    mCurrentConsecutiveFramesDropped++;
+}
+
+void MediaExtendedStats::logDimensions(int32_t width, int32_t height) {
+    Mutex::Autolock lock(mLock);
+    if (mWidthDimensions.empty() || mWidthDimensions.top() != width ||
+        mHeightDimensions.empty() || mHeightDimensions.top() != height) {
+        mWidthDimensions.push(width);
+        mHeightDimensions.push(height);
+    }
+}
+
+void MediaExtendedStats::logBitRate(int64_t frameSize, int64_t timestamp) {
+    mProfileTimes->log(ExtendedStats::MOVING_AVERAGE, STATS_BITRATE, frameSize, true);
+}
+
+MediaExtendedStats::~MediaExtendedStats() {
+    mProfileTimes = NULL;
+}
+
+/***************************** PlayerExtendedStats ************************/
+
+PlayerExtendedStats::PlayerExtendedStats(const char* name, pid_t tid) :
+    MediaExtendedStats(name, tid) {
+
+    reset();
+}
+
+/** helper methods **/
+
+void PlayerExtendedStats::updateTotalPlayingTime(bool wasPlaying) {
+    /* only accumulate total playing time if we were playing */
+    if (wasPlaying) {
+        uint64_t currentTime = ExtendedStats::getSystemTime();
+        mTotalPlayingTime += (currentTime - mStartPlayingTime);
+
+        //reset this in case of repeated calls without intervening stops
+        mStartPlayingTime = currentTime;
+    }
+}
+
+/** PlayerExtendedStats methods **/
+
+void PlayerExtendedStats::reset() {
+    MediaExtendedStats::reset();
+
+    mFramesRendered = 0;
+
+    mPlaying = false;
+    mPaused = false;
+    mEOS = false;
+
+    mTotalPlayingTime = 0;
+    mStartPlayingTime = 0;
+
+    mLastSeekTime = 0;
+}
+
+void PlayerExtendedStats::logFrameRendered() {
+    /* we've just rendered a frame
+     * if we had been dropping consecutive frames
+     * before this, update their counts
+     */
+    if (mCurrentConsecutiveFramesDropped > 1)
+        mNumChainedDrops++;
+
+    resetConsecutiveFramesDropped();
+
+    mFramesRendered++;
+}
+
+void PlayerExtendedStats::notifyPlaying(bool isNowPlaying) {
+    if (isNowPlaying) {
+        mStartPlayingTime = ExtendedStats::getSystemTime();
+        mPaused = false;
+    } else { //we've stopped playing.
+        resetConsecutiveFramesDropped();
+
+        /* explicitly passing in mPlaying b/c we depend on this old value.
+         * The alternative (using mPlaying value within the function) can lead to
+         * hard-to-find bug if mPlaying is updated before this call. Updating
+         * mPlaying after this avoids race condition.
+         */
+        updateTotalPlayingTime(mPlaying);
+    }
+
+    // don't move this before updateTotalPlayingTime
+    mPlaying = isNowPlaying;
+}
+
+void PlayerExtendedStats::notifyPause(int64_t pauseTimeUs) {
+    notifyPlaying(false);
+    mLastPauseTime = pauseTimeUs;
+    mPaused = true;
+}
+
+void PlayerExtendedStats::notifySeek(int64_t seekTimeUs) {
+    notifyPlaying(false);
+    mLastSeekTime = seekTimeUs;
+}
+
+void PlayerExtendedStats::notifySeekDone() {
+    //if we're not seeking while paused
+    if (!mPaused) {
+        notifyPlaying(true);
+    }
+}
+
+void PlayerExtendedStats::notifyEOS() {
+    updateTotalPlayingTime(mPlaying);
+    mEOS = true;
+    mPlaying = false;
+}
+
+void PlayerExtendedStats::dump() {
+    updateTotalPlayingTime(mPlaying);
+
+    int64_t totalFrames = mFramesDropped + mFramesRendered;
+
+    /* If we didn't process any video frames, don't print anything at all.
+     * This takes care of problem in encoder profiling whereby the sound of the
+     * recorder button triggers a PlayerExtendedStats instance and logs become
+     * interleaved.
+     */
+    if (!totalFrames)
+        return;
+
+    double percentDropped = (double)mFramesDropped / totalFrames;
+
+    ALOGI("-------------------Begin PlayerExtendedStats----------------------");
+
+    ALOGI("%s stats (tid %d):", mName.c_str(), mTid);
+    ALOGI("Video dimensions:");
+    for (uint32_t i = 0; i < mWidthDimensions.size(); i++) {
+        ALOGI("\t\t%d x %d", mWidthDimensions[i], mHeightDimensions[i]);
+    }
+    ALOGI("Total frames decoded: %"PRId64"", totalFrames);
+    ALOGI("Frames dropped: %"PRId64" out of %"PRId64" (%0.2f%%)", mFramesDropped, totalFrames, percentDropped * 100);
+    ALOGI("Frames rendered: %"PRId64" out of %"PRId64" (%0.2f%%)", mFramesRendered, totalFrames, (1-percentDropped) * 100);
+    ALOGI("Total playback duration: %"PRId64"ms", mTotalPlayingTime / 1000);
+    ALOGI("Max frames dropped consecutively: %"PRId64"", mMaxConsecutiveFramesDropped);
+    ALOGI("Num occurrences of consecutive drops: %"PRId64"", mNumChainedDrops);
+
+    ALOGI("Last seek to time: %"PRId64" ms", mLastSeekTime / 1000);
+    ALOGI("Last pause time: %"PRId64" ms", mLastPauseTime/1000);
+
+    ALOGI("Average FPS: %0.2f", mTotalPlayingTime == 0 ? 0 : mFramesRendered /(mTotalPlayingTime / 1E6));
+
+    mProfileTimes->dump(STATS_BITRATE);
+
+    ALOGI("EOS(%d)", mEOS ? 1 : 0);
+    ALOGI("PLAYING(%d)", mPlaying ? 1 : 0);
+
+    ALOGI("------- Profile Latencies --------");
+    bool video = true;
+    bool audio = !video;
+    mProfileTimes->dump(STATS_PROFILE_PAUSE);
+    mProfileTimes->dump(STATS_PROFILE_RESUME);
+    mProfileTimes->dump(STATS_PROFILE_SEEK);
+
+    if (mEOS) {
+        ALOGI("---------- KPI -----------");
+        mProfileTimes->dump(STATS_PROFILE_SET_DATA_SOURCE);
+        mProfileTimes->dump(STATS_PROFILE_PREPARE);
+        mProfileTimes->dump(STATS_PROFILE_ALLOCATE_NODE(video));
+        mProfileTimes->dump(STATS_PROFILE_ALLOCATE_NODE(audio));
+        mProfileTimes->dump(STATS_PROFILE_CONFIGURE_CODEC(video));
+        mProfileTimes->dump(STATS_PROFILE_ALLOCATE_INPUT(video));
+        mProfileTimes->dump(STATS_PROFILE_ALLOCATE_OUTPUT(video));
+        mProfileTimes->dump(STATS_PROFILE_CONFIGURE_CODEC(audio));
+        mProfileTimes->dump(STATS_PROFILE_ALLOCATE_INPUT(audio));
+        mProfileTimes->dump(STATS_PROFILE_ALLOCATE_OUTPUT(audio));
+        mProfileTimes->dump(STATS_PROFILE_FIRST_BUFFER(video));
+        mProfileTimes->dump(STATS_PROFILE_FIRST_BUFFER(audio));
+        mProfileTimes->dump(STATS_PROFILE_START_LATENCY);
+        mProfileTimes->dump(STATS_PROFILE_RECONFIGURE);
+    }
+
+    ALOGI("-------------------End PlayerExtendedStats----------------------");
+}
+
+/************************************** RecorderExtendedStats *********************************/
+
+RecorderExtendedStats::RecorderExtendedStats(const char* name, pid_t tid) :
+    MediaExtendedStats(name, tid) {
+
+    reset();
+}
+
+void RecorderExtendedStats::reset() {
+    MediaExtendedStats::reset();
+    mFramesEncoded = 0;
+    mTotalRecordingTime = 0;
+}
+
+void RecorderExtendedStats::notifyPause(int64_t pauseTimeUs) {
+    mLastPauseTime = pauseTimeUs;
+    resetConsecutiveFramesDropped();
+}
+
+void RecorderExtendedStats::logFrameEncoded() {
+    /* we've just rendered a frame
+     * if we had been dropping consecutive frames
+     * before this, update their counts
+     */
+    if (mCurrentConsecutiveFramesDropped > 1)
+        mNumChainedDrops++;
+
+    resetConsecutiveFramesDropped();
+
+    mFramesEncoded++;
+}
+
+void RecorderExtendedStats::logRecordingDuration(int64_t duration) {
+    mTotalRecordingTime = duration;
+}
+
+void RecorderExtendedStats::dump() {
+
+    int64_t totalFrames = mFramesDropped + mFramesEncoded;
+    double percentDropped = totalFrames == 0 ? 0 : (double)mFramesDropped/totalFrames;
+
+    ALOGI("-------------------Begin RecorderExtendedStats----------------------");
+
+    ALOGI("%s stats (tid %d):",mName.c_str(), mTid);
+    ALOGI("Video dimensions:");
+    for (uint32_t i = 0; i < mWidthDimensions.size(); i++)
+    {
+        ALOGI("\t\t%d x %d", mWidthDimensions[i], mHeightDimensions[i]);
+    }
+    ALOGI("Total frames: %"PRId64"", totalFrames);
+    ALOGI("Frames dropped: %"PRId64" out of %"PRId64" (%0.2f%%)", mFramesDropped, totalFrames, percentDropped * 100);
+    ALOGI("Frames encoded: %"PRId64" out of %"PRId64" (%0.2f%%)", mFramesEncoded, totalFrames, (1-percentDropped) * 100);
+    ALOGI("Max frames dropped consecutively: %"PRId64"", mMaxConsecutiveFramesDropped);
+    ALOGI("Num occurrences of consecutive drops: %"PRId64"", mNumChainedDrops);
+
+    ALOGI("Total recording duration: %"PRId64" ms", mTotalRecordingTime/1000);
+    ALOGI("Last pause time: %"PRId64" ms", mLastPauseTime/1000);
+    ALOGI("Input frame rate: %0.2f", mTotalRecordingTime == 0 ? 0 : mFramesEncoded/(mTotalRecordingTime/1E6));
+
+    ALOGI("------- Profile Latencies --------");
+
+    bool video = true;
+    bool audio = !video;
+    mProfileTimes->dump(STATS_PROFILE_PAUSE);
+
+    ALOGI("---------- KPI -----------");
+    mProfileTimes->dump(STATS_PROFILE_SET_CAMERA_SOURCE);
+    mProfileTimes->dump(STATS_PROFILE_ALLOCATE_NODE(video));
+    mProfileTimes->dump(STATS_PROFILE_ALLOCATE_NODE(audio));
+    mProfileTimes->dump(STATS_PROFILE_SET_ENCODER(video));
+    mProfileTimes->dump(STATS_PROFILE_CONFIGURE_CODEC(video));
+    mProfileTimes->dump(STATS_PROFILE_ALLOCATE_INPUT(video));
+    mProfileTimes->dump(STATS_PROFILE_ALLOCATE_OUTPUT(video));
+    mProfileTimes->dump(STATS_PROFILE_SET_ENCODER(audio));
+    mProfileTimes->dump(STATS_PROFILE_CONFIGURE_CODEC(audio));
+    mProfileTimes->dump(STATS_PROFILE_ALLOCATE_INPUT(audio));
+    mProfileTimes->dump(STATS_PROFILE_ALLOCATE_OUTPUT(audio));
+    mProfileTimes->dump(STATS_PROFILE_FIRST_BUFFER(video));
+    mProfileTimes->dump(STATS_PROFILE_FIRST_BUFFER(audio));
+    mProfileTimes->dump(STATS_PROFILE_START_LATENCY);
+    mProfileTimes->dump(STATS_PROFILE_SF_RECORDER_START_LATENCY);
+    mProfileTimes->dump(STATS_PROFILE_CAMERA_SOURCE_START_LATENCY);
+    mProfileTimes->dump(STATS_PROFILE_STOP);
+
+    ALOGI("-------------------End RecorderExtendedStats----------------------");
+}
+
+}
diff --git a/media/libstagefright/ExtendedUtils.cpp b/media/libstagefright/ExtendedUtils.cpp
new file mode 100644
index 0000000..2046d7e
--- /dev/null
+++ b/media/libstagefright/ExtendedUtils.cpp
@@ -0,0 +1,2412 @@
+/*Copyright (c) 2013 - 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ExtendedUtils"
+#include <utils/Log.h>
+
+#include <utils/Errors.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/foundation/ABitReader.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/OMXCodec.h>
+#include <cutils/properties.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/MediaProfiles.h>
+#include <media/stagefright/Utils.h>
+
+//RTSPStream
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#include <netdb.h>
+
+#include "include/avc_utils.h"
+#include "include/ExtendedUtils.h"
+
+static const int64_t kDefaultAVSyncLateMargin =  40000;
+static const int64_t kMaxAVSyncLateMargin     = 250000;
+bool android::ExtendedUtils::mIsQCHWAACEncoder = 0;
+
+static const unsigned kDefaultRtpPortRangeStart = 15550;
+static const unsigned kDefaultRtpPortRangeEnd = 65535;
+
+static const unsigned kMinRtpPort = 1024;
+static const unsigned kMaxRtpPort = 65535;
+
+#define ARG_TOUCH(x) (void)x
+
+static const uint8_t kHEVCNalUnitTypeIDR         = 0x13;
+static const uint8_t kHEVCNalUnitTypeIDRNoLP     = 0x14;
+static const uint8_t kHEVCNalUnitTypeCRA         = 0x15;
+static const uint8_t kHEVCNalUnitTypeVidParamSet = 0x20;
+static const uint8_t kHEVCNalUnitTypeSeqParamSet = 0x21;
+static const uint8_t kHEVCNalUnitTypePicParamSet = 0x22;
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+
+#include <QCMetaData.h>
+#include <QCMediaDefs.h>
+
+#include "include/ExtendedExtractor.h"
+#include "include/avc_utils.h"
+
+namespace android {
+
+void ExtendedUtils::HFR::setHFRIfEnabled(
+        const CameraParameters& params,
+        sp<MetaData> &meta) {
+    const char *hfrParam = params.get("video-hfr");
+    int32_t hfr = -1;
+    if (hfrParam != NULL) {
+        hfr = atoi(hfrParam);
+        if (hfr > 0) {
+            ALOGI("Enabling HFR @ %d fps", hfr);
+            meta->setInt32(kKeyHFR, hfr);
+            return;
+        } else {
+            ALOGI("Invalid HFR rate specified : %d", hfr);
+        }
+    }
+
+    const char *hsrParam = params.get("video-hsr");
+    int32_t hsr = -1;
+    if (hsrParam != NULL ) {
+        hsr = atoi(hsrParam);
+        if (hsr > 0) {
+            ALOGI("Enabling HSR @ %d fps", hsr);
+            meta->setInt32(kKeyHSR, hsr);
+        } else {
+            ALOGI("Invalid HSR rate specified : %d", hfr);
+        }
+    }
+}
+
+status_t ExtendedUtils::HFR::initializeHFR(
+        const sp<MetaData> &meta, sp<AMessage> &format,
+        int64_t &maxFileDurationUs, video_encoder videoEncoder) {
+    status_t retVal = OK;
+
+    int32_t hsr = 0;
+    if (meta->findInt32(kKeyHSR, &hsr) && hsr > 0) {
+        ALOGI("HSR cue found. Override encode fps to %d", hsr);
+        format->setInt32("frame-rate", hsr);
+
+        int maxBitRate;
+        MediaProfiles *profiles = MediaProfiles::getInstance();
+        maxBitRate = profiles->getVideoEncoderParamByName("enc.vid.bps.max", videoEncoder);
+        if (maxBitRate < 0) {
+            ALOGE("Failed to query max bitrate for HSR");
+            return ERROR_UNSUPPORTED;
+        }
+
+        int32_t frameRate = 0, bitRate = 0;
+        CHECK(meta->findInt32(kKeyFrameRate, &frameRate));
+        CHECK(format->findInt32("bitrate", &bitRate));
+
+        // scale the bitrate proportional to the hsr ratio
+        // to maintain quality, but cap it to max-supported.
+        bitRate = (hsr * bitRate) / frameRate;
+        bitRate = bitRate > maxBitRate ? maxBitRate : bitRate;
+        format->setInt32("bitrate", bitRate);
+
+        return retVal;
+    }
+
+    int32_t hfr = 0;
+    if (!meta->findInt32(kKeyHFR, &hfr) || (hfr <= 0)) {
+        ALOGW("Invalid HFR rate specified");
+        return retVal;
+    }
+
+    int32_t width = 0, height = 0;
+    CHECK(meta->findInt32(kKeyWidth, &width));
+    CHECK(meta->findInt32(kKeyHeight, &height));
+
+    int maxW, maxH, MaxFrameRate, maxBitRate = 0;
+    if (getHFRCapabilities(videoEncoder,
+            maxW, maxH, MaxFrameRate, maxBitRate) < 0) {
+        ALOGE("Failed to query HFR target capabilities");
+        return ERROR_UNSUPPORTED;
+    }
+
+    if ((width * height * hfr) > (maxW * maxH * MaxFrameRate)) {
+        ALOGE("HFR request [%d x %d @%d fps] exceeds "
+                "[%d x %d @%d fps]. Will stay disabled",
+                width, height, hfr, maxW, maxH, MaxFrameRate);
+        return ERROR_UNSUPPORTED;
+    }
+
+    int32_t frameRate = 0, bitRate = 0;
+    CHECK(meta->findInt32(kKeyFrameRate, &frameRate));
+    CHECK(format->findInt32("bitrate", &bitRate));
+
+    if (frameRate) {
+        // scale the bitrate proportional to the hfr ratio
+        // to maintain quality, but cap it to max-supported.
+        bitRate = (hfr * bitRate) / frameRate;
+        bitRate = bitRate > maxBitRate ? maxBitRate : bitRate;
+        format->setInt32("bitrate", bitRate);
+
+        int32_t hfrRatio = hfr / frameRate;
+        format->setInt32("frame-rate", hfr);
+        format->setInt32("hfr-ratio", hfrRatio);
+    } else {
+        ALOGE("HFR: Invalid framerate");
+        return BAD_VALUE;
+    }
+
+    return retVal;
+}
+
+void ExtendedUtils::HFR::setHFRRatio(
+        sp<MetaData> &meta, const int32_t hfrRatio) {
+    if (hfrRatio > 0) {
+        meta->setInt32(kKeyHFR, hfrRatio);
+    }
+}
+
+int32_t ExtendedUtils::HFR::getHFRRatio(
+        const sp<MetaData> &meta) {
+    int32_t hfrRatio = 0;
+    meta->findInt32(kKeyHFR, &hfrRatio);
+    return hfrRatio ? hfrRatio : 1;
+}
+
+int32_t ExtendedUtils::HFR::getHFRCapabilities(
+        video_encoder codec,
+        int& maxHFRWidth, int& maxHFRHeight, int& maxHFRFps,
+        int& maxBitRate) {
+    maxHFRWidth = maxHFRHeight = maxHFRFps = maxBitRate = 0;
+    MediaProfiles *profiles = MediaProfiles::getInstance();
+
+    if (profiles) {
+        maxHFRWidth = profiles->getVideoEncoderParamByName("enc.vid.hfr.width.max", codec);
+        maxHFRHeight = profiles->getVideoEncoderParamByName("enc.vid.hfr.height.max", codec);
+        maxHFRFps = profiles->getVideoEncoderParamByName("enc.vid.hfr.mode.max", codec);
+        maxBitRate = profiles->getVideoEncoderParamByName("enc.vid.bps.max", codec);
+    }
+
+    return (maxHFRWidth > 0) && (maxHFRHeight > 0) &&
+            (maxHFRFps > 0) && (maxBitRate > 0) ? 1 : -1;
+}
+
+bool ExtendedUtils::HEVCMuxer::isVideoHEVC(const char* mime) {
+    return (!strncasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC,
+                         strlen(MEDIA_MIMETYPE_VIDEO_HEVC)));
+}
+
+bool ExtendedUtils::HEVCMuxer::getHEVCCodecConfigData(
+                          const sp<MetaData> &meta, const void **data,
+                          size_t *size) {
+    uint32_t type;
+    ALOGV("getHEVCCodecConfigData called");
+    return meta->findData(kKeyHVCC, &type, data, size);
+}
+
+void ExtendedUtils::HEVCMuxer::writeHEVCFtypBox(MPEG4Writer *writer) {
+    ALOGV("writeHEVCFtypBox called");
+    writer->writeFourcc("3gp5");
+    writer->writeInt32(0);
+    writer->writeFourcc("hvc1");
+    writer->writeFourcc("hev1");
+    writer->writeFourcc("3gp5");
+}
+
+void ExtendedUtils::HEVCMuxer::beginHEVCBox(MPEG4Writer *writer) {
+    ALOGV("beginHEVCBox called");
+    writer->beginBox("hvc1");
+}
+
+void ExtendedUtils::HEVCMuxer::writeHvccBox(MPEG4Writer *writer,
+                                            void* codecSpecificData,
+                                            size_t codecSpecificDataSize,
+                                            bool useNalLengthFour) {
+    ALOGV("writeHvccBox called");
+    CHECK(codecSpecificData);
+    CHECK_GE(codecSpecificDataSize, 23);
+
+    // Patch hvcc's lengthSize field to match the number
+    // of bytes we use to indicate the size of a nal unit.
+    uint8_t *ptr = (uint8_t *)codecSpecificData;
+    ptr[21] = (ptr[21] & 0xfc) | (useNalLengthFour? 3 : 1);
+    writer->beginBox("hvcC");
+    writer->write(codecSpecificData, codecSpecificDataSize);
+    writer->endBox();  // hvcC
+}
+
+status_t ExtendedUtils::HEVCMuxer::extractNALRBSPData(const uint8_t *data,
+                                            size_t size,
+                                            uint8_t **header,
+                                            bool *alreadyFilled) {
+    ALOGV("extractNALRBSPData called");
+    CHECK_GE(size, 2);
+
+    uint8_t type = data[0] >> 1;
+    type = 0x3f & type;
+
+    //start parsing here
+    size_t rbspSize = 0;
+    uint8_t *rbspData = (uint8_t *) malloc(size);
+
+    if (rbspData == NULL) {
+        ALOGE("allocation failed");
+        return UNKNOWN_ERROR;
+    }
+
+    //populate rbsp data start from i+2, search for 0x000003,
+    //and ignore emulation_prevention byte
+    size_t itt = 2;
+    while (itt < size) {
+        if ((itt+2 < size) && (!memcmp("\x00\x00\x03", &data[itt], 3) )) {
+            rbspData[rbspSize++] = data[itt++];
+            rbspData[rbspSize++] = data[itt++];
+            itt++;
+        } else {
+            rbspData[rbspSize++] = data[itt++];
+        }
+    }
+
+    uint8_t maxSubLayerMinus1 = 0;
+
+    //parser profileTierLevel
+    if (type == kHEVCNalUnitTypeVidParamSet) { // if VPS
+        ALOGV("its VPS ... start with 5th byte");
+        if (rbspSize < 5) {
+            free(rbspData);
+            return ERROR_MALFORMED;
+        }
+
+        maxSubLayerMinus1 = 0x0E & rbspData[1];
+        maxSubLayerMinus1 = maxSubLayerMinus1 >> 1;
+        parserProfileTierLevel(&rbspData[4], rbspSize - 4, header, alreadyFilled);
+
+    } else if (type == kHEVCNalUnitTypeSeqParamSet) {
+        ALOGV("its SPS .. start with 2nd byte");
+        if (rbspSize < 2) {
+            free(rbspData);
+            return ERROR_MALFORMED;
+        }
+
+        maxSubLayerMinus1 = 0x0E & rbspData[0];
+        maxSubLayerMinus1 = maxSubLayerMinus1 >> 1;
+
+        parserProfileTierLevel(&rbspData[1], rbspSize - 1, header, alreadyFilled);
+    }
+    free(rbspData);
+    return OK;
+}
+
+status_t ExtendedUtils::HEVCMuxer::parserProfileTierLevel(const uint8_t *data, size_t size,
+                                                     uint8_t **header, bool *alreadyFilled) {
+    CHECK_GE(size, 12);
+    uint8_t *tmpHeader = *header;
+    ALOGV("parserProfileTierLevel called");
+    uint8_t generalProfileSpace; //2 bit
+    uint8_t generalTierFlag;     //1 bit
+    uint8_t generalProfileIdc;   //5 bit
+    uint8_t generalProfileCompatibilityFlag[4];
+    uint8_t generalConstraintIndicatorFlag[6];
+    uint8_t generalLevelIdc;     //8 bit
+
+    // Need first 12 bytes
+
+    // First byte will give below info
+    generalProfileSpace = 0xC0 & data[0];
+    generalProfileSpace = generalProfileSpace > 6;
+    generalTierFlag = 0x20 & data[0];
+    generalTierFlag = generalTierFlag > 5;
+    generalProfileIdc = 0x1F & data[0];
+
+    // Next 4 bytes is compatibility flag
+    memcpy(&generalProfileCompatibilityFlag, &data[1], 4);
+
+    // Next 6 bytes is constraint indicator flag
+    memcpy(&generalConstraintIndicatorFlag, &data[5], 6);
+
+    // Next 1 byte is general Level IDC
+    generalLevelIdc = data[11];
+
+    if (*alreadyFilled) {
+        bool overwriteTierValue = false;
+
+        //find profile space
+        uint8_t prvGeneralProfileSpace; //2 bit
+        prvGeneralProfileSpace = 0xC0 & tmpHeader[1];
+        prvGeneralProfileSpace = prvGeneralProfileSpace > 6;
+        //prev needs to be same as current
+        if (prvGeneralProfileSpace != generalProfileSpace) {
+            ALOGW("Something wrong!!! profile space mismatch");
+        }
+
+        uint8_t prvGeneralTierFlag = 0x20 & tmpHeader[1];
+        prvGeneralTierFlag = prvGeneralTierFlag > 5;
+
+        if (prvGeneralTierFlag < generalTierFlag) {
+            overwriteTierValue = true;
+            ALOGV("Found higher tier value, replacing old one");
+        }
+
+        uint8_t prvGeneralProfileIdc = 0x1F & tmpHeader[1];
+
+        if (prvGeneralProfileIdc != generalProfileIdc) {
+            ALOGW("Something is wrong!!! profile space mismatch");
+        }
+
+        if (overwriteTierValue) {
+            tmpHeader[1] = data[0];
+        }
+
+        //general level IDC should be set highest among all
+        if (tmpHeader[12] < data[11]) {
+            tmpHeader[12] = data[11];
+            ALOGV("Found higher level IDC value, replacing old one");
+        }
+
+    } else {
+        *alreadyFilled = true;
+        tmpHeader[1] = data[0];
+        memcpy(&tmpHeader[2], &data[1], 4);
+        memcpy(&tmpHeader[6], &data[5], 6);
+        tmpHeader[12] = data[11];
+    }
+
+    char printCodecConfig[PROPERTY_VALUE_MAX];
+    property_get("hevc.mux.print.codec.config", printCodecConfig, "0");
+
+    if (atoi(printCodecConfig)) {
+        //if property enabled, print these values
+        ALOGI("Start::-----------------");
+        ALOGI("generalProfileSpace = %2x", generalProfileSpace);
+        ALOGI("generalTierFlag     = %2x", generalTierFlag);
+        ALOGI("generalProfileIdc   = %2x", generalProfileIdc);
+        ALOGI("generalLevelIdc     = %2x", generalLevelIdc);
+        ALOGI("generalProfileCompatibilityFlag = %2x %2x %2x %2x", generalProfileCompatibilityFlag[0],
+               generalProfileCompatibilityFlag[1], generalProfileCompatibilityFlag[2],
+               generalProfileCompatibilityFlag[3]);
+        ALOGI("generalConstraintIndicatorFlag = %2x %2x %2x %2x %2x %2x", generalConstraintIndicatorFlag[0],
+               generalConstraintIndicatorFlag[1], generalConstraintIndicatorFlag[2],
+               generalConstraintIndicatorFlag[3], generalConstraintIndicatorFlag[4],
+               generalConstraintIndicatorFlag[5]);
+        ALOGI("End::-----------------");
+    }
+
+    return OK;
+}
+
+static const uint8_t *findNextStartCode(
+       const uint8_t *data, size_t length) {
+    ALOGV("findNextStartCode: %p %d", data, length);
+
+    size_t bytesLeft = length;
+
+    while (bytesLeft > 4 &&
+            memcmp("\x00\x00\x00\x01", &data[length - bytesLeft], 4)) {
+        --bytesLeft;
+    }
+
+    if (bytesLeft <= 4) {
+        bytesLeft = 0; // Last parameter set
+    }
+
+    return &data[length - bytesLeft];
+}
+
+const uint8_t *ExtendedUtils::HEVCMuxer::parseHEVCParamSet(
+        const uint8_t *data, size_t length, List<HEVCParamSet> &paramSetList, size_t *paramSetLen) {
+    ALOGV("parseHEVCParamSet called");
+    const uint8_t *nextStartCode = findNextStartCode(data, length);
+    *paramSetLen = nextStartCode - data;
+    if (*paramSetLen == 0) {
+        ALOGE("Param set is malformed, since its length is 0");
+        return NULL;
+    }
+
+    HEVCParamSet paramSet(*paramSetLen, data);
+    paramSetList.push_back(paramSet);
+
+    return nextStartCode;
+}
+
+static void getHEVCNalUnitType(uint8_t byte, uint8_t* type) {
+    ALOGV("getNalUnitType: %d", (int)byte);
+    // nal_unit_type: 6-bit unsigned integer
+    *type = (byte & 0x7E) >> 1;
+}
+
+size_t ExtendedUtils::HEVCMuxer::parseHEVCCodecSpecificData(
+        const uint8_t *data, size_t size,List<HEVCParamSet> &vidParamSet,
+        List<HEVCParamSet> &seqParamSet, List<HEVCParamSet> &picParamSet ) {
+    ALOGV("parseHEVCCodecSpecificData called");
+    // Data starts with a start code.
+    // VPS, SPS and PPS are separated with start codes.
+    uint8_t type = kHEVCNalUnitTypeVidParamSet;
+    bool gotVps = false;
+    bool gotSps = false;
+    bool gotPps = false;
+    const uint8_t *tmp = data;
+    const uint8_t *nextStartCode = data;
+    size_t bytesLeft = size;
+    size_t paramSetLen = 0;
+    size_t codecSpecificDataSize = 0;
+    while (bytesLeft > 4 && !memcmp("\x00\x00\x00\x01", tmp, 4)) {
+        getHEVCNalUnitType(*(tmp + 4), &type);
+        if (type == kHEVCNalUnitTypeVidParamSet) {
+            nextStartCode = parseHEVCParamSet(tmp + 4, bytesLeft - 4, vidParamSet, &paramSetLen);
+            if (!gotVps) {
+                gotVps = true;
+            }
+        } else if (type == kHEVCNalUnitTypeSeqParamSet) {
+            nextStartCode = parseHEVCParamSet(tmp + 4, bytesLeft - 4, seqParamSet, &paramSetLen);
+            if (!gotSps) {
+                gotSps = true;
+            }
+
+        } else if (type == kHEVCNalUnitTypePicParamSet) {
+            nextStartCode = parseHEVCParamSet(tmp + 4, bytesLeft - 4, picParamSet, &paramSetLen);
+            if (!gotPps) {
+                gotPps = true;
+            }
+        } else {
+            ALOGE("Only VPS, SPS and PPS Nal units are expected");
+            return ERROR_MALFORMED;
+        }
+
+        if (nextStartCode == NULL) {
+            ALOGE("Next start code is NULL");
+            return ERROR_MALFORMED;
+        }
+
+        // Move on to find the next parameter set
+        bytesLeft -= nextStartCode - tmp;
+        tmp = nextStartCode;
+        codecSpecificDataSize += (2 + paramSetLen);
+    }
+
+#if 0
+//not adding this check now, but might be needed
+    if (!gotVps || !gotVps || !gotVps ) {
+        return 0;
+    }
+#endif
+
+    return codecSpecificDataSize;
+}
+
+status_t ExtendedUtils::HEVCMuxer::makeHEVCCodecSpecificData(
+                         const uint8_t *data, size_t size, void** codecSpecificData,
+                         size_t *codecSpecificDataSize) {
+    ALOGV("makeHEVCCodecSpecificData called");
+
+    if (*codecSpecificData != NULL) {
+        ALOGE("Already have codec specific data");
+        return ERROR_MALFORMED;
+    }
+
+    if (size < 4) {
+        ALOGE("Codec specific data length too short: %zu", size);
+        return ERROR_MALFORMED;
+    }
+
+    // Data is in the form of HVCCodecSpecificData
+    if (memcmp("\x00\x00\x00\x01", data, 4)) {
+        // 23 byte fixed header
+        if (size < 23) {
+            ALOGE("Codec specific data length too short: %zu", size);
+            return ERROR_MALFORMED;
+        }
+
+        *codecSpecificData = malloc(size);
+
+        if (*codecSpecificData != NULL) {
+            *codecSpecificDataSize = size;
+            memcpy(*codecSpecificData, data, size);
+            return OK;
+        }
+
+        return NO_MEMORY;
+    }
+
+    List<HEVCParamSet> vidParamSets;
+    List<HEVCParamSet> seqParamSets;
+    List<HEVCParamSet> picParamSets;
+
+    if ((*codecSpecificDataSize = parseHEVCCodecSpecificData(data, size,
+                                   vidParamSets, seqParamSets, picParamSets)) <= 0) {
+        ALOGE("cannot parser codec specific data, bailing out");
+        return ERROR_MALFORMED;
+    }
+
+    size_t numOfNALArray = 0;
+    bool doneWritingVPS = true, doneWritingSPS = true, doneWritingPPS = true;
+
+    if (!vidParamSets.empty()) {
+        doneWritingVPS = false;
+        ++numOfNALArray;
+    }
+
+    if (!seqParamSets.empty()) {
+       doneWritingSPS = false;
+       ++numOfNALArray;
+    }
+
+    if (!picParamSets.empty()) {
+       doneWritingPPS = false;
+       ++numOfNALArray;
+    }
+
+    //additional 23 bytes needed (22 bytes for hvc1 header + 1 byte for number of arrays)
+    *codecSpecificDataSize += 23;
+    //needed 3 bytes per NAL array
+    *codecSpecificDataSize += 3 * numOfNALArray;
+
+    int count = 0;
+    void *codecConfigData = malloc(*codecSpecificDataSize);
+    if (codecConfigData == NULL) {
+        ALOGE("Failed to allocate memory, bailing out");
+        return NO_MEMORY;
+    }
+
+    uint8_t *header = (uint8_t *)codecConfigData;
+    // 8  - bit version
+    header[0]  = 1;
+    //Profile space 2 bit, tier flag 1 bit and profile IDC 5 bit
+    header[1]  = 0x00;
+    // 32 - bit compatibility flag
+    header[2]  = 0x00;
+    header[3]  = 0x00;
+    header[4]  = 0x00;
+    header[5]  = 0x00;
+    // 48 - bit general constraint indicator flag
+    header[6]  = header[7]  = header[8]  = 0x00;
+    header[9]  = header[10] = header[11] = 0x00;
+    // 8  - bit general IDC level
+    header[12] = 0x00;
+    // 4  - bit reserved '1111'
+    // 12 - bit spatial segmentation idc
+    header[13] = 0xf0;
+    header[14] = 0x00;
+    // 6  - bit reserved '111111'
+    // 2  - bit parallelism Type
+    header[15] = 0xfc;
+    // 6  - bit reserved '111111'
+    // 2  - bit chromaFormat
+    header[16] = 0xfc;
+    // 5  - bit reserved '11111'
+    // 3  - bit DepthLumaMinus8
+    header[17] = 0xf8;
+    // 5  - bit reserved '11111'
+    // 3  - bit DepthChromaMinus8
+    header[18] = 0xf8;
+    // 16 - bit average frame rate
+    header[19] = header[20] = 0x00;
+    // 2  - bit constant frame rate
+    // 3  - bit num temporal layers
+    // 1  - bit temoral nested
+    // 2  - bit lengthSizeMinusOne
+    header[21] = 0x07;
+
+    // 8-bit number of NAL types
+    header[22] = (uint8_t)numOfNALArray;
+
+    header += 23;
+    count  += 23;
+
+    bool ifProfileIDCAlreadyFilled = false;
+
+    if (!doneWritingVPS) {
+        doneWritingVPS = true;
+        ALOGV("Writing VPS");
+        //8-bit, last 6 bit for NAL type
+        header[0] = 0x20; // NAL type is VPS
+        //16-bit, number of nal Units
+        uint16_t vidParamSetLength = vidParamSets.size();
+        header[1] = vidParamSetLength >> 8;
+        header[2] = vidParamSetLength && 0xff;
+
+        header += 3;
+        count  += 3;
+
+        for (List<HEVCParamSet>::iterator it = vidParamSets.begin();
+            it != vidParamSets.end(); ++it) {
+            // 16-bit video parameter set length
+            uint16_t vidParamSetLength = it->mLength;
+            header[0] = vidParamSetLength >> 8;
+            header[1] = vidParamSetLength & 0xff;
+
+            extractNALRBSPData(it->mData, it->mLength,
+                               (uint8_t **)&codecConfigData,
+                               &ifProfileIDCAlreadyFilled);
+
+            // VPS NAL unit (video parameter length bytes)
+            memcpy(&header[2], it->mData, vidParamSetLength);
+            header += (2 + vidParamSetLength);
+            count  += (2 + vidParamSetLength);
+        }
+    }
+
+    if (!doneWritingSPS) {
+        doneWritingSPS = true;
+        ALOGV("Writting SPS");
+        //8-bit, last 6 bit for NAL type
+        header[0] = 0x21; // NAL type is SPS
+        //16-bit, number of nal Units
+        uint16_t seqParamSetLength = seqParamSets.size();
+        header[1] = seqParamSetLength >> 8;
+        header[2] = seqParamSetLength && 0xff;
+
+        header += 3;
+        count  += 3;
+
+        for (List<HEVCParamSet>::iterator it = seqParamSets.begin();
+              it != seqParamSets.end(); ++it) {
+            // 16-bit sequence parameter set length
+            uint16_t seqParamSetLength = it->mLength;
+
+            // 16-bit number of NAL units of this type
+            header[0] = seqParamSetLength >> 8;
+            header[1] = seqParamSetLength & 0xff;
+
+            extractNALRBSPData(it->mData, it->mLength,
+                               (uint8_t **)&codecConfigData,
+                               &ifProfileIDCAlreadyFilled);
+
+            // SPS NAL unit (sequence parameter length bytes)
+            memcpy(&header[2], it->mData, seqParamSetLength);
+            header += (2 + seqParamSetLength);
+            count  += (2 + seqParamSetLength);
+        }
+    }
+
+    if (!doneWritingPPS) {
+        doneWritingPPS = true;
+        ALOGV("writing PPS");
+        //8-bit, last 6 bit for NAL type
+        header[0] = 0x22; // NAL type is PPS
+        //16-bit, number of nal Units
+        uint16_t picParamSetLength = picParamSets.size();
+        header[1] = picParamSetLength >> 8;
+        header[2] = picParamSetLength && 0xff;
+
+        header += 3;
+        count  += 3;
+
+        for (List<HEVCParamSet>::iterator it = picParamSets.begin();
+             it != picParamSets.end(); ++it) {
+            // 16-bit picture parameter set length
+            uint16_t picParamSetLength = it->mLength;
+            header[0] = picParamSetLength >> 8;
+            header[1] = picParamSetLength & 0xff;
+
+            // PPS Nal unit (picture parameter set length bytes)
+            memcpy(&header[2], it->mData, picParamSetLength);
+            header += (2 + picParamSetLength);
+            count  += (2 + picParamSetLength);
+        }
+    }
+    *codecSpecificData = codecConfigData;
+    return OK;
+}
+
+sp<MetaData> ExtendedUtils::MakeHEVCCodecSpecificData(const sp<ABuffer> &accessUnit) {
+    const uint8_t *data = accessUnit->data();
+    size_t size = accessUnit->size();
+
+    if (data == NULL || size == 0) {
+        ALOGE("Invalid HEVC CSD");
+        return NULL;
+    }
+
+    sp<MetaData> meta = new MetaData;
+    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_HEVC);
+    meta->setData(kKeyHVCC, kTypeHVCC, data, size);
+
+    // Set width & height to minimum (QCIF). This will trigger a port reconfig &
+    // the decoder will find the correct dimensions.
+    meta->setInt32(kKeyWidth, (int32_t)177);
+    meta->setInt32(kKeyHeight, (int32_t)144);
+
+    // Let the decoder do the frame parsing for HEVC in case access unit data is
+    // not aligned to frame boundaries.
+    meta->setInt32(kKeyUseArbitraryMode, 1);
+
+    // Set the container format as TS, so that timestamp reordering can be
+    // enabled for HEVC TS clips.
+    meta->setCString(kKeyFileFormat, MEDIA_MIMETYPE_CONTAINER_MPEG2TS);
+
+    return meta;
+}
+
+bool ExtendedUtils::IsHevcIDR(const sp<ABuffer> &buffer) {
+    const uint8_t *data = buffer->data();
+    size_t size = buffer->size();
+
+    bool foundRef = false;
+    const uint8_t *nalStart;
+    size_t nalSize;
+    while (!foundRef && getNextNALUnit(&data, &size, &nalStart, &nalSize, true) == OK) {
+        if (nalSize == 0) {
+            ALOGW("Encountered zero-length HEVC NAL", nalSize);
+            return false;
+        }
+
+        uint8_t nalType;
+        getHEVCNalUnitType(nalStart[0], &nalType);
+
+        switch(nalType) {
+        case kHEVCNalUnitTypeIDR:
+        case kHEVCNalUnitTypeIDRNoLP:
+        case kHEVCNalUnitTypeCRA:
+            foundRef = true;
+            break;
+        }
+    }
+
+    return foundRef;
+}
+
+bool ExtendedUtils::ShellProp::isAudioDisabled(bool isEncoder) {
+    bool retVal = false;
+    char disableAudio[PROPERTY_VALUE_MAX];
+    property_get("persist.debug.sf.noaudio", disableAudio, "0");
+    if (isEncoder && (atoi(disableAudio) & 0x02)) {
+        retVal = true;
+    } else if (!isEncoder && atoi(disableAudio) & 0x01) {
+        retVal = true;
+    }
+    return retVal;
+}
+
+bool ExtendedUtils::ShellProp::isVideoRenderingDisabled() {
+    char disableVideoRendering[PROPERTY_VALUE_MAX];
+    property_get("persist.debug.sf.nodisplay", disableVideoRendering, "0");
+    return atoi(disableVideoRendering) > 0 ? true : false;
+}
+
+void ExtendedUtils::ShellProp::setEncoderProfile(
+        video_encoder &videoEncoder, int32_t &videoEncoderProfile,
+        int32_t &videoEncoderLevel) {
+    char value[PROPERTY_VALUE_MAX];
+    if (!property_get("encoder.video.profile", value, NULL) > 0) {
+        return;
+    }
+
+    int32_t profile = videoEncoderProfile;
+    int32_t level = videoEncoderLevel;
+    switch (videoEncoder) {
+        case VIDEO_ENCODER_H264:
+            // Set the minimum valid level if the level was undefined;
+            // encoder will choose the right level anyways
+            level = (level < 0) ? OMX_VIDEO_AVCLevel1 : level;
+            if (strncmp("base", value, 4) == 0) {
+                profile = OMX_VIDEO_AVCProfileBaseline;
+                ALOGI("H264 Baseline Profile");
+            } else if (strncmp("main", value, 4) == 0) {
+                profile = OMX_VIDEO_AVCProfileMain;
+                ALOGI("H264 Main Profile");
+            } else if (strncmp("high", value, 4) == 0) {
+                profile = OMX_VIDEO_AVCProfileHigh;
+                ALOGI("H264 High Profile");
+            } else {
+                ALOGW("Unsupported H264 Profile");
+            }
+            break;
+        case VIDEO_ENCODER_MPEG_4_SP:
+            level = (level < 0) ? OMX_VIDEO_MPEG4Level0 : level;
+            if (strncmp("simple", value, 5) == 0 ) {
+                profile = OMX_VIDEO_MPEG4ProfileSimple;
+                ALOGI("MPEG4 Simple profile");
+            } else if (strncmp("asp", value, 3) == 0 ) {
+                profile = OMX_VIDEO_MPEG4ProfileAdvancedSimple;
+                ALOGI("MPEG4 Advanced Simple Profile");
+            } else {
+                ALOGW("Unsupported MPEG4 Profile");
+            }
+            break;
+        default:
+            ALOGW("No custom profile support for other codecs");
+            break;
+    }
+    // Override _both_ profile and level, only if they are valid
+    if (profile && level) {
+        videoEncoderProfile = profile;
+        videoEncoderLevel = level;
+    }
+}
+
+int64_t ExtendedUtils::ShellProp::getMaxAVSyncLateMargin() {
+    char lateMarginMs[PROPERTY_VALUE_MAX] = {0};
+    property_get("media.sf.set.late.margin", lateMarginMs, "0");
+    int64_t newLateMarginUs = atoi(lateMarginMs)*1000;
+    int64_t maxLateMarginUs = newLateMarginUs;
+
+    if (newLateMarginUs > kDefaultAVSyncLateMargin
+            || newLateMarginUs < kDefaultAVSyncLateMargin) {
+        maxLateMarginUs = kDefaultAVSyncLateMargin;
+    }
+
+    ALOGI("AV Sync late margin : Intended=%lldms Using=%lldms",
+            maxLateMarginUs/1000, newLateMarginUs/1000);
+    return maxLateMarginUs;
+}
+
+bool ExtendedUtils::ShellProp::isSmoothStreamingEnabled() {
+    char prop[PROPERTY_VALUE_MAX] = {0};
+    property_get("mm.enable.smoothstreaming", prop, "0");
+    if (!strncmp(prop, "true", 4) || atoi(prop)) {
+        return true;
+    }
+    return false;
+}
+
+void ExtendedUtils::ShellProp::getRtpPortRange(unsigned *start, unsigned *end) {
+    char value[PROPERTY_VALUE_MAX];
+    if (!property_get("persist.sys.media.rtp-ports", value, NULL)) {
+        ALOGV("Cannot get property of persist.sys.media.rtp-ports");
+        *start = kDefaultRtpPortRangeStart;
+        *end = kDefaultRtpPortRangeEnd;
+        return;
+    }
+
+    if (sscanf(value, "%u-%u", start, end) != 2) {
+        ALOGE("Failed to parse rtp port range from '%s'.", value);
+        *start = kDefaultRtpPortRangeStart;
+        *end = kDefaultRtpPortRangeEnd;
+        return;
+    }
+
+    if (*start > *end || *start <= kMinRtpPort || *end >= kMaxRtpPort) {
+        ALOGE("Illegal rtp port start/end specified, reverting to defaults.");
+        *start = kDefaultRtpPortRangeStart;
+        *end = kDefaultRtpPortRangeEnd;
+        return;
+    }
+
+    ALOGV("rtp port_start = %u, port_end = %u", *start, *end);
+}
+
+void ExtendedUtils::setBFrames(
+        OMX_VIDEO_PARAM_MPEG4TYPE &mpeg4type, const char* componentName) {
+    //ignore non QC components
+    if (strncmp(componentName, "OMX.qcom.", 9)) {
+        return;
+    }
+    if (mpeg4type.eProfile > OMX_VIDEO_MPEG4ProfileSimple) {
+        mpeg4type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
+        mpeg4type.nPFrames = (mpeg4type.nPFrames + kNumBFramesPerPFrame) /
+                (kNumBFramesPerPFrame + 1);
+        mpeg4type.nBFrames = mpeg4type.nPFrames * kNumBFramesPerPFrame;
+    }
+    return;
+}
+
+void ExtendedUtils::setBFrames(
+        OMX_VIDEO_PARAM_AVCTYPE &h264type, const int32_t iFramesInterval,
+        const int32_t frameRate, const char* componentName) {
+    //ignore non QC components
+    if (strncmp(componentName, "OMX.qcom.", 9)) {
+        return;
+    }
+    OMX_U32 val = 0;
+    if (iFramesInterval < 0) {
+        val =  0xFFFFFFFF;
+    } else if (iFramesInterval == 0) {
+        val = 0;
+    } else {
+        val  = frameRate * iFramesInterval - 1;
+        CHECK(val > 1);
+    }
+
+    h264type.nPFrames = val;
+
+    if (h264type.nPFrames == 0) {
+        h264type.nAllowedPictureTypes = OMX_VIDEO_PictureTypeI;
+    }
+
+    if (h264type.eProfile > OMX_VIDEO_AVCProfileBaseline) {
+        h264type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
+        h264type.nPFrames = (h264type.nPFrames + kNumBFramesPerPFrame) /
+                (kNumBFramesPerPFrame + 1);
+        h264type.nBFrames = h264type.nPFrames * kNumBFramesPerPFrame;
+
+        //enable CABAC as default entropy mode for High/Main profiles
+        h264type.bEntropyCodingCABAC = OMX_TRUE;
+        h264type.nCabacInitIdc = 0;
+    }
+    return;
+}
+
+sp<MetaData> ExtendedUtils::updatePCMFormatAndBitwidth(
+                sp<MediaSource> &audioSource, bool offloadAudio)
+{
+    sp<MetaData> tempMetadata = new MetaData;
+    sp<MetaData> format = audioSource->getFormat();
+    int bitWidth = 16;
+    format->findInt32(kKeyBitsPerSample, &bitWidth);
+    tempMetadata->setInt32(kKeyBitsPerSample, bitWidth);
+    tempMetadata->setInt32(kKeyPcmFormat, AUDIO_FORMAT_PCM_16_BIT);
+    char prop_pcmoffload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.24bit.enable", prop_pcmoffload, "0");
+    if ((offloadAudio) &&
+        (24 == bitWidth) &&
+        (!strcmp(prop_pcmoffload, "true") || atoi(prop_pcmoffload))) {
+        tempMetadata->setInt32(kKeyPcmFormat, AUDIO_FORMAT_PCM_8_24_BIT);
+    }
+    return tempMetadata;
+}
+
+/*
+QCOM HW AAC encoder allowed bitrates
+------------------------------------------------------------------------------------------------------------------
+Bitrate limit |AAC-LC(Mono)           | AAC-LC(Stereo)        |AAC+(Mono)            | AAC+(Stereo)            | eAAC+                      |
+Minimum     |Min(24000,0.5 * f_s)   |Min(24000,f_s)           | 24000                      |24000                        |  24000                       |
+Maximum    |Min(192000,6 * f_s)    |Min(192000,12 * f_s)  | Min(192000,6 * f_s)  | Min(192000,12 * f_s)  |  Min(192000,12 * f_s) |
+------------------------------------------------------------------------------------------------------------------
+*/
+bool ExtendedUtils::UseQCHWAACEncoder(audio_encoder Encoder,int32_t Channel,int32_t BitRate,int32_t SampleRate)
+{
+    int minBiteRate = -1;
+    int maxBiteRate = -1;
+    char propValue[PROPERTY_VALUE_MAX] = {0};
+    bool currentState;
+    ARG_TOUCH(BitRate);
+
+    property_get("qcom.hw.aac.encoder",propValue,NULL);
+    if (!strncmp(propValue,"true",sizeof("true"))) {
+        //check for QCOM's HW AAC encoder only when qcom.aac.encoder =  true;
+        ALOGV("qcom.aac.encoder enabled, check AAC encoder(%d) allowed bitrates",Encoder);
+
+        if (Channel == 0 && BitRate == 0 && SampleRate == 0) {
+            //this is a query call, simply reset and return state
+            ALOGV("mIsQCHWAACEncoder:%d", mIsQCHWAACEncoder);
+            currentState = mIsQCHWAACEncoder;
+            mIsQCHWAACEncoder = false;
+            return currentState;
+        }
+
+        switch (Encoder) {
+        case AUDIO_ENCODER_AAC:// for AAC-LC format
+            if (Channel == 1) {//mono
+                minBiteRate = MIN_BITERATE_AAC<(SampleRate/2)?MIN_BITERATE_AAC:(SampleRate/2);
+                maxBiteRate = MAX_BITERATE_AAC<(SampleRate*6)?MAX_BITERATE_AAC:(SampleRate*6);
+            } else if (Channel == 2) {//stereo
+                minBiteRate = MIN_BITERATE_AAC<SampleRate?MIN_BITERATE_AAC:SampleRate;
+                maxBiteRate = MAX_BITERATE_AAC<(SampleRate*12)?MAX_BITERATE_AAC:(SampleRate*12);
+            }
+            break;
+        case AUDIO_ENCODER_HE_AAC:// for AAC+ format
+            // Do not use HW AAC encoder for HE AAC(AAC+) formats.
+            mIsQCHWAACEncoder = false;
+            break;
+        default:
+            ALOGV("encoder:%d not supported by QCOM HW AAC encoder",Encoder);
+
+        }
+
+        //return true only when 1. minBiteRate and maxBiteRate are updated(not -1) 2. minBiteRate <= SampleRate <= maxBiteRate
+        if (BitRate >= minBiteRate && BitRate <= maxBiteRate) {
+            mIsQCHWAACEncoder = true;
+        }
+    }
+
+    return mIsQCHWAACEncoder;
+}
+
+bool ExtendedUtils::is24bitPCMOffloadEnabled() {
+    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.24bit.enable", propPCMOfload, "0");
+    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
+        return true;
+    else
+        return false;
+}
+
+bool ExtendedUtils::is16bitPCMOffloadEnabled() {
+    char propPCMOfload[PROPERTY_VALUE_MAX] = {0};
+    property_get("audio.offload.pcm.16bit.enable", propPCMOfload, "0");
+    if (!strncmp(propPCMOfload, "true", 4) || atoi(propPCMOfload))
+        return true;
+    else
+        return false;
+}
+
+bool ExtendedUtils::isTrackOffloadEnabled() {
+    char propTrackOffload[PROPERTY_VALUE_MAX] = {0};
+
+    //track offload will work only if 16 bit PCM offloading is enabled
+    if (is16bitPCMOffloadEnabled()) {
+        property_get("audio.offload.track.enabled", propTrackOffload, "0");
+        if (!strncmp(propTrackOffload, "true", 4) || atoi(propTrackOffload))
+            return true;
+    }
+
+    return false;
+}
+
+bool ExtendedUtils::isRAWFormat(const sp<MetaData> &meta) {
+    const char *mime = {0};
+    if (meta == NULL) {
+        return false;
+    }
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+    if (!strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW, 9))
+        return true;
+    else
+        return false;
+}
+
+bool ExtendedUtils::isRAWFormat(const sp<AMessage> &format) {
+    AString mime;
+    if (format == NULL) {
+        return false;
+    }
+    CHECK(format->findString("mime", &mime));
+    if (!strncasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_RAW, 9))
+        return true;
+    else
+        return false;
+}
+
+int32_t ExtendedUtils::getPcmSampleBits(const sp<MetaData> &meta) {
+    int32_t bitWidth = 16;
+    if (meta != NULL) {
+        meta->findInt32(kKeyBitsPerSample, &bitWidth);
+    }
+    return bitWidth;
+}
+
+int32_t ExtendedUtils::getPcmSampleBits(const sp<AMessage> &format) {
+    int32_t bitWidth = 16;
+    if (format != NULL) {
+        format->findInt32("sbit", &bitWidth);
+    }
+    return bitWidth;
+}
+
+int32_t ExtendedUtils::getPCMFormat(const sp<MetaData> &meta) {
+    int32_t pcmFormat = AUDIO_FORMAT_PCM_16_BIT;
+    if (meta != NULL) {
+        meta->findInt32(kKeyPcmFormat, &pcmFormat);
+    }
+    return pcmFormat;
+}
+
+void ExtendedUtils::setKeyPCMFormat(const sp<MetaData> &meta, int32_t pcmFormat) {
+    if (meta != NULL) {
+        meta->setInt32(kKeyPcmFormat, pcmFormat);
+    }
+}
+
+//- returns NULL if we dont really need a new extractor (or cannot),
+//  valid extractor is returned otherwise
+//- caller needs to check for NULL
+//  ----------------------------------------
+//  defaultExt - the existing extractor
+//  source - file source
+//  mime - container mime
+//  ----------------------------------------
+//  Note: defaultExt will be deleted in this function if the new parser is selected
+
+sp<MediaExtractor> ExtendedUtils::MediaExtractor_CreateIfNeeded(sp<MediaExtractor> defaultExt,
+                                                            const sp<DataSource> &source,
+                                                            const char *mime) {
+    bool bCheckExtendedExtractor = false;
+    bool videoTrackFound         = false;
+    bool audioTrackFound         = false;
+    bool amrwbAudio              = false;
+    bool hevcVideo               = false;
+    bool dolbyAudio              = false;
+    bool mpeg4Container          = false;
+    bool aacAudioTrack           = false;
+    int  numOfTrack              = 0;
+
+    mpeg4Container = !strncasecmp(mime,
+                                MEDIA_MIMETYPE_CONTAINER_MPEG4,
+                                strlen(MEDIA_MIMETYPE_CONTAINER_MPEG4));
+
+    if (defaultExt != NULL) {
+        for (size_t trackItt = 0; trackItt < defaultExt->countTracks(); ++trackItt) {
+            ++numOfTrack;
+            sp<MetaData> meta = defaultExt->getTrackMetaData(trackItt);
+            const char *_mime;
+            CHECK(meta->findCString(kKeyMIMEType, &_mime));
+
+            String8 mime = String8(_mime);
+
+            const char * dolbyFormats[ ] = {
+                MEDIA_MIMETYPE_AUDIO_AC3,
+                MEDIA_MIMETYPE_AUDIO_EAC3,
+#ifdef DOLBY_UDC
+                MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
+#endif
+            };
+
+            if (!strncasecmp(mime.string(), "audio/", 6)) {
+                audioTrackFound = true;
+
+                amrwbAudio = !strncasecmp(mime.string(),
+                                          MEDIA_MIMETYPE_AUDIO_AMR_WB,
+                                          strlen(MEDIA_MIMETYPE_AUDIO_AMR_WB));
+
+                aacAudioTrack = !strncasecmp(mime.string(),
+                                          MEDIA_MIMETYPE_AUDIO_AAC,
+                                          strlen(MEDIA_MIMETYPE_AUDIO_AAC));
+
+                for (size_t i = 0; i < ARRAY_SIZE(dolbyFormats); i++) {
+                    if (!strncasecmp(mime.string(), dolbyFormats[i], strlen(dolbyFormats[i]))) {
+                        dolbyAudio = true;
+                    }
+                }
+
+                if (amrwbAudio || dolbyAudio) {
+                    break;
+                }
+            } else if (!strncasecmp(mime.string(), "video/", 6)) {
+                videoTrackFound = true;
+                if(!strncasecmp(mime.string(), "video/hevc", 10)) {
+                    hevcVideo = true;
+                }
+            }
+        }
+
+        if (amrwbAudio || dolbyAudio) {
+            bCheckExtendedExtractor = true;
+        } else if (numOfTrack  == 0) {
+            bCheckExtendedExtractor = true;
+        } else if (numOfTrack == 1) {
+            if ((videoTrackFound) ||
+                (!videoTrackFound && !audioTrackFound) ||
+                (audioTrackFound && mpeg4Container && aacAudioTrack)) {
+                bCheckExtendedExtractor = true;
+            }
+        } else if (numOfTrack >= 2) {
+            if (videoTrackFound && audioTrackFound) {
+                if (amrwbAudio || hevcVideo ) {
+                    bCheckExtendedExtractor = true;
+                }
+            } else {
+                bCheckExtendedExtractor = true;
+            }
+        }
+    } else {
+        bCheckExtendedExtractor = true;
+    }
+
+    if (!bCheckExtendedExtractor) {
+        ALOGD("extended extractor not needed, return default");
+        return defaultExt;
+    }
+
+    //Create Extended Extractor only if default extractor is not selected
+    ALOGD("Try creating ExtendedExtractor");
+    sp<MediaExtractor>  retExtExtractor = ExtendedExtractor::Create(source, mime);
+
+    if (retExtExtractor == NULL) {
+        ALOGD("Couldn't create the extended extractor, return default one");
+        return defaultExt;
+    }
+
+    if (defaultExt == NULL) {
+        ALOGD("default extractor is NULL, return extended extractor");
+        return retExtExtractor;
+    }
+
+    //bCheckExtendedExtractor is true which means default extractor was found
+    //but we want to give preference to extended extractor based on certain
+    //conditions.
+
+    //needed to prevent a leak in case both extractors are valid
+    //but we still dont want to use the extended one. we need
+    //to delete the new one
+    bool bUseDefaultExtractor = true;
+
+    const char * extFormats[ ] = {
+        MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS,
+        MEDIA_MIMETYPE_VIDEO_HEVC,
+#ifdef DOLBY_UDC
+        MEDIA_MIMETYPE_AUDIO_AC3,
+        MEDIA_MIMETYPE_AUDIO_EAC3,
+        MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
+#endif
+        MEDIA_MIMETYPE_AUDIO_AAC,
+    };
+
+    for (size_t trackItt = 0; (trackItt < retExtExtractor->countTracks()); ++trackItt) {
+        sp<MetaData> meta = retExtExtractor->getTrackMetaData(trackItt);
+        const char *mime;
+        bool success = meta->findCString(kKeyMIMEType, &mime);
+        bool isExtFormat = false;
+        for (size_t i = 0; i < ARRAY_SIZE(extFormats); i++) {
+            if (!strncasecmp(mime, extFormats[i], strlen(extFormats[i]))) {
+                isExtFormat = true;
+                break;
+            }
+        }
+
+        if ((success == true) && isExtFormat) {
+            ALOGD("Discarding default extractor and using the extended one");
+            bUseDefaultExtractor = false;
+            break;
+        }
+    }
+
+    if (bUseDefaultExtractor) {
+        ALOGD("using default extractor inspite of having a new extractor");
+        retExtExtractor.clear();
+        return defaultExt;
+    } else {
+        defaultExt.clear();
+        return retExtExtractor;
+    }
+
+}
+
+bool ExtendedUtils::isAVCProfileSupported(int32_t  profile) {
+   if (profile == OMX_VIDEO_AVCProfileMain ||
+           profile == OMX_VIDEO_AVCProfileHigh ||
+           profile == OMX_VIDEO_AVCProfileBaseline) {
+      return true;
+   } else {
+      return false;
+   }
+}
+
+void ExtendedUtils::updateNativeWindowBufferGeometry(ANativeWindow* anw,
+        OMX_U32 width, OMX_U32 height, OMX_COLOR_FORMATTYPE colorFormat) {
+    ARG_TOUCH(anw);
+    ARG_TOUCH(width);
+    ARG_TOUCH(height);
+    ARG_TOUCH(colorFormat);
+
+#if UPDATE_BUFFER_GEOMETRY_AVAILABLE
+    if (anw != NULL) {
+        ALOGI("Calling native window update buffer geometry [%lu x %lu]",
+                width, height);
+        status_t err = anw->perform(
+                anw, NATIVE_WINDOW_UPDATE_BUFFERS_GEOMETRY,
+                width, height, colorFormat);
+        if (err != OK) {
+            ALOGE("UPDATE_BUFFER_GEOMETRY failed %d", err);
+        }
+    }
+#endif
+}
+
+bool ExtendedUtils::checkIsThumbNailMode(const uint32_t flags, char* componentName) {
+    bool isInThumbnailMode = false;
+    if ((flags & OMXCodec::kClientNeedsFramebuffer) && !strncmp(componentName, "OMX.qcom.", 9)) {
+        isInThumbnailMode = true;
+    }
+    return isInThumbnailMode;
+}
+
+void ExtendedUtils::setArbitraryModeIfInterlaced(
+	const uint8_t *ptr, const sp<MetaData> &meta) {
+
+   if (ptr == NULL) {
+	return;
+   }
+   uint16_t spsSize = (((uint16_t)ptr[6]) << 8) + (uint16_t)(ptr[7]);
+   int32_t width = 0, height = 0, isInterlaced = 0;
+   const uint8_t *spsStart = &ptr[8];
+
+   sp<ABuffer> seqParamSet = new ABuffer(spsSize);
+   memcpy(seqParamSet->data(), spsStart, spsSize);
+   FindAVCDimensions(seqParamSet, &width, &height, NULL, NULL, &isInterlaced);
+
+   ALOGV("height is %d, width is %d, isInterlaced is %d\n", height, width, isInterlaced);
+   if (isInterlaced) {
+       meta->setInt32(kKeyUseArbitraryMode, 1);
+       meta->setInt32(kKeyInterlace, 1);	   
+   }
+   return; 
+}
+
+int32_t ExtendedUtils::checkIsInterlace(sp<MetaData> &meta) {
+    int32_t isInterlaceFormat = 0;
+
+    if(meta->findInt32(kKeyInterlace, &isInterlaceFormat)) {
+	ALOGI("interlace format detected");
+    }
+    return isInterlaceFormat;
+}
+
+void ExtendedUtils::applyPreRotation(
+        const CameraParameters& params, sp<MetaData> &meta) {
+
+    // Camera pre-rotates video buffers. Width and Height of
+    // of the image will be flipped if rotation is 90 or 270.
+    // Encoder must be made aware of the flip in this case.
+    const char *pRotation = params.get("video-rotation");
+    int32_t preRotation = pRotation ? atoi(pRotation) : 0;
+    bool flip = preRotation % 180;
+
+    if (flip) {
+        int32_t width = 0;
+        int32_t height = 0;
+        meta->findInt32(kKeyWidth, &width);
+        meta->findInt32(kKeyHeight, &height);
+
+        // width assigned to height is intentional
+        meta->setInt32(kKeyWidth, height);
+        meta->setInt32(kKeyStride, height);
+        meta->setInt32(kKeyHeight, width);
+        meta->setInt32(kKeySliceHeight, width);
+    }
+}
+
+void ExtendedUtils::updateVideoTrackInfoFromESDS_MPEG4Video(sp<MetaData> meta) {
+    const char* mime = NULL;
+    if (meta != NULL && meta->findCString(kKeyMIMEType, &mime) &&
+            mime && !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)) {
+        uint32_t type;
+        const void *data;
+        size_t size;
+        if (!meta->findData(kKeyESDS, &type, &data, &size) || !data) {
+            ALOGW("ESDS atom is invalid");
+            return;
+        }
+
+        if (checkDPFromCodecSpecificData((const uint8_t*) data, size)) {
+            meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG4_DP);
+        }
+    }
+}
+
+bool ExtendedUtils::checkDPFromCodecSpecificData(const uint8_t *data, size_t size) {
+    bool retVal = false;
+    size_t offset = 0, startCodeOffset = 0;
+    bool isStartCode = false;
+    const int kVolStartCode = 0x20;
+    const char kStartCode[] = "\x00\x00\x01";
+    // must contain at least 4 bytes for video_object_layer_start_code
+    const size_t kMinCsdSize = 4;
+
+    if (!data || (size < kMinCsdSize)) {
+        ALOGV("Invalid CSD (expected at least %zu bytes)", kMinCsdSize);
+        return retVal;
+    }
+
+    while (offset < size - 3) {
+        if ((data[offset + 3] & 0xf0) == kVolStartCode) {
+            if (!memcmp(&data[offset], kStartCode, 3)) {
+                startCodeOffset = offset;
+                isStartCode = true;
+                break;
+            }
+        }
+
+        offset++;
+    }
+
+    if (isStartCode) {
+        retVal = checkDPFromVOLHeader((const uint8_t*) &data[startCodeOffset],
+                (size - startCodeOffset));
+    }
+
+    return retVal;
+}
+
+bool ExtendedUtils::checkDPFromVOLHeader(const uint8_t *data, size_t size) {
+    bool retVal = false;
+    // must contain at least 4 bytes for video_object_layer_start_code + 9 bits of data
+    const size_t kMinHeaderSize = 6;
+
+    if (!data || (size < kMinHeaderSize)) {
+        ALOGV("Invalid VOL header (expected at least %zu bytes)", kMinHeaderSize);
+        return false;
+    }
+
+    ALOGV("Checking for MPEG4 DP bit");
+    ABitReader br(&data[4], (size - 4));
+    br.skipBits(1); // random_accessible_vol
+
+    unsigned videoObjectTypeIndication = br.getBits(8);
+    if (videoObjectTypeIndication == 0x12u) {
+        ALOGW("checkDPFromVOLHeader: videoObjectTypeIndication:%u",
+               videoObjectTypeIndication);
+        return false;
+    }
+
+    unsigned videoObjectLayerVerid = 1;
+    if (br.getBits(1)) {
+        videoObjectLayerVerid = br.getBits(4);
+        br.skipBits(3); // video_object_layer_priority
+        ALOGV("checkDPFromVOLHeader: videoObjectLayerVerid:%u",
+               videoObjectLayerVerid);
+    }
+
+    if (br.getBits(4) == 0x0f) { // aspect_ratio_info
+        ALOGV("checkDPFromVOLHeader: extended PAR");
+        br.skipBits(8); // par_width
+        br.skipBits(8); // par_height
+    }
+
+    if (br.getBits(1)) { // vol_control_parameters
+        br.skipBits(2);  // chroma_format
+        br.skipBits(1);  // low_delay
+        if (br.getBits(1)) { // vbv_parameters
+            br.skipBits(15); // first_half_bit_rate
+            br.skipBits(1);  // marker_bit
+            br.skipBits(15); // latter_half_bit_rate
+            br.skipBits(1);  // marker_bit
+            br.skipBits(15); // first_half_vbv_buffer_size
+            br.skipBits(1);  // marker_bit
+            br.skipBits(3);  // latter_half_vbv_buffer_size
+            br.skipBits(11); // first_half_vbv_occupancy
+            br.skipBits(1);  // marker_bit
+            br.skipBits(15); // latter_half_vbv_occupancy
+            br.skipBits(1);  // marker_bit
+        }
+    }
+
+    unsigned videoObjectLayerShape = br.getBits(2);
+    if (videoObjectLayerShape != 0x00u /* rectangular */) {
+        ALOGV("checkDPFromVOLHeader: videoObjectLayerShape:%x",
+               videoObjectLayerShape);
+        return false;
+    }
+
+    br.skipBits(1); // marker_bit
+    unsigned vopTimeIncrementResolution = br.getBits(16);
+    br.skipBits(1); // marker_bit
+    if (br.getBits(1)) {  // fixed_vop_rate
+        // range [0..vopTimeIncrementResolution)
+
+        // vopTimeIncrementResolution
+        // 2 => 0..1, 1 bit
+        // 3 => 0..2, 2 bits
+        // 4 => 0..3, 2 bits
+        // 5 => 0..4, 3 bits
+        // ...
+
+        if (vopTimeIncrementResolution <= 0u) {
+            return BAD_VALUE;
+        }
+
+        --vopTimeIncrementResolution;
+        unsigned numBits = 0;
+        while (vopTimeIncrementResolution > 0) {
+            ++numBits;
+            vopTimeIncrementResolution >>= 1;
+        }
+
+        br.skipBits(numBits);  // fixed_vop_time_increment
+    }
+
+    br.skipBits(1);  // marker_bit
+    br.skipBits(13); // video_object_layer_width
+    br.skipBits(1);  // marker_bit
+    br.skipBits(13); // video_object_layer_height
+    br.skipBits(1);  // marker_bit
+    br.skipBits(1);  // interlaced
+    br.skipBits(1);  // obmc_disable
+    unsigned spriteEnable = 0;
+    if (videoObjectLayerVerid == 1) {
+        spriteEnable = br.getBits(1);
+    } else {
+        spriteEnable = br.getBits(2);
+    }
+
+    if (spriteEnable == 0x1) { // static
+        int spriteWidth = br.getBits(13);
+        ALOGV("checkDPFromVOLHeader: spriteWidth:%d", spriteWidth);
+        br.skipBits(1) ; // marker_bit
+        br.skipBits(13); // sprite_height
+        br.skipBits(1);  // marker_bit
+        br.skipBits(13); // sprite_left_coordinate
+        br.skipBits(1);  // marker_bit
+        br.skipBits(13); // sprite_top_coordinate
+        br.skipBits(1);  // marker_bit
+        br.skipBits(6);  // no_of_sprite_warping_points
+        br.skipBits(2);  // sprite_warping_accuracy
+        br.skipBits(1);  // sprite_brightness_change
+        br.skipBits(1);  // low_latency_sprite_enable
+    } else if (spriteEnable == 0x2) { // GMC
+        br.skipBits(6); // no_of_sprite_warping_points
+        br.skipBits(2); // sprite_warping_accuracy
+        br.skipBits(1); // sprite_brightness_change
+    }
+
+    if (videoObjectLayerVerid != 1
+            && videoObjectLayerShape != 0x0u) {
+        br.skipBits(1);
+    }
+
+    if (br.getBits(1)) { // not_8_bit
+        br.skipBits(4);  // quant_precision
+        br.skipBits(4);  // bits_per_pixel
+    }
+
+    if (videoObjectLayerShape == 0x3) {
+        br.skipBits(1);
+        br.skipBits(1);
+        br.skipBits(1);
+    }
+
+    if (br.getBits(1)) { // quant_type
+        if (br.getBits(1)) { // load_intra_quant_mat
+            unsigned IntraQuantMat = 1;
+            for (int i = 0; i < 64 && IntraQuantMat; i++) {
+                 IntraQuantMat = br.getBits(8);
+            }
+        }
+
+        if (br.getBits(1)) { // load_non_intra_quant_matrix
+            unsigned NonIntraQuantMat = 1;
+            for (int i = 0; i < 64 && NonIntraQuantMat; i++) {
+                 NonIntraQuantMat = br.getBits(8);
+            }
+        }
+    } /* quantType */
+
+    if (videoObjectLayerVerid != 1) {
+        unsigned quarterSample = br.getBits(1);
+        ALOGV("checkDPFromVOLHeader: quarterSample:%u",
+                quarterSample);
+    }
+
+    br.skipBits(1); // complexity_estimation_disable
+    br.skipBits(1); // resync_marker_disable
+    unsigned dataPartitioned = br.getBits(1);
+    if (dataPartitioned) {
+        retVal = true;
+    }
+
+    ALOGD("checkDPFromVOLHeader: DP:%u", dataPartitioned);
+    return retVal;
+}
+
+bool ExtendedUtils::RTSPStream::ParseURL_V6(
+        AString *host, const char **colonPos) {
+
+    ssize_t bracketEnd = host->find("]");
+    ALOGI("ExtendedUtils::ParseURL_V6() : host->c_str() = %s", host->c_str());
+
+    if (bracketEnd <= 0) {
+        return false;
+    }
+
+    // If there is a port present, leave it for parsing in ParseURL
+    // otherwise, remove all trailing characters in the hostname
+    size_t trailing = host->size() - bracketEnd;
+    if (host->find(":", bracketEnd) == bracketEnd + 1) {
+        // 2 characters must be subtracted to account for the removal of
+        // the starting and ending brackets below --> bracketEnd + 1 - 2
+        *colonPos = host->c_str() + bracketEnd - 1;
+        trailing = 1;
+    }
+
+    host->erase(bracketEnd, trailing);
+    host->erase(0, 1);
+
+    return true;
+}
+
+void ExtendedUtils::RTSPStream::MakePortPair_V6(
+        int *rtpSocket, int *rtcpSocket, unsigned *rtpPort) {
+
+    struct addrinfo hints, *result = NULL;
+
+    ALOGV("ExtendedUtils::RTSPStream::MakePortPair_V6()");
+
+    *rtpSocket = socket(AF_INET6, SOCK_DGRAM, 0);
+    CHECK_GE(*rtpSocket, 0);
+    bumpSocketBufferSize_V6(*rtpSocket);
+
+    *rtcpSocket = socket(AF_INET6, SOCK_DGRAM, 0);
+    CHECK_GE(*rtcpSocket, 0);
+
+    bumpSocketBufferSize_V6(*rtcpSocket);
+
+    /* rand() * 1000 may overflow int type, use long long */
+    unsigned start = (unsigned)((rand()* 1000ll)/RAND_MAX) + 15550;
+    start &= ~1;
+
+     for (unsigned port = start; port < 65536; port += 2) {
+         struct sockaddr_in6 addr;
+         addr.sin6_family = AF_INET6;
+         addr.sin6_addr = in6addr_any;
+         addr.sin6_port = htons(port);
+
+         if (bind(*rtpSocket,
+                  (const struct sockaddr *)&addr, sizeof(addr)) < 0) {
+             continue;
+         }
+
+         addr.sin6_port = htons(port + 1);
+
+         if (bind(*rtcpSocket,
+                  (const struct sockaddr *)&addr, sizeof(addr)) == 0) {
+             *rtpPort = port;
+             ALOGV("END MakePortPair_V6: %u", port);
+             return;
+         }
+    }
+    TRESPASS();
+}
+
+void ExtendedUtils::RTSPStream::bumpSocketBufferSize_V6(int s) {
+    int size = 256 * 1024;
+    CHECK_EQ(setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &size, sizeof(size)), 0);
+}
+
+bool ExtendedUtils::RTSPStream::pokeAHole_V6(int rtpSocket, int rtcpSocket,
+                const AString &transport, AString &sessionHost) {
+    struct sockaddr_in addr;
+    memset(addr.sin_zero, 0, sizeof(addr.sin_zero));
+    addr.sin_family = AF_INET6;
+
+    struct addrinfo hints, *result = NULL;
+    ALOGV("Inside ExtendedUtils::RTSPStream::pokeAHole_V6");
+    memset(&hints, 0, sizeof (hints));
+    hints.ai_family = PF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+    hints.ai_flags = AI_PASSIVE;
+
+    AString source;
+    AString server_port;
+
+    Vector<struct sockaddr_in> s_addrs;
+    if (GetAttribute(transport.c_str(), "source", &source)) {
+        ALOGI("found 'source' = %s field in Transport response",
+            source.c_str());
+        int err = getaddrinfo(source.c_str(), NULL, &hints, &result);
+        if (err != 0 || result == NULL) {
+            ALOGI("no need to poke the hole");
+        } else {
+            s_addrs.push(*(struct sockaddr_in *)result->ai_addr);
+        }
+    }
+
+    int err = getaddrinfo(sessionHost.c_str(), NULL, &hints, &result);
+    if (err != 0 || result == NULL) {
+        ALOGE("Failed to look up address of session host '%s' err:%d(%s)",
+            sessionHost.c_str(), err, gai_strerror(err));
+
+        return false;
+     } else {
+        ALOGD("get the endpoint address of session host");
+        addr = (*(struct sockaddr_in *)result->ai_addr);
+
+        if (addr.sin_addr.s_addr == INADDR_NONE || IN_LOOPBACK(ntohl(addr.sin_addr.s_addr))) {
+            ALOGI("no need to poke the hole");
+        } else if (s_addrs.size() == 0 || s_addrs[0].sin_addr.s_addr != addr.sin_addr.s_addr) {
+            s_addrs.push(addr);
+        }
+    }
+
+    if (s_addrs.size() == 0){
+        ALOGW("Failed to get any session address");
+        return false;
+    }
+
+    if (!GetAttribute(transport.c_str(),
+                             "server_port",
+                             &server_port)) {
+        ALOGW("Missing 'server_port' field in Transport response.");
+        return false;
+    }
+
+    int rtpPort, rtcpPort;
+    if (sscanf(server_port.c_str(), "%d-%d", &rtpPort, &rtcpPort) != 2
+            || rtpPort <= 0 || rtpPort > 65535
+            || rtcpPort <=0 || rtcpPort > 65535
+            || rtcpPort != rtpPort + 1) {
+        ALOGE("Server picked invalid RTP/RTCP port pair %s,"
+             " RTP port must be even, RTCP port must be one higher.",
+             server_port.c_str());
+
+        return false;
+    }
+
+    if (rtpPort & 1) {
+        ALOGW("Server picked an odd RTP port, it should've picked an "
+             "even one, we'll let it pass for now, but this may break "
+             "in the future.");
+    }
+
+    // Make up an RR/SDES RTCP packet.
+    sp<ABuffer> buf = new ABuffer(65536);
+    buf->setRange(0, 0);
+    addRR(buf);
+    addSDES(rtpSocket, buf);
+
+    for (uint32_t i = 0; i < s_addrs.size(); i++){
+        addr.sin_addr.s_addr = s_addrs[i].sin_addr.s_addr;
+
+        addr.sin_port = htons(rtpPort);
+
+        ssize_t n = sendto(
+                rtpSocket, buf->data(), buf->size(), 0,
+                (const sockaddr *)&addr, sizeof(sockaddr_in6));
+
+        if (n < (ssize_t)buf->size()) {
+            ALOGE("failed to poke a hole for RTP packets");
+            continue;
+        }
+
+        addr.sin_port = htons(rtcpPort);
+
+        n = sendto(
+                rtcpSocket, buf->data(), buf->size(), 0,
+                (const sockaddr *)&addr, sizeof(sockaddr_in6));
+
+        if (n < (ssize_t)buf->size()) {
+            ALOGE("failed to poke a hole for RTCP packets");
+            continue;
+        }
+
+        ALOGV("successfully poked holes for the address = %u", s_addrs[i].sin_addr.s_addr);
+    }
+
+    return true;
+}
+
+bool ExtendedUtils::RTSPStream::GetAttribute(const char *s, const char *key, AString *value) {
+    value->clear();
+
+    size_t keyLen = strlen(key);
+
+    for (;;) {
+        while (isspace(*s)) {
+            ++s;
+        }
+
+        const char *colonPos = strchr(s, ';');
+
+        size_t len =
+            (colonPos == NULL) ? strlen(s) : colonPos - s;
+
+        if (len >= keyLen + 1 && s[keyLen] == '=' && !strncmp(s, key, keyLen)) {
+            value->setTo(&s[keyLen + 1], len - keyLen - 1);
+            return true;
+        }
+
+        if (colonPos == NULL) {
+            return false;
+        }
+
+        s = colonPos + 1;
+    }
+}
+
+void ExtendedUtils::RTSPStream::addRR(const sp<ABuffer> &buf) {
+    uint8_t *ptr = buf->data() + buf->size();
+    ptr[0] = 0x80 | 0;
+    ptr[1] = 201;  // RR
+    ptr[2] = 0;
+    ptr[3] = 1;
+    ptr[4] = 0xde;  // SSRC
+    ptr[5] = 0xad;
+    ptr[6] = 0xbe;
+    ptr[7] = 0xef;
+
+    buf->setRange(0, buf->size() + 8);
+}
+
+void ExtendedUtils::RTSPStream::addSDES(int s, const sp<ABuffer> &buffer) {
+    struct sockaddr_in addr;
+    socklen_t addrSize = sizeof(addr);
+    CHECK_EQ(0, getsockname(s, (sockaddr *)&addr, &addrSize));
+
+    uint8_t *data = buffer->data() + buffer->size();
+    data[0] = 0x80 | 1;
+    data[1] = 202;  // SDES
+    data[4] = 0xde;  // SSRC
+    data[5] = 0xad;
+    data[6] = 0xbe;
+    data[7] = 0xef;
+
+    size_t offset = 8;
+
+    data[offset++] = 1;  // CNAME
+
+    AString cname = "stagefright@";
+    cname.append(inet_ntoa(addr.sin_addr));
+    data[offset++] = cname.size();
+
+    memcpy(&data[offset], cname.c_str(), cname.size());
+    offset += cname.size();
+
+    data[offset++] = 6;  // TOOL
+
+    AString tool = MakeUserAgent();
+
+    data[offset++] = tool.size();
+
+    memcpy(&data[offset], tool.c_str(), tool.size());
+    offset += tool.size();
+
+    data[offset++] = 0;
+
+    if ((offset % 4) > 0) {
+        size_t count = 4 - (offset % 4);
+        switch (count) {
+            case 3:
+                data[offset++] = 0;
+            case 2:
+                data[offset++] = 0;
+            case 1:
+                data[offset++] = 0;
+        }
+    }
+
+    size_t numWords = (offset / 4) - 1;
+    data[2] = numWords >> 8;
+    data[3] = numWords & 0xff;
+
+    buffer->setRange(buffer->offset(), buffer->size() + offset);
+}
+
+bool ExtendedUtils::isPcmOffloadEnabled() {
+    bool prop_enabled = false;
+    char propValue[PROPERTY_VALUE_MAX];
+    if(property_get("audio.offload.pcm.16bit.enable", propValue, "false"))
+        prop_enabled = atoi(propValue) || !strncmp("true", propValue, 4);
+    if(property_get("audio.offload.pcm.24bit.enable", propValue, "false"))
+        prop_enabled = prop_enabled || atoi(propValue) || !strncmp("true", propValue, 4);
+    return prop_enabled;
+}
+
+//return true if mime type is not support for pcm offload
+//return true if PCM offload is not enabled
+bool ExtendedUtils::pcmOffloadException(const char* const mime) {
+    bool decision = false;
+
+    if (!isPcmOffloadEnabled())
+        return true;
+
+    if (!mime) {
+        ALOGV("%s: no audio mime present, ignoring pcm offload", __func__);
+        return true;
+    }
+
+    const char * const ExceptionTable[] = {
+        MEDIA_MIMETYPE_AUDIO_AMR_NB,
+        MEDIA_MIMETYPE_AUDIO_AMR_WB,
+        MEDIA_MIMETYPE_AUDIO_QCELP,
+        MEDIA_MIMETYPE_AUDIO_G711_ALAW,
+        MEDIA_MIMETYPE_AUDIO_G711_MLAW,
+        MEDIA_MIMETYPE_AUDIO_EVRC
+    };
+    int countException = (sizeof(ExceptionTable) / sizeof(ExceptionTable[0]));
+
+    for(int i = 0; i < countException; i++) {
+        if (!strcasecmp(mime, ExceptionTable[i])) {
+            decision = true;
+            break;
+        }
+    }
+    ALOGI("decision %d mime %s", decision, mime);
+    return decision;
+}
+
+sp<MetaData> ExtendedUtils::createPCMMetaFromSource(
+                const sp<MetaData> &sMeta)
+{
+    sp<MetaData> tPCMMeta = new MetaData;
+    //hard code as RAW
+    tPCMMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+
+    //TODO: remove this hard coding and use the meta info, but the issue
+    //is that decoder does not provide this info for now
+    tPCMMeta->setInt32(kKeyBitsPerSample, 16);
+
+    if (sMeta == NULL) {
+        ALOGW("no meta returning dummy meta");
+        return tPCMMeta;
+    }
+
+    int32_t srate = -1;
+    if (!sMeta->findInt32(kKeySampleRate, &srate)) {
+        ALOGV("No sample rate");
+    }
+    tPCMMeta->setInt32(kKeySampleRate, srate);
+
+    int32_t cmask = 0;
+    if (!sMeta->findInt32(kKeyChannelMask, &cmask) || (cmask == 0)) {
+        ALOGI("No channel mask, try channel count");
+    }
+    int32_t channelCount = 0;
+    if (!sMeta->findInt32(kKeyChannelCount, &channelCount)) {
+        ALOGI("No channel count either");
+    } else {
+        //if channel mask is not set till now, use channel count
+        //to retrieve channel count
+        if (!cmask) {
+            cmask = audio_channel_out_mask_from_count(channelCount);
+        }
+    }
+    tPCMMeta->setInt32(kKeyChannelCount, channelCount);
+    tPCMMeta->setInt32(kKeyChannelMask, cmask);
+
+    int64_t duration = INT_MAX;
+    if (!sMeta->findInt64(kKeyDuration, &duration)) {
+        ALOGW("No duration in meta setting max duration");
+    }
+    tPCMMeta->setInt64(kKeyDuration, duration);
+
+    int32_t bitRate = -1;
+    if (!sMeta->findInt32(kKeyBitRate, &bitRate)) {
+        ALOGW("No bitrate info");
+    } else {
+        tPCMMeta->setInt32(kKeyBitRate, bitRate);
+    }
+
+    return tPCMMeta;
+}
+
+void ExtendedUtils::overWriteAudioFormat(
+                sp<AMessage> &dst, const sp<AMessage> &src)
+{
+    int32_t dchannels = 0;
+    int32_t schannels = 0;
+    int32_t drate = 0;
+    int32_t srate = 0;
+    int32_t dmask = 0;
+    int32_t smask = 0;
+    int32_t scmask = 0;
+    int32_t dcmask = 0;
+
+    dst->findInt32("channel-count", &dchannels);
+    src->findInt32("channel-count", &schannels);
+
+    dst->findInt32("sample-rate", &drate);
+    src->findInt32("sample-rate", &srate);
+
+    dst->findInt32("channel-mask", &dmask);
+    src->findInt32("channel-mask", &smask);
+
+    ALOGI("channel count src: %d dst: %d", schannels, dchannels);
+    ALOGI("sample rate src: %d dst:%d ", srate, drate);
+
+    scmask = audio_channel_count_from_out_mask(smask);
+    dcmask = audio_channel_count_from_out_mask(dmask);
+    ALOGI("channel mask src: %d dst:%d ", smask, dmask);
+    ALOGI("channel count from mask src: %d dst:%d ", scmask, dcmask);
+
+    if (schannels && dchannels != schannels) {
+        dst->setInt32("channel-count", schannels);
+    }
+
+    if (srate && drate != srate) {
+        dst->setInt32("sample-rate", srate);
+    }
+
+    if (dmask != smask) {
+        dst->setInt32("channel-mask", smask);
+    }
+
+    return;
+}
+
+
+bool ExtendedUtils::is24bitPCMOffloaded(const sp<MetaData> &sMeta) {
+    bool decision = false;
+
+    if (sMeta == NULL) {
+        return decision;
+    }
+
+   /* Return true, if
+      1. 24 bit offload flag is enabled
+      2. the bit stream is raw 
+      3. this is a 24 bit PCM */
+
+    if (is24bitPCMOffloadEnabled() && isRAWFormat(sMeta) &&
+        getPcmSampleBits(sMeta) == 24) {
+        ALOGV("%s: decided its true for 24 bit PCM offloading", __func__);
+        decision = true;
+    }
+
+    return decision;
+}
+
+}
+#else //ENABLE_AV_ENHANCEMENTS
+
+namespace android {
+
+sp<MetaData> ExtendedUtils::updatePCMFormatAndBitwidth(
+                sp<MediaSource> &audioSource, bool offloadAudio)
+{
+    ARG_TOUCH(audioSource);
+    ARG_TOUCH(offloadAudio);
+    sp<MetaData> tempMetadata = new MetaData;
+    return tempMetadata;
+}
+
+void ExtendedUtils::HFR::setHFRIfEnabled(
+        const CameraParameters& params, sp<MetaData> &meta) {
+    ARG_TOUCH(params);
+    ARG_TOUCH(meta);
+}
+
+status_t ExtendedUtils::HFR::initializeHFR(
+        const sp<MetaData> &meta, sp<AMessage> &format,
+        int64_t &maxFileDurationUs, video_encoder videoEncoder) {
+    ARG_TOUCH(meta);
+    ARG_TOUCH(format);
+    ARG_TOUCH(maxFileDurationUs);
+    ARG_TOUCH(videoEncoder);
+    return OK;
+}
+
+void ExtendedUtils::HFR::setHFRRatio(
+        sp<MetaData> &meta, const int32_t hfrRatio) {
+    ARG_TOUCH(meta);
+    ARG_TOUCH(hfrRatio);
+}
+
+int32_t ExtendedUtils::HFR::getHFRRatio(
+        const sp<MetaData> &meta) {
+    ARG_TOUCH(meta);
+    return 1;
+}
+
+int32_t ExtendedUtils::HFR::getHFRCapabilities(
+        video_encoder codec,
+        int& maxHFRWidth, int& maxHFRHeight, int& maxHFRFps,
+        int& maxBitRate) {
+    ARG_TOUCH(codec);
+    maxHFRWidth = maxHFRHeight = maxHFRFps = maxBitRate = 0;
+    return -1;
+}
+
+sp<MetaData> ExtendedUtils::MakeHEVCCodecSpecificData(const sp<ABuffer> &accessUnit) {
+    ARG_TOUCH(accessUnit);
+    return NULL;
+}
+
+bool ExtendedUtils::IsHevcIDR(const sp<ABuffer> &buffer) {
+    ARG_TOUCH(buffer);
+    return false;
+}
+
+bool ExtendedUtils::ShellProp::isAudioDisabled(bool isEncoder) {
+    ARG_TOUCH(isEncoder);
+    return false;
+}
+
+bool ExtendedUtils::ShellProp::isVideoRenderingDisabled() {
+    return false;
+}
+
+void ExtendedUtils::ShellProp::setEncoderProfile(
+        video_encoder &videoEncoder, int32_t &videoEncoderProfile,
+        int32_t &videoEncoderLevel) {
+    ARG_TOUCH(videoEncoder);
+    ARG_TOUCH(videoEncoderProfile);
+    ARG_TOUCH(videoEncoderLevel);
+}
+
+int64_t ExtendedUtils::ShellProp::getMaxAVSyncLateMargin() {
+     return kDefaultAVSyncLateMargin;
+}
+
+bool ExtendedUtils::ShellProp::isSmoothStreamingEnabled() {
+    return false;
+}
+
+void ExtendedUtils::ShellProp::getRtpPortRange(unsigned *start, unsigned *end) {
+    *start = kDefaultRtpPortRangeStart;
+    *end = kDefaultRtpPortRangeEnd;
+}
+
+void ExtendedUtils::setBFrames(
+        OMX_VIDEO_PARAM_MPEG4TYPE &mpeg4type, const char* componentName) {
+    ARG_TOUCH(mpeg4type);
+    ARG_TOUCH(componentName);
+}
+
+void ExtendedUtils::setBFrames(
+        OMX_VIDEO_PARAM_AVCTYPE &h264type, const int32_t iFramesInterval,
+        const int32_t frameRate, const char* componentName) {
+    ARG_TOUCH(h264type);
+    ARG_TOUCH(iFramesInterval);
+    ARG_TOUCH(frameRate);
+    ARG_TOUCH(componentName);
+}
+
+bool ExtendedUtils::UseQCHWAACEncoder(audio_encoder Encoder,int32_t Channel,
+        int32_t BitRate,int32_t SampleRate) {
+    ARG_TOUCH(Encoder);
+    ARG_TOUCH(Channel);
+    ARG_TOUCH(BitRate);
+    ARG_TOUCH(SampleRate);
+    return false;
+}
+
+bool ExtendedUtils::is24bitPCMOffloadEnabled() {
+    return false;
+}
+
+bool ExtendedUtils::is16bitPCMOffloadEnabled() {
+    return false;
+}
+
+bool ExtendedUtils::isTrackOffloadEnabled() {
+    return false;
+}
+
+bool ExtendedUtils::isRAWFormat(const sp<MetaData> &meta) {
+    ARG_TOUCH(meta);
+    return false;
+}
+
+bool ExtendedUtils::isRAWFormat(const sp<AMessage> &format) {
+    ARG_TOUCH(format);
+    return false;
+}
+
+int32_t ExtendedUtils::getPcmSampleBits(const sp<MetaData> &meta) {
+    ARG_TOUCH(meta);
+    return 16;
+}
+
+int32_t ExtendedUtils::getPcmSampleBits(const sp<AMessage> &format) {
+    ARG_TOUCH(format);
+    return 16;
+}
+
+int32_t ExtendedUtils::getPCMFormat(const sp<MetaData> &meta) {
+    ARG_TOUCH(meta);
+    return false;
+}
+
+void ExtendedUtils::setKeyPCMFormat(const sp<MetaData> &meta, int32_t pcmFormat) {
+    ARG_TOUCH(meta);
+    ARG_TOUCH(pcmFormat);
+}
+
+sp<MediaExtractor> ExtendedUtils::MediaExtractor_CreateIfNeeded(
+        sp<MediaExtractor> defaultExt,
+        const sp<DataSource> &source,
+        const char *mime) {
+    ARG_TOUCH(defaultExt);
+    ARG_TOUCH(source);
+    ARG_TOUCH(mime);
+    return defaultExt;
+}
+
+bool ExtendedUtils::isAVCProfileSupported(int32_t  profile) {
+    ARG_TOUCH(profile);
+    return false;
+}
+
+void ExtendedUtils::updateNativeWindowBufferGeometry(ANativeWindow* anw,
+        OMX_U32 width, OMX_U32 height, OMX_COLOR_FORMATTYPE colorFormat) {
+    ARG_TOUCH(anw);
+    ARG_TOUCH(width);
+    ARG_TOUCH(height);
+    ARG_TOUCH(colorFormat);
+}
+
+bool ExtendedUtils::checkIsThumbNailMode(const uint32_t flags, char* componentName) {
+    ARG_TOUCH(flags);
+    ARG_TOUCH(componentName);
+    return false;
+}
+
+void ExtendedUtils::setArbitraryModeIfInterlaced(const uint8_t *ptr,
+        const sp<MetaData> &meta) {
+    ARG_TOUCH(ptr);
+    ARG_TOUCH(meta);
+}
+
+int32_t ExtendedUtils::checkIsInterlace(sp<MetaData> &meta) {
+    ARG_TOUCH(meta);
+    return 0;
+}
+
+void ExtendedUtils::HEVCMuxer::writeHEVCFtypBox(MPEG4Writer *writer) {
+    ARG_TOUCH(writer);
+}
+
+status_t ExtendedUtils::HEVCMuxer::makeHEVCCodecSpecificData(const uint8_t *data, size_t size,
+                                 void** codecSpecificData, size_t *codecSpecificDataSize) {
+    ARG_TOUCH(data);
+    ARG_TOUCH(size);
+    ARG_TOUCH(codecSpecificData);
+    *codecSpecificDataSize = 0;
+    return BAD_VALUE;
+}
+
+void ExtendedUtils::HEVCMuxer::beginHEVCBox(MPEG4Writer *writer) {
+    ARG_TOUCH(writer);
+}
+
+void ExtendedUtils::HEVCMuxer::writeHvccBox(MPEG4Writer *writer, void* codecSpecificData,
+                  size_t codecSpecificDataSize, bool useNalLengthFour) {
+    ARG_TOUCH(writer);
+    ARG_TOUCH(codecSpecificData);
+    ARG_TOUCH(codecSpecificDataSize);
+    ARG_TOUCH(useNalLengthFour);
+}
+
+bool ExtendedUtils::HEVCMuxer::isVideoHEVC(const char* mime) {
+    ARG_TOUCH(mime);
+    return false;
+}
+
+bool ExtendedUtils::HEVCMuxer::getHEVCCodecConfigData(const sp<MetaData> &meta,
+                  const void **data, size_t *size) {
+    ARG_TOUCH(meta);
+    ARG_TOUCH(data);
+    ARG_TOUCH(size);
+    *size = 0;
+    return false;
+}
+
+void ExtendedUtils::applyPreRotation(
+        const CameraParameters&, sp<MetaData>&) {}
+
+void ExtendedUtils::updateVideoTrackInfoFromESDS_MPEG4Video(sp<MetaData> meta) {
+    ARG_TOUCH(meta);
+}
+
+bool ExtendedUtils::checkDPFromCodecSpecificData(const uint8_t *data, size_t size) {
+    ARG_TOUCH(data);
+    ARG_TOUCH(size);
+    return false;
+}
+
+bool ExtendedUtils::checkDPFromVOLHeader(const uint8_t *data, size_t size) {
+    ARG_TOUCH(data);
+    ARG_TOUCH(size);
+    return false;
+}
+
+bool ExtendedUtils::RTSPStream::ParseURL_V6(
+        AString *host, const char **colonPos) {
+    return false;
+}
+
+void ExtendedUtils::RTSPStream::MakePortPair_V6(
+        int *rtpSocket, int *rtcpSocket, unsigned *rtpPort){}
+
+bool ExtendedUtils::RTSPStream::pokeAHole_V6(int rtpSocket, int rtcpSocket,
+        const AString &transport, AString &sessionHost) {
+    return false;
+}
+
+void ExtendedUtils::RTSPStream::bumpSocketBufferSize_V6(int s) {}
+
+bool ExtendedUtils::RTSPStream::GetAttribute(const char *s, const char *key, AString *value) {
+    return false;
+}
+
+void ExtendedUtils::RTSPStream::addRR(const sp<ABuffer> &buf) {}
+
+void ExtendedUtils::RTSPStream::addSDES(int s, const sp<ABuffer> &buffer) {}
+
+bool ExtendedUtils::isPcmOffloadEnabled() {
+    return false;
+}
+
+//return true to make sure pcm offload is not exercised
+bool ExtendedUtils::pcmOffloadException(const char* const mime) {
+    ARG_TOUCH(mime);
+    return true;
+}
+
+sp<MetaData> ExtendedUtils::createPCMMetaFromSource(
+                const sp<MetaData> &sMeta) {
+    ARG_TOUCH(sMeta);
+    sp<MetaData> tPCMMeta = new MetaData;
+    return tPCMMeta;
+}
+
+void ExtendedUtils::overWriteAudioFormat(
+                sp<AMessage> &dst, const sp<AMessage> &src)
+{
+    ARG_TOUCH(dst);
+    ARG_TOUCH(src);
+    return;
+}
+
+bool ExtendedUtils::is24bitPCMOffloaded(const sp<MetaData> &sMeta) {
+    ARG_TOUCH(sMeta);
+
+    return false;
+}
+
+} // namespace android
+#endif //ENABLE_AV_ENHANCEMENTS
+
+// Methods with identical implementation with & without ENABLE_AV_ENHANCEMENTS
+namespace android {
+
+bool ExtendedUtils::isVideoMuxFormatSupported(const char *mime) {
+    if (mime == NULL) {
+        ALOGE("NULL video mime type");
+        return false;
+    }
+
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)
+            || !strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)
+            || !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)
+            || !strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
+        return true;
+    }
+
+    return false;
+}
+
+void ExtendedUtils::printFileName(int fd) {
+    if (fd) {
+        char prop[PROPERTY_VALUE_MAX];
+        if (property_get("media.stagefright.log-uri", prop, "false") &&
+                (!strcmp(prop, "1") || !strcmp(prop, "true"))) {
+
+            char symName[40] = {0};
+            char fileName[256] = {0};
+            snprintf(symName, sizeof(symName), "/proc/%d/fd/%d", getpid(), fd);
+
+            if (readlink( symName, fileName, (sizeof(fileName) - 1)) != -1 ) {
+                ALOGI("printFileName fd(%d) -> %s", fd, fileName);
+            }
+        }
+    }
+}
+
+bool ExtendedUtils::isAudioAMR(const char* mime) {
+    if (mime && (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB, mime)
+            || !strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB, mime))) {
+        return true;
+    }
+
+    return false;
+}
+
+}
diff --git a/media/libstagefright/ExtendedWriter.cpp b/media/libstagefright/ExtendedWriter.cpp
new file mode 100644
index 0000000..a0a0466
--- /dev/null
+++ b/media/libstagefright/ExtendedWriter.cpp
@@ -0,0 +1,402 @@
+/*
+* Copyright (c) 2014, The Linux Foundation. All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are
+* met:
+*     * Redistributions of source code must retain the above copyright
+*       notice, this list of conditions and the following disclaimer.
+*     * Redistributions in binary form must reproduce the above
+*       copyright notice, this list of conditions and the following
+*       disclaimer in the documentation and/or other materials provided
+*       with the distribution.
+*     * Neither the name of The Linux Foundation nor the names of its
+*       contributors may be used to endorse or promote products derived
+*       from this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*/
+
+#include <media/stagefright/ExtendedWriter.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/mediarecorder.h>
+#include <system/audio.h>
+
+#include <sys/prctl.h>
+#include <sys/resource.h>
+
+#include <arpa/inet.h>
+#include <QCMediaDefs.h>
+
+#undef LOG_TAG
+#define LOG_TAG "ExtendedWriter"
+
+namespace android {
+
+ExtendedWriter::ExtendedWriter(const char *filename)
+    : mFile(fopen(filename, "wb")),
+      mInitCheck(mFile != NULL ? OK : NO_INIT),
+      mStarted(false),
+      mPaused(false),
+      mResumed(false),
+      mOffset(0) {
+}
+
+ExtendedWriter::ExtendedWriter(int fd)
+    : mFile(fdopen(fd, "wb")),
+      mInitCheck(mFile != NULL ? OK : NO_INIT),
+      mStarted(false),
+      mPaused(false),
+      mResumed(false),
+      mOffset(0) {
+}
+
+ExtendedWriter::~ExtendedWriter() {
+    if (mStarted) {
+        stop();
+    }
+
+    if (mFile != NULL) {
+        fclose(mFile);
+        mFile = NULL;
+    }
+}
+
+status_t ExtendedWriter::initCheck() const {
+    return mInitCheck;
+}
+
+status_t ExtendedWriter::addSource(const sp<MediaSource> &source) {
+    if (mInitCheck != OK) {
+        ALOGE("Init Check not OK, return");
+        return mInitCheck;
+    }
+
+    if (mSource != NULL) {
+        ALOGE("A source already exists, return");
+        return UNKNOWN_ERROR;
+    }
+
+    sp<MetaData> meta = source->getFormat();
+
+    const char *mime;
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+
+    if ( !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_QCELP)) {
+        mFormat = AUDIO_FORMAT_QCELP;
+    } else if ( !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EVRC)) {
+        mFormat = AUDIO_FORMAT_EVRC;
+    }
+    else {
+        return UNKNOWN_ERROR;
+    }
+
+    int32_t channelCount;
+    int32_t sampleRate;
+    CHECK(meta->findInt32(kKeyChannelCount, &channelCount));
+    CHECK_EQ(channelCount, 1);
+    CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+    CHECK_EQ(sampleRate, 8000);
+
+    mSource = source;
+
+    return OK;
+}
+
+status_t ExtendedWriter::start(MetaData *params) {
+    if (mInitCheck != OK) {
+        ALOGE("Init Check not OK, return");
+        return mInitCheck;
+    }
+
+    if (mSource == NULL) {
+        ALOGE("NULL Source");
+        return UNKNOWN_ERROR;
+    }
+
+    if (mStarted && mPaused) {
+        mPaused = false;
+        mResumed = true;
+        return OK;
+    } else if (mStarted) {
+        ALOGE("Already startd, return");
+        return OK;
+    }
+
+    //space for header;
+    size_t headerSize = sizeof( struct QCPEVRCHeader );
+    uint8_t * header = (uint8_t *)malloc(headerSize);
+    memset( header, '?', headerSize);
+    fwrite( header, 1, headerSize, mFile );
+    mOffset += headerSize;
+    delete header;
+
+    status_t err = mSource->start();
+
+    if (err != OK) {
+        return err;
+    }
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    mReachedEOS = false;
+    mDone = false;
+
+    pthread_create(&mThread, &attr, ThreadWrapper, this);
+    pthread_attr_destroy(&attr);
+
+    mStarted = true;
+
+    return OK;
+}
+
+status_t ExtendedWriter::pause() {
+    if (!mStarted) {
+        return OK;
+    }
+    mPaused = true;
+    return OK;
+}
+
+status_t ExtendedWriter::stop() {
+    if (!mStarted) {
+        return OK;
+    }
+
+    mDone = true;
+
+    void *dummy;
+    pthread_join(mThread, &dummy);
+
+    status_t err = static_cast<status_t>(reinterpret_cast<uintptr_t>(dummy));
+    {
+        status_t status = mSource->stop();
+        if (err == OK &&
+            (status != OK && status != ERROR_END_OF_STREAM)) {
+            err = status;
+        }
+    }
+
+    mStarted = false;
+    return err;
+}
+
+bool ExtendedWriter::exceedsFileSizeLimit() {
+    if (mMaxFileSizeLimitBytes == 0) {
+        return false;
+    }
+    return mEstimatedSizeBytes >= mMaxFileSizeLimitBytes;
+}
+
+bool ExtendedWriter::exceedsFileDurationLimit() {
+    if (mMaxFileDurationLimitUs == 0) {
+        return false;
+    }
+    return mEstimatedDurationUs >= mMaxFileDurationLimitUs;
+}
+
+// static
+void *ExtendedWriter::ThreadWrapper(void *me) {
+    return (void *) (uintptr_t)static_cast<ExtendedWriter *>(me)->threadFunc();
+}
+
+status_t ExtendedWriter::threadFunc() {
+    mEstimatedDurationUs = 0;
+    mEstimatedSizeBytes = 0;
+    bool stoppedPrematurely = true;
+    int64_t previousPausedDurationUs = 0;
+    int64_t maxTimestampUs = 0;
+    status_t err = OK;
+
+    pid_t tid  = gettid();
+    androidSetThreadPriority(tid, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"ExtendedWriter", 0, 0, 0);
+    while (!mDone) {
+        MediaBuffer *buffer;
+        err = mSource->read(&buffer);
+
+        if (err != OK) {
+            break;
+        }
+
+        if (mPaused) {
+            buffer->release();
+            buffer = NULL;
+            continue;
+        }
+
+        mEstimatedSizeBytes += buffer->range_length();
+        if (exceedsFileSizeLimit()) {
+            buffer->release();
+            buffer = NULL;
+            notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0);
+            break;
+        }
+
+        int64_t timestampUs;
+        CHECK(buffer->meta_data()->findInt64(kKeyTime, &timestampUs));
+        if (timestampUs > mEstimatedDurationUs) {
+            mEstimatedDurationUs = timestampUs;
+        }
+        if (mResumed) {
+            previousPausedDurationUs += (timestampUs - maxTimestampUs - 20000);
+            mResumed = false;
+        }
+        timestampUs -= previousPausedDurationUs;
+        ALOGV("time stamp: %lld, previous paused duration: %lld",
+                timestampUs, previousPausedDurationUs);
+        if (timestampUs > maxTimestampUs) {
+            maxTimestampUs = timestampUs;
+        }
+
+        if (exceedsFileDurationLimit()) {
+            buffer->release();
+            buffer = NULL;
+            notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0);
+            break;
+        }
+        ssize_t n = fwrite(
+                (const uint8_t *)buffer->data() + buffer->range_offset(),
+                1,
+                buffer->range_length(),
+                mFile);
+        mOffset += n;
+
+        if (n < (ssize_t)buffer->range_length()) {
+            buffer->release();
+            buffer = NULL;
+
+            break;
+        }
+
+        // XXX: How to tell it is stopped prematurely?
+        if (stoppedPrematurely) {
+            stoppedPrematurely = false;
+        }
+
+        buffer->release();
+        buffer = NULL;
+    }
+
+    if (stoppedPrematurely) {
+        notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS, UNKNOWN_ERROR);
+    }
+
+    if ( mFormat == AUDIO_FORMAT_QCELP ) {
+        writeQCPHeader( );
+    }
+    else if ( mFormat == AUDIO_FORMAT_EVRC ) {
+        writeEVRCHeader( );
+    }
+
+    fflush(mFile);
+    fclose(mFile);
+    mFile = NULL;
+    mReachedEOS = true;
+    if (err == ERROR_END_OF_STREAM || (err == -ETIMEDOUT)) {
+        return OK;
+    }
+    return err;
+}
+
+bool ExtendedWriter::reachedEOS() {
+    return mReachedEOS;
+}
+
+status_t ExtendedWriter::writeQCPHeader() {
+    /* Common part */
+    struct QCPEVRCHeader header = {
+        {'R', 'I', 'F', 'F'}, 0, {'Q', 'L', 'C', 'M'}, /* Riff */
+        {'f', 'm', 't', ' '}, 150, 1, 0, 0, 0, 0,{0}, 0, {0},0,0,160,8000,16,0,{0},{0},{0}, /* Fmt */
+        {'v','r','a','t'}, 0, 0, 0, /* Vrat */
+        {'d','a','t','a'},0 /* Data */
+    };
+
+    fseeko(mFile, 0, SEEK_SET);
+    header.s_riff = (mOffset - 8);
+    header.data1 = (0x5E7F6D41);
+    header.data2 = (0xB115);
+    header.data3 = (0x11D0);
+    header.data4[0] = 0xBA;
+    header.data4[1] = 0x91;
+    header.data4[2] = 0x00;
+    header.data4[3] = 0x80;
+    header.data4[4] = 0x5F;
+    header.data4[5] = 0xB4;
+    header.data4[6] = 0xB9;
+    header.data4[7] = 0x7E;
+    header.ver = (0x0002);
+    memcpy(header.name, "Qcelp 13K", 9);
+    header.abps = (13000);
+    header.bytes_per_pkt = (35);
+    header.vr_num_of_rates = 5;
+    header.vr_bytes_per_pkt[0] = (0x0422);
+    header.vr_bytes_per_pkt[1] = (0x0310);
+    header.vr_bytes_per_pkt[2] = (0x0207);
+    header.vr_bytes_per_pkt[3] = (0x0103);
+    header.s_vrat = (0x00000008);
+    header.v_rate = (0x00000001);
+    header.size_in_pkts = (mOffset - sizeof( struct QCPEVRCHeader ))/ header.bytes_per_pkt;
+    header.s_data = mOffset - sizeof( struct QCPEVRCHeader );
+    fwrite( &header, 1, sizeof( struct QCPEVRCHeader ), mFile );
+    return OK;
+}
+
+status_t ExtendedWriter::writeEVRCHeader() {
+    /* Common part */
+    struct QCPEVRCHeader header = {
+        {'R', 'I', 'F', 'F'}, 0, {'Q', 'L', 'C', 'M'}, /* Riff */
+        {'f', 'm', 't', ' '}, 150, 1, 0, 0, 0, 0,{0}, 0, {0},0,0,160,8000,16,0,{0},{0},{0}, /* Fmt */
+        {'v','r','a','t'}, 0, 0, 0, /* Vrat */
+        {'d','a','t','a'},0 /* Data */
+    };
+
+    fseeko(mFile, 0, SEEK_SET);
+    header.s_riff = (mOffset - 8);
+    header.data1 = (0xe689d48d);
+    header.data2 = (0x9076);
+    header.data3 = (0x46b5);
+    header.data4[0] = 0x91;
+    header.data4[1] = 0xef;
+    header.data4[2] = 0x73;
+    header.data4[3] = 0x6a;
+    header.data4[4] = 0x51;
+    header.data4[5] = 0x00;
+    header.data4[6] = 0xce;
+    header.data4[7] = 0xb4;
+    header.ver = (0x0001);
+    memcpy(header.name, "TIA IS-127 Enhanced Variable Rate Codec, Speech Service Option 3", 64);
+    header.abps = (9600);
+    header.bytes_per_pkt = (23);
+    header.vr_num_of_rates = 4;
+    header.vr_bytes_per_pkt[0] = (0x0416);
+    header.vr_bytes_per_pkt[1] = (0x030a);
+    header.vr_bytes_per_pkt[2] = (0x0200);
+    header.vr_bytes_per_pkt[3] = (0x0102);
+    header.s_vrat = (0x00000008);
+    header.v_rate = (0x00000001);
+    header.size_in_pkts = (mOffset - sizeof( struct QCPEVRCHeader )) / header.bytes_per_pkt;
+    header.s_data = mOffset - sizeof( struct QCPEVRCHeader );
+    fwrite( &header, 1, sizeof( struct QCPEVRCHeader ), mFile );
+    return OK;
+}
+
+
+}  // namespace android
diff --git a/media/libstagefright/FFMPEGSoftCodec.cpp b/media/libstagefright/FFMPEGSoftCodec.cpp
new file mode 100644
index 0000000..92139ef
--- /dev/null
+++ b/media/libstagefright/FFMPEGSoftCodec.cpp
@@ -0,0 +1,942 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "FFMPEGSoftCodec"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/foundation/ABitReader.h>
+
+#include <media/stagefright/FFMPEGSoftCodec.h>
+
+#include <media/stagefright/ExtendedCodec.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaCodecList.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/OMXCodec.h>
+#include <media/stagefright/Utils.h>
+
+#include <OMX_Component.h>
+#include <OMX_AudioExt.h>
+#include <OMX_IndexExt.h>
+
+#include <OMX_FFMPEG_Extn.h>
+
+namespace android {
+
+void FFMPEGSoftCodec::convertMessageToMetaData(
+    const sp<AMessage> &msg, sp<MetaData> &meta) {
+
+    int32_t blockAlign;
+    if (msg->findInt32("block-align", &blockAlign)) {
+        meta->setInt32(kKeyBlockAlign, blockAlign);
+    }
+
+    int32_t rvVersion;
+    if (msg->findInt32("rv-version", &rvVersion)) {
+        meta->setInt32(kKeyRVVersion, rvVersion);
+    }
+
+    int32_t wmvVersion;
+    if (msg->findInt32("wmv-version", &wmvVersion)) {
+        meta->setInt32(kKeyWMVVersion, wmvVersion);
+    }
+
+    int32_t bitrate;
+    if (msg->findInt32("bitrate", &bitrate)) {
+        meta->setInt32(kKeyBitRate, bitrate);
+    }
+
+    int32_t codedSampleBits;
+    if (msg->findInt32("coded-sample-bits", &codedSampleBits)) {
+        meta->setInt32(kKeyCodedSampleBits, codedSampleBits);
+    }
+}
+
+template<class T>
+static void InitOMXParams(T *params) {
+    params->nSize = sizeof(T);
+    params->nVersion.s.nVersionMajor = 1;
+    params->nVersion.s.nVersionMinor = 0;
+    params->nVersion.s.nRevision = 0;
+    params->nVersion.s.nStep = 0;
+}
+
+const char* FFMPEGSoftCodec::overrideComponentName(
+        uint32_t /*quirks*/, const sp<MetaData> &meta, const char *mime, bool isEncoder) {
+    const char* componentName = NULL;
+
+    int32_t wmvVersion = 0;
+    if (!strncasecmp(mime, MEDIA_MIMETYPE_VIDEO_WMV, strlen(MEDIA_MIMETYPE_VIDEO_WMV)) &&
+            meta->findInt32(kKeyWMVVersion, &wmvVersion)) {
+        ALOGD("Found WMV version key %d", wmvVersion);
+        if (wmvVersion == 1) {
+            ALOGD("Use FFMPEG for unsupported WMV track");
+            componentName = "OMX.ffmpeg.wmv.decoder";
+        }
+    }
+
+    int32_t encodeOptions = 0;
+    if (!isEncoder && !strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_WMA, strlen(MEDIA_MIMETYPE_AUDIO_WMA)) &&
+            !meta->findInt32(kKeyWMAEncodeOpt, &encodeOptions)) {
+        ALOGD("Use FFMPEG for unsupported WMA track");
+        componentName = "OMX.ffmpeg.wma.decoder";
+    }
+
+    // Google's decoder doesn't support MAIN profile
+    int32_t aacProfile = 0;
+    if (!isEncoder && !strncasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
+            meta->findInt32(kKeyAACAOT, &aacProfile)) {
+        if (aacProfile == OMX_AUDIO_AACObjectMain) {
+            ALOGD("Use FFMPEG for AAC MAIN profile");
+            componentName = "OMX.ffmpeg.aac.decoder";
+        }
+    }
+    
+    return componentName;
+}
+
+void FFMPEGSoftCodec::overrideComponentName(
+        uint32_t /*quirks*/, const sp<AMessage> &msg, AString* componentName, AString* mime, int32_t isEncoder) {
+
+    int32_t wmvVersion = 0;
+    if (!strncasecmp(mime->c_str(), MEDIA_MIMETYPE_VIDEO_WMV, strlen(MEDIA_MIMETYPE_VIDEO_WMV)) &&
+            msg->findInt32(ExtendedCodec::getMsgKey(kKeyWMVVersion), &wmvVersion)) {
+        ALOGD("Found WMV version key %d", wmvVersion);
+        if (wmvVersion == 1) {
+            ALOGD("Use FFMPEG for unsupported WMV track");
+            componentName->setTo("OMX.ffmpeg.wmv.decoder");
+        }
+    }
+
+    int32_t encodeOptions = 0;
+    if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_WMA, strlen(MEDIA_MIMETYPE_AUDIO_WMA)) &&
+            !msg->findInt32(ExtendedCodec::getMsgKey(kKeyWMAEncodeOpt), &encodeOptions)) {
+        ALOGD("Use FFMPEG for unsupported WMA track");
+        componentName->setTo("OMX.ffmpeg.wma.decoder");
+    }
+
+    // Google's decoder doesn't support MAIN profile
+    int32_t aacProfile = 0;
+    if (!isEncoder && !strncasecmp(mime->c_str(), MEDIA_MIMETYPE_AUDIO_AAC, strlen(MEDIA_MIMETYPE_AUDIO_AAC)) &&
+            msg->findInt32(ExtendedCodec::getMsgKey(kKeyAACAOT), &aacProfile)) {
+        if (aacProfile == OMX_AUDIO_AACObjectMain) {
+            ALOGD("Use FFMPEG for AAC MAIN profile");
+            componentName->setTo("OMX.ffmpeg.aac.decoder");
+        }
+    }
+}
+
+status_t FFMPEGSoftCodec::handleSupportedAudioFormats(int format, AString* mime) {
+    ALOGV("handleSupportedAudioFormats called for format:%x",format);
+    status_t retVal = OK;
+    if (format == OMX_AUDIO_CodingVORBIS ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_VORBIS;
+    } else if (format == OMX_AUDIO_CodingRA ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_RA;
+    } else if (format == OMX_AUDIO_CodingFLAC) {
+        *mime = MEDIA_MIMETYPE_AUDIO_FLAC;
+    } else if (format == OMX_AUDIO_CodingMP2) {
+        *mime = MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II;
+    } else if (format == OMX_AUDIO_CodingWMA ) {
+        *mime = MEDIA_MIMETYPE_AUDIO_WMA;
+    } else if (format == OMX_AUDIO_CodingAC3 || format == OMX_AUDIO_CodingAndroidAC3) {
+        *mime = MEDIA_MIMETYPE_AUDIO_AC3;
+    } else if (format == OMX_AUDIO_CodingAPE) {
+        *mime = MEDIA_MIMETYPE_AUDIO_APE;
+    } else if (format == OMX_AUDIO_CodingDTS) {
+        *mime = MEDIA_MIMETYPE_AUDIO_DTS;
+    } else if (format == OMX_AUDIO_CodingAutoDetect) {
+        *mime = MEDIA_MIMETYPE_AUDIO_FFMPEG;
+    } else {
+        retVal = BAD_VALUE;
+    }
+    return retVal;
+}
+
+status_t FFMPEGSoftCodec::handleSupportedVideoFormats(int format, AString* mime) {
+    ALOGV("handleSupportedVideoFormats called");
+    status_t retVal = OK;
+    if (format == OMX_VIDEO_CodingWMV) {
+        *mime = MEDIA_MIMETYPE_VIDEO_WMV;
+    } else if (format == OMX_VIDEO_CodingRV) {
+        *mime = MEDIA_MIMETYPE_VIDEO_RV;
+    } else if (format == OMX_VIDEO_CodingVC1) {
+        *mime = MEDIA_MIMETYPE_VIDEO_VC1;
+    } else if (format == OMX_VIDEO_CodingFLV1) {
+        *mime = MEDIA_MIMETYPE_VIDEO_FLV1;
+    } else if (format == OMX_VIDEO_CodingDIVX) {
+        *mime = MEDIA_MIMETYPE_VIDEO_DIVX;
+    } else if (format == OMX_VIDEO_CodingHEVC) {
+        *mime = MEDIA_MIMETYPE_VIDEO_HEVC;
+    } else if (format == OMX_VIDEO_CodingAutoDetect) {
+        *mime = MEDIA_MIMETYPE_VIDEO_FFMPEG;
+    } else {
+        retVal = BAD_VALUE;
+    }
+    return retVal;
+}
+
+status_t FFMPEGSoftCodec::setVideoFormat(
+        const sp<MetaData> &meta, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder,
+        OMX_VIDEO_CODINGTYPE *compressionFormat) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    return setVideoFormat(msg, mime, OMXhandle, nodeID, isEncoder, compressionFormat);
+}
+
+status_t FFMPEGSoftCodec::setVideoFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder,
+        OMX_VIDEO_CODINGTYPE *compressionFormat) {
+    status_t err = OK;
+
+    if (isEncoder) {
+        ALOGE("Encoding not supported");
+        err = BAD_VALUE;
+    
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)) {
+        err = setWMVFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setWMVFormat() failed (err = %d)", err);
+        } else {
+            *compressionFormat = OMX_VIDEO_CodingWMV;
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mime)) {
+        err = setRVFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setRVFormat() failed (err = %d)", err);
+        } else {
+            *compressionFormat = OMX_VIDEO_CodingRV;
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVC1;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FLV1, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingFLV1;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
+        *compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingHEVC;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FFMPEG, mime)) {
+        ALOGV("Setting the OMX_VIDEO_PARAM_FFMPEGTYPE params");
+        err = setFFmpegVideoFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setFFmpegVideoFormat() failed (err = %d)", err);
+        } else {
+            *compressionFormat = OMX_VIDEO_CodingAutoDetect;
+        }
+    } else {
+        err = BAD_VALUE;
+    }
+
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setAudioFormat(
+        const sp<MetaData> &meta, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    sp<AMessage> msg = new AMessage();
+    msg->clear();
+    convertMetaDataToMessage(meta, &msg);
+    return setAudioFormat(msg, mime, OMXhandle, nodeID, isEncoder);
+}
+
+status_t FFMPEGSoftCodec::setAudioFormat(
+        const sp<AMessage> &msg, const char* mime, sp<IOMX> OMXhandle,
+        IOMX::node_id nodeID, bool isEncoder ) {
+    ALOGV("setAudioFormat called");
+    status_t err = OK;
+
+    if (isEncoder) {
+        ALOGE("Encoding not supported");
+        err = BAD_VALUE;
+
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_WMA, mime))  {
+        err = setWMAFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setWMAFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_VORBIS, mime))  {
+        err = setVORBISFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setVORBISFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_RA, mime))  {
+        err = setRAFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setRAFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_FLAC, mime))  {
+        err = setFLACFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setFLACFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II, mime))  {
+        err = setMP2Format(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setMP2Format() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AC3, mime)) {
+        err = setAC3Format(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setAC3Format() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_APE, mime))  {
+        err = setAPEFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setAPEFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_DTS, mime))  {
+        err = setDTSFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setDTSFormat() failed (err = %d)", err);
+        }
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_FFMPEG, mime))  {
+        err = setFFmpegAudioFormat(msg, OMXhandle, nodeID);
+        if (err != OK) {
+            ALOGE("setFFmpegAudioFormat() failed (err = %d)", err);
+        }
+    }
+
+    ALOGV("setAudioFormat: %s", msg->debugString(0).c_str());
+
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setSupportedRole(
+        const sp<IOMX> &omx, IOMX::node_id node,
+        bool isEncoder, const char *mime) {
+
+    ALOGV("setSupportedRole Called %s", mime);
+
+    struct MimeToRole {
+        const char *mime;
+        const char *decoderRole;
+        const char *encoderRole;
+    };
+
+    static const MimeToRole kFFMPEGMimeToRole[] = {
+        { MEDIA_MIMETYPE_AUDIO_AAC,
+          "audio_decoder.aac", NULL },
+        { MEDIA_MIMETYPE_AUDIO_MPEG,
+          "audio_decoder.mp3", NULL },
+        { MEDIA_MIMETYPE_AUDIO_VORBIS,
+          "audio_decoder.vorbis", NULL },
+        { MEDIA_MIMETYPE_AUDIO_WMA,
+          "audio_decoder.wma", NULL },
+        { MEDIA_MIMETYPE_AUDIO_RA,
+          "audio_decoder.ra" , NULL },
+        { MEDIA_MIMETYPE_AUDIO_FLAC,
+          "audio_decoder.flac", NULL },
+        { MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II,
+          "audio_decoder.mp2", NULL },
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+          "audio_decoder.ac3", NULL },
+        { MEDIA_MIMETYPE_AUDIO_APE,
+          "audio_decoder.ape", NULL },
+        { MEDIA_MIMETYPE_AUDIO_DTS,
+          "audio_decoder.dts", NULL },
+        { MEDIA_MIMETYPE_VIDEO_MPEG2,
+          "video_decoder.mpeg2", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX4,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX311,
+          "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_VIDEO_WMV,
+          "video_decoder.wmv",  NULL },
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+          "video_decoder.vc1", NULL },
+        { MEDIA_MIMETYPE_VIDEO_RV,
+          "video_decoder.rv", NULL },
+        { MEDIA_MIMETYPE_VIDEO_FLV1,
+          "video_decoder.flv1", NULL },
+        { MEDIA_MIMETYPE_VIDEO_HEVC,
+          "video_decoder.hevc", NULL },
+        { MEDIA_MIMETYPE_AUDIO_FFMPEG,
+          "audio_decoder.trial", NULL },
+        { MEDIA_MIMETYPE_VIDEO_FFMPEG,
+          "video_decoder.trial", NULL },
+        };
+    static const size_t kNumMimeToRole =
+                     sizeof(kFFMPEGMimeToRole) / sizeof(kFFMPEGMimeToRole[0]);
+
+    size_t i;
+    for (i = 0; i < kNumMimeToRole; ++i) {
+        if (!strcasecmp(mime, kFFMPEGMimeToRole[i].mime)) {
+            break;
+        }
+    }
+
+    if (i == kNumMimeToRole) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    const char *role =
+        isEncoder ? kFFMPEGMimeToRole[i].encoderRole
+                  : kFFMPEGMimeToRole[i].decoderRole;
+
+    if (role != NULL) {
+        OMX_PARAM_COMPONENTROLETYPE roleParams;
+        InitOMXParams(&roleParams);
+
+        strncpy((char *)roleParams.cRole,
+                role, OMX_MAX_STRINGNAME_SIZE - 1);
+
+        roleParams.cRole[OMX_MAX_STRINGNAME_SIZE - 1] = '\0';
+
+        status_t err = omx->setParameter(
+                node, OMX_IndexParamStandardComponentRole,
+                &roleParams, sizeof(roleParams));
+
+        if (err != OK) {
+            ALOGW("Failed to set standard component role '%s'.", role);
+            return err;
+        }
+    }
+    return OK;
+}
+
+//video
+status_t FFMPEGSoftCodec::setWMVFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t version = -1;
+    OMX_VIDEO_PARAM_WMVTYPE paramWMV;
+
+    if (!msg->findInt32(ExtendedCodec::getMsgKey(kKeyWMVVersion), &version)) {
+        ALOGE("WMV version not detected");
+    }
+
+    InitOMXParams(&paramWMV);
+    paramWMV.nPortIndex = kPortIndexInput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamVideoWmv, &paramWMV, sizeof(paramWMV));
+    if (err != OK) {
+        return err;
+    }
+
+    if (version == kTypeWMVVer_7) {
+        paramWMV.eFormat = OMX_VIDEO_WMVFormat7;
+    } else if (version == kTypeWMVVer_8) {
+        paramWMV.eFormat = OMX_VIDEO_WMVFormat8;
+    } else if (version == kTypeWMVVer_9) {
+        paramWMV.eFormat = OMX_VIDEO_WMVFormat9;
+    }
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamVideoWmv, &paramWMV, sizeof(paramWMV));
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setRVFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t version = kTypeRVVer_G2;
+    OMX_VIDEO_PARAM_RVTYPE paramRV;
+
+    if (!msg->findInt32(ExtendedCodec::getMsgKey(kKeyRVVersion), &version)) {
+        ALOGE("RV version not detected");
+    }
+
+    InitOMXParams(&paramRV);
+    paramRV.nPortIndex = kPortIndexInput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamVideoRv, &paramRV, sizeof(paramRV));
+    if (err != OK)
+        return err;
+
+    if (version == kTypeRVVer_G2) {
+        paramRV.eFormat = OMX_VIDEO_RVFormatG2;
+    } else if (version == kTypeRVVer_8) {
+        paramRV.eFormat = OMX_VIDEO_RVFormat8;
+    } else if (version == kTypeRVVer_9) {
+        paramRV.eFormat = OMX_VIDEO_RVFormat9;
+    }
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamVideoRv, &paramRV, sizeof(paramRV));
+    return err;
+}
+
+status_t FFMPEGSoftCodec::setFFmpegVideoFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t codec_id = 0;
+    int32_t width = 0;
+    int32_t height = 0;
+    OMX_VIDEO_PARAM_FFMPEGTYPE param;
+
+    ALOGD("setFFmpegVideoFormat");
+
+    if (msg->findInt32(ExtendedCodec::getMsgKey(kKeyWidth), &width)) {
+        ALOGE("No video width specified");
+    }
+    if (msg->findInt32(ExtendedCodec::getMsgKey(kKeyHeight), &height)) {
+        ALOGE("No video height specified");
+    }
+    if (!msg->findInt32(ExtendedCodec::getMsgKey(kKeyCodecId), &codec_id)) {
+        ALOGE("No codec id sent for FFMPEG catch-all codec!");
+    }
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamVideoFFmpeg, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.eCodecId = codec_id;
+    param.nWidth   = width;
+    param.nHeight  = height;
+
+    err = OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamVideoFFmpeg, &param, sizeof(param));
+    return err;
+}
+
+//audio
+status_t FFMPEGSoftCodec::setRawAudioFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 0;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+    if (!msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitsPerSample), &bitsPerSample)) {
+        ALOGD("No PCM format specified, let decoder decide");
+    }
+
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+
+    status_t err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+    if (err != OK) {
+        return err;
+    }
+
+    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+    if (err != OK) {
+        return err;
+    }
+
+    OMX_AUDIO_PARAM_PCMMODETYPE pcmParams;
+    InitOMXParams(&pcmParams);
+    pcmParams.nPortIndex = kPortIndexOutput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioPcm, &pcmParams, sizeof(pcmParams));
+
+    if (err != OK) {
+        return err;
+    }
+
+    pcmParams.nChannels = numChannels;
+    pcmParams.eNumData = OMX_NumericalDataSigned;
+    pcmParams.bInterleaved = OMX_TRUE;
+    if (bitsPerSample > 0) {
+        pcmParams.nBitPerSample = bitsPerSample;
+    }
+    pcmParams.nSamplingRate = sampleRate;
+    pcmParams.ePCMMode = OMX_AUDIO_PCMModeLinear;
+
+    if (getOMXChannelMapping(numChannels, pcmParams.eChannelMapping) != OK) {
+        return OMX_ErrorNone;
+    }
+
+    err = OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioPcm, &pcmParams, sizeof(pcmParams));
+
+    if (err != OK) {
+        return err;
+    }
+
+    msg->setInt32("bits-per-sample", pcmParams.nBitPerSample);
+
+    return OK;
+}
+
+status_t FFMPEGSoftCodec::setWMAFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t version = 0;
+    int32_t numChannels = 0;
+    int32_t bitRate = 0;
+    int32_t sampleRate = 0;
+    int32_t blockAlign = 0;
+    int32_t formattag = 0;
+    int32_t bitsPerSample = 0;
+
+    OMX_AUDIO_PARAM_WMATYPE paramWMA;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitRate), &bitRate));
+    if (!msg->findInt32(ExtendedCodec::getMsgKey(kKeyBlockAlign), &blockAlign)) {
+        // we should be last on the codec list, but another sniffer may
+        // have handled it and there is no hardware codec.
+        if (!msg->findInt32(ExtendedCodec::getMsgKey(kKeyWMABlockAlign), &blockAlign)) {
+            return ERROR_UNSUPPORTED;
+        }
+    }
+
+    // mm-parser may want a different bit depth
+    if (msg->findInt32(ExtendedCodec::getMsgKey(kKeyWMABitspersample), &bitsPerSample)) {
+        msg->setInt32("bits-per-sample", bitsPerSample);
+    }
+
+    ALOGV("Channels: %d, SampleRate: %d, BitRate: %d, blockAlign: %d",
+            numChannels, sampleRate, bitRate, blockAlign);
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyWMAVersion), &version));
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&paramWMA);
+    paramWMA.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+    if (err != OK)
+        return err;
+
+    paramWMA.nChannels = numChannels;
+    paramWMA.nSamplingRate = sampleRate;
+    paramWMA.nBitRate = bitRate;
+    paramWMA.nBlockAlign = blockAlign;
+
+    // http://msdn.microsoft.com/en-us/library/ff819498(v=vs.85).aspx
+    if (version == kTypeWMA) {
+        paramWMA.eFormat = OMX_AUDIO_WMAFormat7;
+    } else if (version == kTypeWMAPro) {
+        paramWMA.eFormat = OMX_AUDIO_WMAFormat8;
+    } else if (version == kTypeWMALossLess) {
+        paramWMA.eFormat = OMX_AUDIO_WMAFormat9;
+    }
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+}
+
+status_t FFMPEGSoftCodec::setVORBISFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    OMX_AUDIO_PARAM_VORBISTYPE param;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioVorbis, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioVorbis, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setRAFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t bitRate = 0;
+    int32_t sampleRate = 0;
+    int32_t blockAlign = 0;
+    OMX_AUDIO_PARAM_RATYPE paramRA;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitRate), &bitRate);
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyBlockAlign), &blockAlign));
+
+    ALOGV("Channels: %d, SampleRate: %d, BitRate: %d, blockAlign: %d",
+            numChannels, sampleRate, bitRate, blockAlign);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&paramRA);
+    paramRA.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioRa, &paramRA, sizeof(paramRA));
+    if (err != OK)
+        return err;
+
+    paramRA.eFormat = OMX_AUDIO_RAFormatUnused; // FIXME, cook only???
+    paramRA.nChannels = numChannels;
+    paramRA.nSamplingRate = sampleRate;
+    // FIXME, HACK!!!, I use the nNumRegions parameter pass blockAlign!!!
+    // the cook audio codec need blockAlign!
+    paramRA.nNumRegions = blockAlign;
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioRa, &paramRA, sizeof(paramRA));
+}
+
+status_t FFMPEGSoftCodec::setFLACFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 0;
+    OMX_AUDIO_PARAM_FLACTYPE param;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitsPerSample), &bitsPerSample));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, OMX_IndexParamAudioFlac, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, OMX_IndexParamAudioFlac, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setMP2Format(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    OMX_AUDIO_PARAM_MP2TYPE param;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioMp2, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioMp2, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setAC3Format(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 0;
+    OMX_AUDIO_PARAM_ANDROID_AC3TYPE param;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc3, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSampleRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAc3, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setAPEFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 0;
+    OMX_AUDIO_PARAM_APETYPE param;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitsPerSample), &bitsPerSample));
+
+    ALOGV("Channels:%d, SampleRate:%d, bitsPerSample:%d",
+            numChannels, sampleRate, bitsPerSample);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioApe, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSamplingRate = sampleRate;
+    param.nBitsPerSample = bitsPerSample;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioApe, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setDTSFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t numChannels = 0;
+    int32_t sampleRate = 0;
+    int32_t bitsPerSample = 0;
+    OMX_AUDIO_PARAM_DTSTYPE param;
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate));
+
+    ALOGV("Channels: %d, SampleRate: %d",
+            numChannels, sampleRate);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioDts, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.nChannels = numChannels;
+    param.nSamplingRate = sampleRate;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioDts, &param, sizeof(param));
+}
+
+status_t FFMPEGSoftCodec::setFFmpegAudioFormat(
+        const sp<AMessage> &msg, sp<IOMX> OMXhandle, IOMX::node_id nodeID)
+{
+    int32_t codec_id = 0;
+    int32_t numChannels = 0;
+    int32_t bitRate = 0;
+    int32_t bitsPerSample = 16;
+    int32_t sampleRate = 0;
+    int32_t blockAlign = 0;
+    int32_t sampleFormat = 0;
+    int32_t codedSampleBits = 0;
+    OMX_AUDIO_PARAM_FFMPEGTYPE param;
+
+    ALOGD("setFFmpegAudioFormat");
+
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyCodecId), &codec_id));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeyChannelCount), &numChannels));
+    CHECK(msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleFormat), &sampleFormat));
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitRate), &bitRate);
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitsPerSample), &bitsPerSample);
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeySampleRate), &sampleRate);
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeyBlockAlign), &blockAlign);
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeyBitsPerSample), &bitsPerSample);
+    msg->findInt32(ExtendedCodec::getMsgKey(kKeyCodedSampleBits), &codedSampleBits);
+
+    status_t err = setRawAudioFormat(msg, OMXhandle, nodeID);
+    if (err != OK)
+        return err;
+
+    InitOMXParams(&param);
+    param.nPortIndex = kPortIndexInput;
+
+    err = OMXhandle->getParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioFFmpeg, &param, sizeof(param));
+    if (err != OK)
+        return err;
+
+    param.eCodecId       = codec_id;
+    param.nChannels      = numChannels;
+    param.nBitRate       = bitRate;
+    param.nBitsPerSample = codedSampleBits;
+    param.nSampleRate    = sampleRate;
+    param.nBlockAlign    = blockAlign;
+    param.eSampleFormat  = sampleFormat;
+
+    return OMXhandle->setParameter(
+            nodeID, (OMX_INDEXTYPE)OMX_IndexParamAudioFFmpeg, &param, sizeof(param));
+}
+
+}
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 9f20b1d..91d9db5 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -2800,8 +2800,10 @@ void MPEG4Writer::Track::writeMp4aEsdsBox() {
 
     mOwner->writeInt16(0x03);  // XXX
     mOwner->writeInt8(0x00);   // buffer size 24-bit
-    mOwner->writeInt32(96000); // max bit rate
-    mOwner->writeInt32(96000); // avg bit rate
+    int32_t bitRate;
+    bool success = mMeta->findInt32(kKeyBitRate, &bitRate);
+    mOwner->writeInt32(success ? bitRate : 96000); // max bit rate
+    mOwner->writeInt32(success ? bitRate : 96000); // avg bit rate
 
     mOwner->writeInt8(0x05);   // DecoderSpecificInfoTag
     mOwner->writeInt8(mCodecSpecificDataSize);
diff --git a/media/libstagefright/MediaBufferGroup.cpp b/media/libstagefright/MediaBufferGroup.cpp
index 6ac6d4a..284a413 100644
--- a/media/libstagefright/MediaBufferGroup.cpp
+++ b/media/libstagefright/MediaBufferGroup.cpp
@@ -41,6 +41,11 @@ MediaBufferGroup::~MediaBufferGroup() {
     }
 }
 
+extern "C" status_t _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferE(
+                    MediaBufferGroup* group, MediaBuffer **out) {
+    return group->acquire_buffer(out, false);
+}
+
 void MediaBufferGroup::add_buffer(MediaBuffer *buffer) {
     Mutex::Autolock autoLock(mLock);
 
diff --git a/media/libstagefright/MediaCodec.cpp b/media/libstagefright/MediaCodec.cpp
index a9c3a04..2c7d279 100644
--- a/media/libstagefright/MediaCodec.cpp
+++ b/media/libstagefright/MediaCodec.cpp
@@ -868,7 +868,8 @@ void MediaCodec::onMessageReceived(const sp<AMessage> &msg) {
 
                     CHECK(msg->findString("componentName", &mComponentName));
 
-                    if (mComponentName.startsWith("OMX.google.")) {
+                    if (mComponentName.startsWith("OMX.google.")
+                        || mComponentName.startsWith("OMX.ffmpeg.")) {
                         mFlags |= kFlagUsesSoftwareRenderer;
                     } else {
                         mFlags &= ~kFlagUsesSoftwareRenderer;
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index c5a6939..54ebb6c 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2014 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #include <media/stagefright/MediaDefs.h>
@@ -25,6 +44,7 @@ const char *MEDIA_MIMETYPE_VIDEO_VP9 = "video/x-vnd.on2.vp9";
 const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_HEVC = "video/hevc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
+const char *MEDIA_MIMETYPE_VIDEO_MPEG4_DP = "video/mp4v-esdp";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
@@ -61,5 +81,44 @@ const char *MEDIA_MIMETYPE_TEXT_3GPP = "text/3gpp-tt";
 const char *MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";
 const char *MEDIA_MIMETYPE_TEXT_VTT = "text/vtt";
 const char *MEDIA_MIMETYPE_TEXT_CEA_608 = "text/cea-608";
+#ifdef DOLBY_UDC
+const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC = "audio/eac3-joc";
+#endif // DOLBY_END
+
+const char *MEDIA_MIMETYPE_VIDEO_DIVX = "video/divx";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX311 = "video/divx311";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX4 = "video/divx4";
+const char *MEDIA_MIMETYPE_VIDEO_FLV1 = "video/x-flv";
+const char *MEDIA_MIMETYPE_VIDEO_MJPEG = "video/x-jpeg";
+const char *MEDIA_MIMETYPE_VIDEO_RV = "video/vnd.rn-realvideo";
+const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
+const char *MEDIA_MIMETYPE_VIDEO_WMV = "video/x-ms-wmv";
+const char *MEDIA_MIMETYPE_VIDEO_FFMPEG = "video/ffmpeg";
+
+const char *MEDIA_MIMETYPE_AUDIO_APE = "audio/x-ape";
+const char *MEDIA_MIMETYPE_AUDIO_DTS = "audio/vnd.dts";
+const char *MEDIA_MIMETYPE_AUDIO_PCM = "audio/x-pcm";
+const char *MEDIA_MIMETYPE_AUDIO_RA = "audio/vnd.rn-realaudio";
+const char *MEDIA_MIMETYPE_AUDIO_WMA = "audio/x-ms-wma";
+const char *MEDIA_MIMETYPE_AUDIO_FFMPEG = "audio/ffmpeg";
+
+const char *MEDIA_MIMETYPE_CONTAINER_APE = "audio/x-ape";
+const char *MEDIA_MIMETYPE_CONTAINER_ASF = "video/x-ms-asf";
+const char *MEDIA_MIMETYPE_CONTAINER_DIVX = "video/divx";
+const char *MEDIA_MIMETYPE_CONTAINER_DTS = "audio/vnd.dts";
+const char *MEDIA_MIMETYPE_CONTAINER_FLAC = "audio/flac";
+const char *MEDIA_MIMETYPE_CONTAINER_FLV = "video/x-flv";
+const char *MEDIA_MIMETYPE_CONTAINER_MOV = "video/quicktime";
+const char *MEDIA_MIMETYPE_CONTAINER_MP2 = "audio/mpeg2";
+const char *MEDIA_MIMETYPE_CONTAINER_MPG = "video/mpeg";
+const char *MEDIA_MIMETYPE_CONTAINER_RA = "audio/vnd.rn-realaudio";
+const char *MEDIA_MIMETYPE_CONTAINER_RM = "video/vnd.rn-realvideo";
+const char *MEDIA_MIMETYPE_CONTAINER_TS = "video/mp2t";
+const char *MEDIA_MIMETYPE_CONTAINER_WEBM = "video/webm";
+const char *MEDIA_MIMETYPE_CONTAINER_WMA = "audio/x-ms-wma";
+const char *MEDIA_MIMETYPE_CONTAINER_WMV = "video/x-ms-wmv";
+const char *MEDIA_MIMETYPE_CONTAINER_VC1 = "video/vc1";
+const char *MEDIA_MIMETYPE_CONTAINER_HEVC = "video/hevc";
+const char *MEDIA_MIMETYPE_CONTAINER_FFMPEG = "video/ffmpeg";
 
 }  // namespace android
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 9ab6611..b85b964 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -41,6 +41,8 @@
 
 namespace android {
 
+MediaExtractor::Plugin MediaExtractor::sPlugin;
+
 sp<MetaData> MediaExtractor::getMetaData() {
     return new MetaData;
 }
@@ -90,8 +92,14 @@ sp<MediaExtractor> MediaExtractor::Create(
         }
     }
 
+    AString extractorName;
     MediaExtractor *ret = NULL;
-    if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
+    if (meta.get() && meta->findString("extended-extractor-use", &extractorName)
+            && sPlugin.create) {
+        ALOGI("Use extended extractor for the special mime(%s) or codec", mime);
+        ret = sPlugin.create(source, mime, meta);
+    }
+    else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
             || !strcasecmp(mime, "audio/mp4")) {
         ret = new MPEG4Extractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
@@ -116,6 +124,8 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new AACExtractor(source, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {
         ret = new MPEG2PSExtractor(source);
+    } else if (!isDrm && sPlugin.create) {
+        ret = sPlugin.create(source, mime, meta);
     }
 
     if (ret != NULL) {
diff --git a/media/libstagefright/OMXClient.cpp b/media/libstagefright/OMXClient.cpp
index ca031aa..c57076b 100644
--- a/media/libstagefright/OMXClient.cpp
+++ b/media/libstagefright/OMXClient.cpp
@@ -180,7 +180,7 @@ bool MuxOMX::CanLiveLocally(const char *name) {
     return false;
 #else
     // 32 bit processes run only OMX.google.* components locally
-    return !strncasecmp(name, "OMX.google.", 11);
+    return !strncasecmp(name, "OMX.google.", 11) || !strncasecmp(name, "OMX.ffmpeg.", 11);
 #endif
 }
 
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 6cb0775..e56477a 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -45,6 +45,7 @@
 #include <media/stagefright/OMXCodec.h>
 #include <media/stagefright/Utils.h>
 #include <media/stagefright/SkipCutBuffer.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
 #include <utils/Vector.h>
 
 #include <OMX_AudioExt.h>
@@ -146,7 +147,9 @@ static void InitOMXParams(T *params) {
 }
 
 static bool IsSoftwareCodec(const char *componentName) {
-    if (!strncmp("OMX.google.", componentName, 11)) {
+    if (!strncmp("OMX.google.", componentName, 11)
+        || !strncmp("OMX.ffmpeg.", componentName, 11)
+        || !strncmp("OMX.PV.", componentName, 7)) {
         return true;
     }
 
@@ -641,6 +644,22 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
 
         setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+    } else {
+        if (mIsEncoder && !mIsVideo) {
+            int32_t numChannels, sampleRate;
+            CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
+            CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+            setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+        }
+        status_t err = OK;
+
+        if (!strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setAudioFormat(
+                    meta, mMIME, mOMX, mNode, mIsEncoder);
+        }
+        if (OK != err) {
+            return err;
+        }
     }
 
     if (!strncasecmp(mMIME, "video/", 6)) {
@@ -897,8 +916,16 @@ void OMXCodec::setVideoInputFormat(
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
     } else {
-        ALOGE("Not a supported video mime type: %s", mime);
-        CHECK(!"Should not be here. Not a supported video mime type.");
+        status_t err = ERROR_UNSUPPORTED;
+
+        if (err != OK && !strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    meta, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            ALOGE("Not a supported video mime type: %s", mime);
+            CHECK(!"Should not be here. Not a supported video mime type.");
+        }
     }
 
     OMX_COLOR_FORMATTYPE colorFormat;
@@ -1297,8 +1324,16 @@ status_t OMXCodec::setVideoOutputFormat(
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG2;
     } else {
-        ALOGE("Not a supported video mime type: %s", mime);
-        CHECK(!"Should not be here. Not a supported video mime type.");
+        status_t err = ERROR_UNSUPPORTED;
+
+        if(err != OK && !strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    meta, mMIME, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            ALOGE("Not a supported video mime type: %s", mime);
+            return err;
+        }
     }
 
     status_t err = setVideoPortFormatType(
@@ -1321,7 +1356,21 @@ status_t OMXCodec::setVideoOutputFormat(
         CHECK_EQ(err, (status_t)OK);
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+#if 0
+        CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
+               || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
+               || format.eColorFormat == OMX_COLOR_FormatCbYCrY
+               || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+               || format.eColorFormat == OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
+               );
+
+#endif
+
         int32_t colorFormat;
+        if (!strncmp("OMX.brcm.video.h264.hw.decoder", mComponentName, 30)) {
+            format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+        }
         if (meta->findInt32(kKeyColorFormat, &colorFormat)
                 && colorFormat != OMX_COLOR_FormatUnused
                 && colorFormat != format.eColorFormat) {
@@ -1331,9 +1380,14 @@ status_t OMXCodec::setVideoOutputFormat(
                 err = mOMX->getParameter(
                         mNode, OMX_IndexParamVideoPortFormat,
                             &format, sizeof(format));
+
                 if (format.eColorFormat == colorFormat) {
                     break;
                 }
+
+                if(err == 0x80001005){
+                    err = OMX_ErrorNoMore;
+                }
             }
             if (format.eColorFormat != colorFormat) {
                 CODEC_LOGE("Color format %d is not supported", colorFormat);
@@ -1364,7 +1418,7 @@ status_t OMXCodec::setVideoOutputFormat(
 
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
-    const size_t X = 64 * 1024;
+    const size_t X = 64 * 8 * 1024;
     if (def.nBufferSize < X) {
         def.nBufferSize = X;
     }
@@ -1441,7 +1495,8 @@ OMXCodec::OMXCodec(
       mLeftOverBuffer(NULL),
       mPaused(false),
       mNativeWindow(
-              (!strncmp(componentName, "OMX.google.", 11))
+              (!strncmp(componentName, "OMX.google.", 11)
+              || !strncmp(componentName, "OMX.ffmpeg.", 11))
                         ? NULL : nativeWindow) {
     mPortStatus[kPortIndexInput] = ENABLED;
     mPortStatus[kPortIndexOutput] = ENABLED;
@@ -1515,6 +1570,10 @@ void OMXCodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
+        status_t err = ERROR_UNSUPPORTED;
+        if (err != OK) {
+            err = FFMPEGSoftCodec::setSupportedRole(omx, node, isEncoder, mime);
+        }
         return;
     }
 
@@ -1650,9 +1709,9 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
             def.nBufferCountActual, def.nBufferSize,
             portIndex == kPortIndexInput ? "input" : "output");
 
-    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
-        return BAD_VALUE;
-    }
+    // if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
+    //     return BAD_VALUE;
+    // }
     size_t totalSize = def.nBufferCountActual * def.nBufferSize;
     mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
 
@@ -1824,11 +1883,31 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+    OMX_COLOR_FORMATTYPE HalColorFormat;
+    status_t errss;
+
+    switch (def.format.video.eColorFormat) {
+        case OMX_COLOR_FormatYCbYCr:
+            def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            errss = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            if (errss != OK){
+                // nothing here
+            }       
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        case OMX_COLOR_FormatYUV420Planar:
+            HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+        break;
+        default:
+            HalColorFormat = def.format.video.eColorFormat;
+        break;
+    }
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -3125,7 +3204,6 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
     size_t offset = 0;
     int32_t n = 0;
 
-
     for (;;) {
         MediaBuffer *srcBuffer;
         if (mSeekTimeUs >= 0) {
@@ -4353,7 +4431,25 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
             } else {
-                CHECK(!"Should not be here. Unknown audio encoding.");
+                AString mimeType;
+                status_t err = BAD_VALUE;
+                if (err != OK) {
+                    err = FFMPEGSoftCodec::handleSupportedAudioFormats(
+                            audio_def->eEncoding, &mimeType);
+                }
+                if (err == OK) {
+                    mOutputFormat->setCString(
+                            kKeyMIMEType, mimeType.c_str());
+                    int32_t numChannels, sampleRate, bitRate;
+                    inputFormat->findInt32(kKeyChannelCount, &numChannels);
+                    inputFormat->findInt32(kKeySampleRate, &sampleRate);
+                    inputFormat->findInt32(kKeyBitRate, &bitRate);
+                    mOutputFormat->setInt32(kKeyChannelCount, numChannels);
+                    mOutputFormat->setInt32(kKeySampleRate, sampleRate);
+                    mOutputFormat->setInt32(kKeyBitRate, bitRate);
+                } else {
+                    CHECK(!"Should not be here. Unknown audio encoding.");
+                }
             }
             break;
         }
@@ -4375,7 +4471,17 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
             } else {
-                CHECK(!"Unknown compression format.");
+                AString mimeType;
+                status_t err = BAD_VALUE;
+                if (err != OK) {
+                    err = FFMPEGSoftCodec::handleSupportedVideoFormats(
+                            video_def->eCompressionFormat, &mimeType);
+                }
+                if (err == OK) {
+                    mOutputFormat->setCString(kKeyMIMEType, mimeType.c_str());
+                } else {
+                    CHECK(!"Unknown compression format.");
+                }
             }
 
             mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
@@ -4556,7 +4662,11 @@ status_t QueryCodec(
                     caps->mColorFormats.push(flexibleEquivalent);
                 }
             }
-            caps->mColorFormats.push(portFormat.eColorFormat);
+            if(portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+                caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+            } else {
+                caps->mColorFormats.push(portFormat.eColorFormat);
+            }
         }
     }
 
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 214e2fc..bc132bf 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -34,6 +34,7 @@
 #include <hardware/audio.h>
 #include <media/stagefright/Utils.h>
 #include <media/AudioParameter.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
 
 namespace android {
 
@@ -635,6 +636,8 @@ void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {
 
     // XXX TODO add whatever other keys there are
 
+    FFMPEGSoftCodec::convertMessageToMetaData(msg, meta);
+
 #if 0
     ALOGI("converted %s to:", msg->debugString(0).c_str());
     meta->dumpToLog();
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f..9e0aaca 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -22,6 +22,11 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaErrors.h>
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+#include <sec_format.h>
+#endif
+
+
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -44,6 +49,7 @@ bool ColorConverter::isValid() const {
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+        case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -110,6 +116,10 @@ status_t ColorConverter::convert(
             err = convertCbYCrY(src, dst);
             break;
 
+        case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break; 
+ 
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
             break;
@@ -133,7 +143,7 @@ status_t ColorConverter::convert(
 }
 
 status_t ColorConverter::convertCbYCrY(
-        const BitmapParams &src, const BitmapParams &dst) {
+    const BitmapParams &src, const BitmapParams &dst) {
     // XXX Untested
 
     uint8_t *kAdjustedClip = initClip();
@@ -196,6 +206,71 @@ status_t ColorConverter::convertCbYCrY(
     return OK;
 }
 
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+    // XXX Untested
+    ALOGW("PATCH:ColorConverter:convertYCbYCr");
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+            signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
 status_t ColorConverter::convertYUV420Planar(
         const BitmapParams &src, const BitmapParams &dst) {
     if (!((src.mCropLeft & 1) == 0
diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 04467b9..7cd1bf6 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -132,11 +132,20 @@ void SoftwareRenderer::resetFormatIfChanged(const sp<AMessage> &format) {
     CHECK(mCropHeight > 0);
     CHECK(mConverter == NULL || mConverter->isValid());
 
+#ifdef EXYNOS4_ENHANCEMENTS
+    CHECK_EQ(0,
+            native_window_set_usage(
+            mNativeWindow.get(),
+            GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_OFTEN
+            | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP
+            | GRALLOC_USAGE_HW_FIMC1));
+#else
     CHECK_EQ(0,
             native_window_set_usage(
             mNativeWindow.get(),
             GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_OFTEN
             | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP));
+#endif
 
     CHECK_EQ(0,
             native_window_set_scaling_mode(
@@ -219,10 +228,19 @@ void SoftwareRenderer::render(
 
         uint8_t *dst_y = (uint8_t *)dst;
         size_t dst_y_size = buf->stride * buf->height;
+
+#ifdef EXYNOS4_ENHANCEMENTS
+        size_t dst_c_stride = buf->stride / 2;
+        size_t dst_c_size = dst_c_stride * buf->height / 2;
+        size_t dst_c_size_aligned = ALIGN(buf->stride / 2, 16) * buf->height / 2;
+        uint8_t *dst_v = dst_y + dst_y_size;
+        uint8_t *dst_u = dst_v + dst_c_size_aligned;
+#else
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
         size_t dst_c_size = dst_c_stride * buf->height / 2;
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
+#endif
 
         for (int y = 0; y < mCropHeight; ++y) {
             memcpy(dst_y, src_y, mCropWidth);
@@ -252,13 +270,25 @@ void SoftwareRenderer::render(
         const uint8_t *src_uv =
             (const uint8_t *)data + mWidth * (mHeight - mCropTop / 2);
 
-        uint8_t *dst_y = (uint8_t *)dst;
+#ifdef EXYNOS4_ENHANCEMENTS
+        void *pYUVBuf[3];
 
+        CHECK_EQ(0, mapper.unlock(buf->handle));
+        CHECK_EQ(0, mapper.lock(
+                buf->handle, GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_YUV_ADDR, bounds, pYUVBuf));
+
+        size_t dst_c_stride = buf->stride / 2;
+        uint8_t *dst_y = (uint8_t *)pYUVBuf[0];
+        uint8_t *dst_v = (uint8_t *)pYUVBuf[1];
+        uint8_t *dst_u = (uint8_t *)pYUVBuf[2];
+#else
         size_t dst_y_size = buf->stride * buf->height;
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
         size_t dst_c_size = dst_c_stride * buf->height / 2;
+        uint8_t *dst_y = (uint8_t *)dst;
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
+#endif
 
         for (int y = 0; y < mCropHeight; ++y) {
             memcpy(dst_y, src_y, mCropWidth);
diff --git a/media/libstagefright/include/ExtendedExtractor.h b/media/libstagefright/include/ExtendedExtractor.h
new file mode 100644
index 0000000..590674d
--- /dev/null
+++ b/media/libstagefright/include/ExtendedExtractor.h
@@ -0,0 +1,49 @@
+/*Copyright (c) 2012 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef EXTENDED_EXTRACTOR_
+#define EXTENDED_EXTRACTOR_
+
+#include <media/stagefright/DataSource.h>
+
+namespace android {
+
+class MediaExtractor;
+class ExtendedExtractor
+{
+public:
+    static MediaExtractor* Create (
+            const sp<DataSource> &source, const char *mime);
+    static bool Sniff (
+            const sp<DataSource> &source, String8 *mimeType,
+            float *confidence,sp<AMessage> *meta);
+};
+
+}  // namespace android
+
+#endif //EXTENDED_EXTRACTOR_
diff --git a/media/libstagefright/include/ExtendedUtils.h b/media/libstagefright/include/ExtendedUtils.h
new file mode 100644
index 0000000..75dc6b5
--- /dev/null
+++ b/media/libstagefright/include/ExtendedUtils.h
@@ -0,0 +1,277 @@
+/* Copyright (c) 2013 - 2014, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef EXTENDED_UTILS_H_
+#define EXTENDED_UTILS_H_
+
+#include <utils/StrongPointer.h>
+#include <media/Metadata.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/foundation/AString.h>
+#include <media/stagefright/MediaCodecList.h>
+#include <media/stagefright/MPEG4Writer.h>
+
+#include <media/MediaRecorderBase.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <camera/CameraParameters.h>
+#include <OMX_Video.h>
+#include <android/native_window.h>
+
+#define MIN_BITERATE_AAC 24000
+#define MAX_BITERATE_AAC 192000
+
+#define IPV4 4
+#define IPV6 6
+
+namespace android {
+
+/*
+ * This class is a placeholder for utility methods for
+ * QC specific changes
+ */
+struct ExtendedUtils {
+
+    /*
+     * This class is a placeholder for the set of methods used
+     * to enable HFR (High Frame Rate) Recording
+     *
+     * HFR is a slow-motion recording feature where framerate
+     * is increased at capture, but file is composed to play
+     * back at normal rate, giving a net result of slow-motion.
+     * If HFR factor = N
+     *   framerate (at capture and encoder) = N * actual value
+     *   bitrate = N * actual value
+     *      (as the encoder still gets actual timestamps)
+     *   timeStamps (at composition) = actual value
+     *   timeScale (at composition) = actual value / N
+     *      (when parser re-generates timestamps, they will be
+     *       up-scaled by factor N, which results in slow-motion)
+     *
+     * HSR is a high-framerate recording variant where timestamps
+     * are not meddled with, yielding a video mux'ed at captured
+     * fps
+     */
+    struct HFR {
+        // set kKeyHFR when 'video-hfr' paramater is enabled
+        // or set kKeyHSR when 'video-hsr' paramater is enabled
+        static void setHFRIfEnabled(
+                const CameraParameters& params, sp<MetaData> &meta);
+
+        // recalculate file-duration when HFR is enabled
+        static status_t initializeHFR(
+                const sp<MetaData> &meta, sp<AMessage> &format,
+                int64_t &maxFileDurationUs, video_encoder videoEncoder);
+
+        static void setHFRRatio(
+                sp<MetaData> &meta, const int32_t hfrRatio);
+
+        static int32_t getHFRRatio(
+                const sp<MetaData> &meta);
+
+        private:
+        // Query supported capabilities from target-specific profiles
+        static int32_t getHFRCapabilities(
+                video_encoder codec,
+                int& maxHFRWidth, int& maxHFRHeight, int& maxHFRFps,
+                int& maxBitrate);
+    };
+
+    /*
+     * This class is a placeholder for set of methods used
+     * to enable HEVC muxing
+     */
+
+    struct HEVCParamSet {
+        HEVCParamSet(uint16_t length, const uint8_t *data)
+               : mLength(length), mData(data) {}
+
+        uint16_t mLength;
+        const uint8_t *mData;
+    };
+
+    struct HEVCMuxer {
+        static void writeHEVCFtypBox(MPEG4Writer *writer);
+
+        static status_t makeHEVCCodecSpecificData(const uint8_t *data,
+                  size_t size, void** codecSpecificData,
+                  size_t *codecSpecificDataSize);
+
+        static void beginHEVCBox(MPEG4Writer *writer);
+
+        static void writeHvccBox(MPEG4Writer *writer,
+                  void* codecSpecificData, size_t codecSpecificDataSize,
+                  bool useNalLengthFour);
+
+        static bool isVideoHEVC(const char* mime);
+
+        static bool getHEVCCodecConfigData(const sp<MetaData> &meta,
+                  const void **data, size_t *size);
+
+        private:
+
+        static status_t extractNALRBSPData(const uint8_t *data, size_t size,
+                  uint8_t **header, bool *alreadyFilled);
+
+        static status_t parserProfileTierLevel(const uint8_t *data, size_t size,
+                  uint8_t **header, bool *alreadyFilled);
+
+        static const uint8_t *parseHEVCParamSet(const uint8_t *data, size_t length,
+                  List<HEVCParamSet> &paramSetList, size_t *paramSetLen);
+
+        static size_t parseHEVCCodecSpecificData(const uint8_t *data, size_t size,
+                  List<HEVCParamSet> &vidParamSet, List<HEVCParamSet> &seqParamSet,
+                  List<HEVCParamSet> &picParamSet );
+    };
+
+
+    /*
+     * This class is a placeholder for methods to override
+     * default heaviour based on shell properties set
+     */
+    struct ShellProp {
+        // check if shell property to disable audio is set
+        static bool isAudioDisabled(bool isEncoder);
+
+        //helper function to set encoding profiles
+        static void setEncoderProfile(video_encoder &videoEncoder,
+                int32_t &videoEncoderProfile, int32_t &videoEncoderLevel);
+
+        static bool isSmoothStreamingEnabled();
+
+        static int64_t getMaxAVSyncLateMargin();
+
+        //helper function to parse rtp port range form system property
+        static void getRtpPortRange(unsigned *start, unsigned *end);
+
+        static bool isVideoRenderingDisabled();
+    };
+
+    struct RTSPStream {
+
+        static bool ParseURL_V6(
+                AString *host, const char **colonPos);
+
+        // Creates a pair of UDP datagram sockets bound to adjacent ports
+        // (the rtpSocket is bound to an even port, the rtcpSocket to the
+        // next higher port) for IPV6.
+        static void MakePortPair_V6(
+                int *rtpSocket, int *rtcpSocket, unsigned *rtpPort);
+
+        // In case we're behind NAT, fire off two UDP packets to the remote
+        // rtp/rtcp ports to poke a hole into the firewall for future incoming
+        // packets. We're going to send an RR/SDES RTCP packet to both of them.
+        static bool pokeAHole_V6(int rtpSocket, int rtcpSocket,
+                 const AString &transport, AString &sessionHost);
+
+        private:
+
+        static void bumpSocketBufferSize_V6(int s);
+
+        static bool GetAttribute(const char *s, const char *key, AString *value);
+
+        static void addRR(const sp<ABuffer> &buf);
+
+        static void addSDES(int s, const sp<ABuffer> &buffer);
+
+    };
+
+
+    static const int32_t kNumBFramesPerPFrame = 1;
+    static bool mIsQCHWAACEncoder;
+
+    //set B frames for MPEG4
+    static void setBFrames(OMX_VIDEO_PARAM_MPEG4TYPE &mpeg4type,
+            const char* componentName);
+
+    //set B frames for H264
+    static void setBFrames(OMX_VIDEO_PARAM_AVCTYPE &h264type,
+            const int32_t iFramesInterval, const int32_t frameRate,
+            const char* componentName);
+
+    static bool UseQCHWAACEncoder(audio_encoder Encoder = AUDIO_ENCODER_DEFAULT, int32_t Channel = 0,
+            int32_t BitRate = 0, int32_t SampleRate = 0);
+
+    static bool is24bitPCMOffloadEnabled();
+    static bool is16bitPCMOffloadEnabled();
+    static bool isTrackOffloadEnabled();
+    static bool isRAWFormat(const sp<MetaData> &meta);
+    static bool isRAWFormat(const sp<AMessage> &format);
+    static int32_t getPcmSampleBits(const sp<MetaData> &meta);
+    static int32_t getPcmSampleBits(const sp<AMessage> &format);
+    static int32_t getPCMFormat(const sp<MetaData> &meta);
+    static void setKeyPCMFormat(const sp<MetaData> &meta, int32_t pcmFormat);
+
+    static sp<MediaExtractor> MediaExtractor_CreateIfNeeded(
+            sp<MediaExtractor> defaultExt, const sp<DataSource> &source,
+            const char *mime);
+
+    static bool isAVCProfileSupported(int32_t profile);
+
+    //notify stride change to ANW
+    static void updateNativeWindowBufferGeometry(ANativeWindow* anw,
+            OMX_U32 width, OMX_U32 height, OMX_COLOR_FORMATTYPE colorFormat);
+
+    static bool checkIsThumbNailMode(const uint32_t flags, char* componentName);
+    
+    static void setArbitraryModeIfInterlaced(const uint8_t *ptr, const sp<MetaData> &meta);
+
+    static int32_t checkIsInterlace(sp<MetaData> &meta);
+
+    static bool isVideoMuxFormatSupported(const char *mime);
+
+    static void printFileName(int fd);
+    static sp<MetaData> updatePCMFormatAndBitwidth(sp<MediaSource> &audioSource,
+                                            bool offloadAudio);
+    static void applyPreRotation(
+            const CameraParameters& params, sp<MetaData> &meta);
+
+    static bool isAudioAMR(const char* mime);
+
+    static void updateVideoTrackInfoFromESDS_MPEG4Video(sp<MetaData> meta);
+    static bool checkDPFromVOLHeader(const uint8_t *ptr, size_t size);
+    static bool checkDPFromCodecSpecificData(const uint8_t *ptr, size_t size);
+
+    static bool isPcmOffloadEnabled();
+
+    static bool pcmOffloadException(const char* const mime);
+
+    static sp<MetaData> createPCMMetaFromSource(
+            const sp<MetaData> &sMeta);
+
+    static void overWriteAudioFormat(
+                sp<AMessage> &dst, const sp<AMessage> &src);
+
+    static sp<MetaData> MakeHEVCCodecSpecificData(const sp<ABuffer> &accessUnit);
+    static bool IsHevcIDR(const sp<ABuffer> &accessUnit);
+	
+    static bool is24bitPCMOffloaded(
+                const sp<MetaData> &sMeta);
+};
+
+}
+#endif  //EXTENDED_UTILS_H_
diff --git a/media/libstagefright/omx/OMXMaster.cpp b/media/libstagefright/omx/OMXMaster.cpp
index ae3cb33..fc2e2b6 100644
--- a/media/libstagefright/omx/OMXMaster.cpp
+++ b/media/libstagefright/omx/OMXMaster.cpp
@@ -25,6 +25,7 @@
 #include <dlfcn.h>
 
 #include <media/stagefright/foundation/ADebug.h>
+#include <cutils/properties.h>
 
 namespace android {
 
@@ -32,6 +33,7 @@ OMXMaster::OMXMaster()
     : mVendorLibHandle(NULL) {
     addVendorPlugin();
     addPlugin(new SoftOMXPlugin);
+    addUserPlugin();
 }
 
 OMXMaster::~OMXMaster() {
@@ -47,6 +49,15 @@ void OMXMaster::addVendorPlugin() {
     addPlugin("libstagefrighthw.so");
 }
 
+void OMXMaster::addUserPlugin() {
+    char plugin[PROPERTY_VALUE_MAX];
+    if (property_get("media.sf.omx-plugin", plugin, NULL)) {
+        if (plugin != NULL) {
+            addPlugin(plugin);
+        }
+    }
+}
+
 void OMXMaster::addPlugin(const char *libname) {
     mVendorLibHandle = dlopen(libname, RTLD_NOW);
 
diff --git a/media/libstagefright/omx/OMXMaster.h b/media/libstagefright/omx/OMXMaster.h
index 6069741..b89232b 100644
--- a/media/libstagefright/omx/OMXMaster.h
+++ b/media/libstagefright/omx/OMXMaster.h
@@ -60,6 +60,7 @@ private:
     void addVendorPlugin();
     void addPlugin(const char *libname);
     void addPlugin(OMXPluginBase *plugin);
+    void addUserPlugin();
     void clearPlugins();
 
     OMXMaster(const OMXMaster &);
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index b4c9905..c1ae641 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -1996,6 +1996,13 @@ sp<AudioFlinger::RecordThread> AudioFlinger::openInput_l(audio_module_handle_t m
     audio_config_t halconfig = *config;
     audio_hw_device_t *inHwHal = inHwDev->hwDevice();
     audio_stream_in_t *inStream = NULL;
+
+#ifdef HAWAII_HWC
+    ALOGD("Forcing input to mono 48K on hawaii");
+    halconfig.channel_mask = AUDIO_CHANNEL_IN_MONO;
+    halconfig.sample_rate = 48000;
+#endif
+
     status_t status = inHwHal->open_input_stream(inHwHal, *input, device, &halconfig,
                                         &inStream, flags, address.string(), source);
     ALOGV("openInput_l() openInputStream returned input %p, SamplingRate %d"
