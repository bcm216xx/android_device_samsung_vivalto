diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba920..37d7807 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -67,6 +67,9 @@ private:
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
 
+	status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);		
+
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 85e98f1..270f7cf 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -40,6 +40,8 @@
 #include <media/stagefright/NativeWindowWrapper.h>
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
+#include <media/stagefright/ExtendedCodec.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
 
 #include <media/hardware/HardwareAPI.h>
 
@@ -48,8 +50,19 @@
 #include <OMX_Component.h>
 #include <OMX_IndexExt.h>
 
+#include "include/ExtendedUtils.h"
+
+#ifdef USE_SAMSUNG_COLORFORMAT
+#include <sec_format.h>
+#endif
+
 #include "include/avc_utils.h"
 
+#ifdef ENABLE_AV_ENHANCEMENTS
+#include <QCMediaDefs.h>
+#include <ExtendedUtils.h>
+#endif
+
 namespace android {
 
 // OMX errors are directly mapped into status_t range if
@@ -407,7 +420,6 @@ ACodec::ACodec()
       mSentFormat(false),
       mIsEncoder(false),
       mUseMetadataOnEncoderOutput(false),
-      mFatalError(false),
       mShutdownInProgress(false),
       mExplicitShutdown(false),
       mEncoderDelay(0),
@@ -469,6 +481,9 @@ void ACodec::initiateAllocateComponent(const sp<AMessage> &msg) {
 }
 
 void ACodec::initiateConfigureComponent(const sp<AMessage> &msg) {
+    if (mMediaExtendedStats == NULL)
+        msg->findObject(MEDIA_EXTENDED_STATS, (sp<RefBase>*)&mMediaExtendedStats);
+
     msg->setWhat(kWhatConfigureComponent);
     msg->setTarget(id());
     msg->post();
@@ -522,6 +537,14 @@ void ACodec::signalSubmitOutputMetaDataBufferIfEOS_workaround() {
 }
 
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
+    ATRACE_NAME(mComponentName.c_str());
+
+    bool isVideo = mComponentName.find("video") != -1;
+    const char* portType = portIndex == kPortIndexInput ?
+                                        STATS_PROFILE_ALLOCATE_INPUT(isVideo) :
+                                        STATS_PROFILE_ALLOCATE_OUTPUT(isVideo);
+    ExtendedStats::AutoProfile autoProfile(portType, mMediaExtendedStats);
+
     CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);
 
     CHECK(mDealer[portIndex] == NULL);
@@ -529,11 +552,11 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (mStoreMetaDataInOutputBuffers) {
-            err = allocateOutputMetaDataBuffers();
-        } else {
+        //if (mStoreMetaDataInOutputBuffers) {
+        //    err = allocateOutputMetaDataBuffers();
+       // } else {
             err = allocateOutputBuffersFromNativeWindow();
-        }
+       // }
     } else {
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
@@ -553,9 +576,7 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
             for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
                 sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
-                if (mem == NULL || mem->pointer() == NULL) {
-                    return NO_MEMORY;
-                }
+                CHECK(mem.get() != NULL);
 
                 BufferInfo info;
                 info.mStatus = BufferInfo::OWNED_BY_US;
@@ -631,11 +652,50 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         return err;
     }
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
+    setNativeWindowColorFormat(eNativeColorFormat);
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+    eNativeColorFormat);
+#elif defined(MTK_HARDWARE)
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
             def.format.video.eColorFormat);
+#else
+	
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	status_t omxresuilts;
+	
+	ALOGE("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGE("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i)", OMX_COLOR_FormatYCbYCr, OMX_COLOR_FormatYUV420Planar);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			omxresuilts = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			if (omxresuilts != OK) {
+				ALOGE("PATCH:ACodec:configureOutputBuffersFromNativeWindow setParameter(OMX_IndexParamPortDefinition) ERROR");
+			}
+			ALOGE("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", OMX_COLOR_FormatYCbYCr, OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;	
+		break;
+		default:
+			ALOGE("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: default(%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", def.format.video.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;	
+		break;
+	}
+
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+            def.format.video.nFrameWidth,
+            def.format.video.nFrameHeight,
+            HalColorFormat);
+#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -672,9 +732,8 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         // XXX: Currently this error is logged, but not fatal.
         usage = 0;
     }
-    int omxUsage = usage;
 
-    if (mFlags & kFlagIsGrallocUsageProtected) {
+    if (mFlags & (kFlagIsSecure | kFlagIsContentDrmProtected)) {
         usage |= GRALLOC_USAGE_PROTECTED;
     }
 
@@ -697,18 +756,6 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         }
     }
 
-    int consumerUsage = 0;
-    err = mNativeWindow->query(
-            mNativeWindow.get(), NATIVE_WINDOW_CONSUMER_USAGE_BITS,
-            &consumerUsage);
-    if (err != 0) {
-        ALOGW("failed to get consumer usage bits. ignoring");
-        err = 0;
-    }
-
-    ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec) + %#x(Consumer) = %#x",
-            omxUsage, usage, consumerUsage, usage | consumerUsage);
-    usage |= consumerUsage;
     err = native_window_set_usage(
             mNativeWindow.get(),
             usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
@@ -756,6 +803,12 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
     // 2. try to allocate two (2) additional buffers to reduce starvation from
     //    the consumer
     //    plus an extra buffer to account for incorrect minUndequeuedBufs
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    // Some devices don't like to set OMX_IndexParamPortDefinition at this
+    // point (even with an unmodified def), so skip it if possible.
+    // This check was present in KitKat.
+    if (def.nBufferCountActual < def.nBufferCountMin + *minUndequeuedBuffers) {
+#endif
     for (OMX_U32 extraBuffers = 2 + 1; /* condition inside loop */; extraBuffers--) {
         OMX_U32 newBufferCount =
             def.nBufferCountMin + *minUndequeuedBuffers + extraBuffers;
@@ -775,6 +828,9 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
             return err;
         }
     }
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    }
+#endif
 
     err = native_window_set_buffer_count(
             mNativeWindow.get(), def.nBufferCountActual);
@@ -882,9 +938,7 @@ status_t ACodec::allocateOutputMetaDataBuffers() {
 
         sp<IMemory> mem = mDealer[kPortIndexOutput]->allocate(
                 sizeof(struct VideoDecoderOutputMetaData));
-        if (mem == NULL || mem->pointer() == NULL) {
-            return NO_MEMORY;
-        }
+        CHECK(mem.get() != NULL);
         info.mData = new ABuffer(mem->pointer(), mem->size());
 
         // we use useBuffer for metadata regardless of quirks
@@ -921,6 +975,26 @@ status_t ACodec::submitOutputMetaDataBuffer() {
     return OK;
 }
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+void ACodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
+{
+    // In case of Samsung decoders, we set proper native color format for the Native Window
+    if (!strcasecmp(mComponentName.c_str(), "OMX.SEC.AVC.Decoder")
+        || !strcasecmp(mComponentName.c_str(), "OMX.SEC.FP.AVC.Decoder")
+        || !strcasecmp(mComponentName.c_str(), "OMX.Exynos.AVC.Decoder")) {
+        switch (eNativeColorFormat) {
+            case OMX_COLOR_FormatYUV420SemiPlanar:
+                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
+                break;
+            case OMX_COLOR_FormatYUV420Planar:
+            default:
+                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
+                break;
+        }
+    }
+}
+#endif
+
 status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
@@ -940,7 +1014,6 @@ status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
 
 ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
     ANativeWindowBuffer *buf;
-    int fenceFd = -1;
     CHECK(mNativeWindow.get() != NULL);
 
     if (mTunneled) {
@@ -949,11 +1022,6 @@ ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
         return NULL;
     }
 
-    if (mFatalError) {
-        ALOGW("not dequeuing from native window due to fatal error");
-        return NULL;
-    }
-
     if (native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf) != 0) {
         ALOGE("dequeueBuffer failed.");
         return NULL;
@@ -1097,6 +1165,20 @@ status_t ACodec::setComponentRole(
             "audio_decoder.amrnb", "audio_encoder.amrnb" },
         { MEDIA_MIMETYPE_AUDIO_AMR_WB,
             "audio_decoder.amrwb", "audio_encoder.amrwb" },
+#ifdef ENABLE_AV_ENHANCEMENTS
+        { MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS,
+            "audio_decoder.amrwbplus", "audio_encoder.amrwbplus" },
+        { MEDIA_MIMETYPE_AUDIO_EVRC,
+            "audio_decoder.evrchw", "audio_encoder.evrc" },
+        { MEDIA_MIMETYPE_AUDIO_QCELP,
+            "audio_decoder,qcelp13Hw", "audio_encoder.qcelp13" },
+#ifdef DOLBY_UDC
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+            "audio_decoder.ac3", NULL },
+        { MEDIA_MIMETYPE_AUDIO_EAC3,
+            "audio_decoder.ec3", NULL },
+#endif // DOLBY_END
+#endif
         { MEDIA_MIMETYPE_AUDIO_AAC,
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
@@ -1113,6 +1195,8 @@ status_t ACodec::setComponentRole(
             "video_decoder.hevc", "video_encoder.hevc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
+        { MEDIA_MIMETYPE_VIDEO_MPEG4_DP,
+            "video_decoder.mpeg4", NULL },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
         { MEDIA_MIMETYPE_VIDEO_VP8,
@@ -1121,16 +1205,19 @@ status_t ACodec::setComponentRole(
             "video_decoder.vp9", "video_encoder.vp9" },
         { MEDIA_MIMETYPE_AUDIO_RAW,
             "audio_decoder.raw", "audio_encoder.raw" },
+#ifdef QTI_FLAC_DECODER
+        { MEDIA_MIMETYPE_AUDIO_FLAC,
+            "audio_decoder.raw", NULL },
+#else
         { MEDIA_MIMETYPE_AUDIO_FLAC,
             "audio_decoder.flac", "audio_encoder.flac" },
+#endif
         { MEDIA_MIMETYPE_AUDIO_MSGSM,
             "audio_decoder.gsm", "audio_encoder.gsm" },
         { MEDIA_MIMETYPE_VIDEO_MPEG2,
             "video_decoder.mpeg2", "video_encoder.mpeg2" },
         { MEDIA_MIMETYPE_AUDIO_AC3,
             "audio_decoder.ac3", "audio_encoder.ac3" },
-        { MEDIA_MIMETYPE_AUDIO_EAC3,
-            "audio_decoder.eac3", "audio_encoder.eac3" },
     };
 
     static const size_t kNumMimeToRole =
@@ -1144,7 +1231,16 @@ status_t ACodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
-        return ERROR_UNSUPPORTED;
+        status_t err = BAD_VALUE;
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
+        }
+#endif
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
+        }
+        return err;
     }
 
     const char *role =
@@ -1177,13 +1273,18 @@ status_t ACodec::setComponentRole(
 
 status_t ACodec::configureCodec(
         const char *mime, const sp<AMessage> &msg) {
+    ATRACE_NAME("configureCodec");
     int32_t encoder;
     if (!msg->findInt32("encoder", &encoder)) {
         encoder = false;
     }
 
+    bool isVideo = mComponentName.find("video") != -1;
+    ExtendedStats::AutoProfile autoProfile(
+            STATS_PROFILE_CONFIGURE_CODEC(isVideo), mMediaExtendedStats);
+
     sp<AMessage> inputFormat = new AMessage();
-    sp<AMessage> outputFormat = mNotify->dup(); // will use this for kWhatOutputFormatChanged
+    sp<AMessage> outputFormat = new AMessage();
 
     mIsEncoder = encoder;
 
@@ -1281,47 +1382,18 @@ status_t ACodec::configureCodec(
         }
     }
 
-    // NOTE: we only use native window for video decoders
     sp<RefBase> obj;
-    bool haveNativeWindow = msg->findObject("native-window", &obj)
-            && obj != NULL && video && !encoder;
+    int32_t haveNativeWindow = msg->findObject("native-window", &obj) &&
+        obj != NULL;
     mStoreMetaDataInOutputBuffers = false;
     if (video && !encoder) {
         inputFormat->setInt32("adaptive-playback", false);
-
-        int32_t usageProtected;
-        if (msg->findInt32("protected", &usageProtected) && usageProtected) {
-            if (!haveNativeWindow) {
-                ALOGE("protected output buffers must be sent to an ANativeWindow");
-                return PERMISSION_DENIED;
             }
-            mFlags |= kFlagIsGrallocUsageProtected;
-            mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
-        }
-    }
-    if (haveNativeWindow) {
+    if (!encoder && video && haveNativeWindow) {
         sp<NativeWindowWrapper> windowWrapper(
                 static_cast<NativeWindowWrapper *>(obj.get()));
         sp<ANativeWindow> nativeWindow = windowWrapper->getNativeWindow();
 
-        // START of temporary support for automatic FRC - THIS WILL BE REMOVED
-        int32_t autoFrc;
-        if (msg->findInt32("auto-frc", &autoFrc)) {
-            bool enabled = autoFrc;
-            OMX_CONFIG_BOOLEANTYPE config;
-            InitOMXParams(&config);
-            config.bEnabled = (OMX_BOOL)enabled;
-            status_t temp = mOMX->setConfig(
-                    mNode, (OMX_INDEXTYPE)OMX_IndexConfigAutoFramerateConversion,
-                    &config, sizeof(config));
-            if (temp == OK) {
-                outputFormat->setInt32("auto-frc", enabled);
-            } else if (enabled) {
-                ALOGI("codec does not support requested auto-frc (err %d)", temp);
-            }
-        }
-        // END of temporary support for automatic FRC
-
         int32_t tunneled;
         if (msg->findInt32("feature-tunneled-playback", &tunneled) &&
             tunneled != 0) {
@@ -1339,43 +1411,26 @@ status_t ACodec::configureCodec(
                 return err;
             }
 
-            int32_t maxWidth = 0, maxHeight = 0;
-            if (msg->findInt32("max-width", &maxWidth) &&
-                    msg->findInt32("max-height", &maxHeight)) {
-
-                err = mOMX->prepareForAdaptivePlayback(
-                        mNode, kPortIndexOutput, OMX_TRUE, maxWidth, maxHeight);
-                if (err != OK) {
-                    ALOGW("[%s] prepareForAdaptivePlayback failed w/ err %d",
-                            mComponentName.c_str(), err);
-                    // allow failure
-                    err = OK;
-                } else {
-                    inputFormat->setInt32("max-width", maxWidth);
-                    inputFormat->setInt32("max-height", maxHeight);
                     inputFormat->setInt32("adaptive-playback", true);
-                }
-            }
         } else {
             ALOGV("Configuring CPU controlled video playback.");
             mTunneled = false;
 
-            // Explicity reset the sideband handle of the window for
-            // non-tunneled video in case the window was previously used
-            // for a tunneled video playback.
-            err = native_window_set_sideband_stream(nativeWindow.get(), NULL);
-            if (err != OK) {
-                ALOGE("set_sideband_stream(NULL) failed! (err %d).", err);
-                return err;
-            }
-
+            bool bAdaptivePlaybackMode = false;
+            int32_t preferAdaptive = 0;
+            if (msg->findInt32("prefer-adaptive-playback", &preferAdaptive)
+                    && preferAdaptive == 1) {
+                ALOGI("[%s] Adaptive playback preferred", mComponentName.c_str());
+            } else {
             // Always try to enable dynamic output buffers on native surface
             err = mOMX->storeMetaDataInBuffers(
                     mNode, kPortIndexOutput, OMX_TRUE);
             if (err != OK) {
                 ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
                         mComponentName.c_str(), err);
-
+                }
+            }
+            if (err != OK || preferAdaptive) {
                 // if adaptive playback has been requested, try JB fallback
                 // NOTE: THIS FALLBACK MECHANISM WILL BE REMOVED DUE TO ITS
                 // LARGE MEMORY REQUIREMENT
@@ -1402,7 +1457,7 @@ status_t ACodec::configureCodec(
                 if (canDoAdaptivePlayback &&
                         msg->findInt32("max-width", &maxWidth) &&
                         msg->findInt32("max-height", &maxHeight)) {
-                    ALOGV("[%s] prepareForAdaptivePlayback(%dx%d)",
+                    ALOGI("[%s] prepareForAdaptivePlayback(%dx%d)",
                             mComponentName.c_str(), maxWidth, maxHeight);
 
                     err = mOMX->prepareForAdaptivePlayback(
@@ -1417,6 +1472,19 @@ status_t ACodec::configureCodec(
                         inputFormat->setInt32("max-height", maxHeight);
                         inputFormat->setInt32("adaptive-playback", true);
                     }
+                    bAdaptivePlaybackMode = (err == OK);
+                }
+                // if Adaptive mode was tried first and codec failed it, try dynamic mode
+                if (err != OK && preferAdaptive) {
+                    err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, OMX_TRUE);
+                    if (err != OK) {
+                        ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
+                              mComponentName.c_str(), err);
+                    } else {
+                        ALOGV("[%s] storeMetaDataInBuffers succeeded", mComponentName.c_str());
+                        mStoreMetaDataInOutputBuffers = true;
+                        inputFormat->setInt32("adaptive-playback", true);
+                    }
                 }
                 // allow failure
                 err = OK;
@@ -1427,6 +1495,9 @@ status_t ACodec::configureCodec(
                 inputFormat->setInt32("adaptive-playback", true);
             }
 
+            ALOGI("[%s] DRC Mode: %s", mComponentName.c_str(),
+                    (mStoreMetaDataInOutputBuffers ? "Dynamic Buffer Mode" :
+                    (bAdaptivePlaybackMode ? "Adaptive Mode" : "Port Reconfig Mode")));
             int32_t push;
             if (msg->findInt32("push-blank-buffers-on-shutdown", &push)
                     && push != 0) {
@@ -1440,95 +1511,41 @@ status_t ACodec::configureCodec(
         } else {
             mRotationDegrees = 0;
         }
+        // enforce screen-capture protection if requested by app
+        int32_t preventScreenCapture = 0;
+        if (msg->findInt32("prevent-screen-capture", &preventScreenCapture)
+                && preventScreenCapture == 1) {
+            mFlags |= kFlagIsContentDrmProtected;
     }
-
-    if (video) {
-        // determine need for software renderer
-        bool usingSwRenderer = false;
-        if (haveNativeWindow && mComponentName.startsWith("OMX.google.")) {
-            usingSwRenderer = true;
-            haveNativeWindow = false;
         }
 
+    if (video) {
         if (encoder) {
             err = setupVideoEncoder(mime, msg);
         } else {
-            err = setupVideoDecoder(mime, msg, haveNativeWindow);
-        }
-
-        if (err != OK) {
-            return err;
-        }
-
-        if (haveNativeWindow) {
-            sp<NativeWindowWrapper> nativeWindow(
-                    static_cast<NativeWindowWrapper *>(obj.get()));
-            CHECK(nativeWindow != NULL);
-            mNativeWindow = nativeWindow->getNativeWindow();
-
-            native_window_set_scaling_mode(
-                    mNativeWindow.get(), NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-        }
-
-        // initialize native window now to get actual output format
-        // TODO: this is needed for some encoders even though they don't use native window
-        CHECK_EQ((status_t)OK, initNativeWindow());
-
-        // fallback for devices that do not handle flex-YUV for native buffers
-        if (haveNativeWindow) {
-            int32_t requestedColorFormat = OMX_COLOR_FormatUnused;
-            if (msg->findInt32("color-format", &requestedColorFormat) &&
-                    requestedColorFormat == OMX_COLOR_FormatYUV420Flexible) {
-                CHECK_EQ(getPortFormat(kPortIndexOutput, outputFormat), (status_t)OK);
-                int32_t colorFormat = OMX_COLOR_FormatUnused;
-                OMX_U32 flexibleEquivalent = OMX_COLOR_FormatUnused;
-                CHECK(outputFormat->findInt32("color-format", &colorFormat));
-                ALOGD("[%s] Requested output format %#x and got %#x.",
-                        mComponentName.c_str(), requestedColorFormat, colorFormat);
-                if (!isFlexibleColorFormat(
-                                mOMX, mNode, colorFormat, haveNativeWindow, &flexibleEquivalent)
-                        || flexibleEquivalent != (OMX_U32)requestedColorFormat) {
-                    // device did not handle flex-YUV request for native window, fall back
-                    // to SW renderer
-                    ALOGI("[%s] Falling back to software renderer", mComponentName.c_str());
-                    mNativeWindow.clear();
-                    haveNativeWindow = false;
-                    usingSwRenderer = true;
-                    if (mStoreMetaDataInOutputBuffers) {
-                        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, OMX_FALSE);
-                        mStoreMetaDataInOutputBuffers = false;
-                        // TODO: implement adaptive-playback support for bytebuffer mode.
-                        // This is done by SW codecs, but most HW codecs don't support it.
-                        inputFormat->setInt32("adaptive-playback", false);
-                    }
+            err = setupVideoDecoder(mime, msg);
+#ifdef ENABLE_AV_ENHANCEMENTS
                     if (err == OK) {
-                        err = mOMX->enableGraphicBuffers(mNode, kPortIndexOutput, OMX_FALSE);
-                    }
-                    if (mFlags & kFlagIsGrallocUsageProtected) {
-                        // fallback is not supported for protected playback
-                        err = PERMISSION_DENIED;
-                    } else if (err == OK) {
-                        err = setupVideoDecoder(mime, msg, false);
-                    }
-                }
+                const char* componentName = mComponentName.c_str();
+                ExtendedCodec::configureVideoDecoder(msg, mime, mOMX, 0, mNode, componentName);
             }
-        }
-
-        if (usingSwRenderer) {
-            outputFormat->setInt32("using-sw-renderer", 1);
+#endif
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
-        int32_t numChannels, sampleRate;
+        int32_t numChannels, sampleRate, bitsPerSample;
+
         if (!msg->findInt32("channel-count", &numChannels)
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             // Since we did not always check for these, leave them optional
             // and have the decoder figure it all out.
             err = OK;
         } else {
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupRawAudioFormat(
                     encoder ? kPortIndexInput : kPortIndexOutput,
                     sampleRate,
-                    numChannels);
+                    numChannels, bitsPerSample);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
         int32_t numChannels, sampleRate;
@@ -1599,11 +1616,10 @@ status_t ACodec::configureCodec(
         } else {
             err = setupG711Codec(encoder, numChannels);
         }
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
-        int32_t numChannels, sampleRate, compressionLevel = -1;
-        if (encoder &&
-                (!msg->findInt32("channel-count", &numChannels)
-                        || !msg->findInt32("sample-rate", &sampleRate))) {
+    } else if (encoder && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
+        int32_t numChannels = 0, sampleRate = 0, compressionLevel = -1;
+        if (!msg->findInt32("channel-count", &numChannels)
+                    || !msg->findInt32("sample-rate", &sampleRate)) {
             ALOGE("missing channel count or sample rate for FLAC encoder");
             err = INVALID_OPERATION;
         } else {
@@ -1625,8 +1641,10 @@ status_t ACodec::configureCodec(
                     compressionLevel = 8;
                 }
             }
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupFlacCodec(
-                    encoder, numChannels, sampleRate, compressionLevel);
+                    encoder, numChannels, sampleRate, compressionLevel, bitsPerSample);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
         int32_t numChannels, sampleRate;
@@ -1635,25 +1653,42 @@ status_t ACodec::configureCodec(
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bits-per-sample", &bitsPerSample);
+            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels, bitsPerSample);
         }
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
+    } else if (!strncmp(mComponentName.c_str(), "OMX.google.", 11)
+            && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
         int32_t numChannels;
         int32_t sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            err = setupAC3Codec(encoder, numChannels, sampleRate);
+            int32_t bitsPerSample = 16;
+            msg->findInt32("bits-per-sample", &bitsPerSample);
+            err = setupAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
         }
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EAC3)) {
-        int32_t numChannels;
-        int32_t sampleRate;
-        if (!msg->findInt32("channel-count", &numChannels)
-                || !msg->findInt32("sample-rate", &sampleRate)) {
-            err = INVALID_OPERATION;
         } else {
-            err = setupEAC3Codec(encoder, numChannels, sampleRate);
+        if (encoder) {
+            int32_t numChannels, sampleRate;
+            if (msg->findInt32("channel-count", &numChannels)
+                  && msg->findInt32("sample-rate", &sampleRate)) {
+                setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels, 16);
+            }
+        }
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setAudioFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder);
+        }
+#endif
+        if(!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setAudioFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder);
+        }
+        if (err != OK) {
+            return err;
         }
     }
 
@@ -1680,10 +1715,11 @@ status_t ACodec::configureCodec(
         err = setMinBufferSize(kPortIndexInput, (size_t)maxInputSize);
     } else if (!strcmp("OMX.Nvidia.aac.decoder", mComponentName.c_str())) {
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
+    }else if (!strncmp(mComponentName.c_str(), "OMX.brcm.video.h264.hw.decoder", 30)) {
+		ALOGE("PATCH:ACodec:configureCodec:[%s] setMinBufferSize", mComponentName.c_str());
+        setMinBufferSize(kPortIndexInput, (1080 * 720 * 3) / 2);
     }
 
-    mBaseOutputFormat = outputFormat;
-
     CHECK_EQ(getPortFormat(kPortIndexInput, inputFormat), (status_t)OK);
     CHECK_EQ(getPortFormat(kPortIndexOutput, outputFormat), (status_t)OK);
     mInputFormat = inputFormat;
@@ -1767,7 +1803,7 @@ status_t ACodec::setupAACCodec(
     status_t err = setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
             sampleRate,
-            numChannels);
+            numChannels, 16);
 
     if (err != OK) {
         return err;
@@ -1903,9 +1939,9 @@ status_t ACodec::setupAACCodec(
 }
 
 status_t ACodec::setupAC3Codec(
-        bool encoder, int32_t numChannels, int32_t sampleRate) {
+        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
     status_t err = setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels);
+            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
 
     if (err != OK) {
         return err;
@@ -1940,44 +1976,6 @@ status_t ACodec::setupAC3Codec(
             sizeof(def));
 }
 
-status_t ACodec::setupEAC3Codec(
-        bool encoder, int32_t numChannels, int32_t sampleRate) {
-    status_t err = setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels);
-
-    if (err != OK) {
-        return err;
-    }
-
-    if (encoder) {
-        ALOGW("EAC3 encoding is not supported.");
-        return INVALID_OPERATION;
-    }
-
-    OMX_AUDIO_PARAM_ANDROID_EAC3TYPE def;
-    InitOMXParams(&def);
-    def.nPortIndex = kPortIndexInput;
-
-    err = mOMX->getParameter(
-            mNode,
-            (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidEac3,
-            &def,
-            sizeof(def));
-
-    if (err != OK) {
-        return err;
-    }
-
-    def.nChannels = numChannels;
-    def.nSampleRate = sampleRate;
-
-    return mOMX->setParameter(
-            mNode,
-            (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidEac3,
-            &def,
-            sizeof(def));
-}
-
 static OMX_AUDIO_AMRBANDMODETYPE pickModeFromBitRate(
         bool isAMRWB, int32_t bps) {
     if (isAMRWB) {
@@ -2048,18 +2046,19 @@ status_t ACodec::setupAMRCodec(bool encoder, bool isWAMR, int32_t bitrate) {
     return setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
             isWAMR ? 16000 : 8000 /* sampleRate */,
-            1 /* numChannels */);
+            1 /* numChannels */, 16);
 }
 
 status_t ACodec::setupG711Codec(bool encoder, int32_t numChannels) {
     CHECK(!encoder);  // XXX TODO
 
     return setupRawAudioFormat(
-            kPortIndexInput, 8000 /* sampleRate */, numChannels);
+            kPortIndexInput, 8000 /* sampleRate */, numChannels, 16);
 }
 
 status_t ACodec::setupFlacCodec(
-        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel) {
+        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel,
+        int32_t bitsPerSample) {
 
     if (encoder) {
         OMX_AUDIO_PARAM_FLACTYPE def;
@@ -2081,17 +2080,18 @@ status_t ACodec::setupFlacCodec(
     }
 
     return setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput,
+            kPortIndexInput,
             sampleRate,
-            numChannels);
+            numChannels, bitsPerSample);
 }
 
 status_t ACodec::setupRawAudioFormat(
-        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels) {
+        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels, int32_t bitsPerSample) {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
+    ALOGI("sampleRate=%d channels=%d bits=%d", sampleRate, numChannels, bitsPerSample);
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -2122,7 +2122,7 @@ status_t ACodec::setupRawAudioFormat(
     pcmParams.nChannels = numChannels;
     pcmParams.eNumData = OMX_NumericalDataSigned;
     pcmParams.bInterleaved = OMX_TRUE;
-    pcmParams.nBitPerSample = 16;
+    pcmParams.nBitPerSample = bitsPerSample;
     pcmParams.nSamplingRate = sampleRate;
     pcmParams.ePCMMode = OMX_AUDIO_PCMModeLinear;
 
@@ -2158,8 +2158,7 @@ status_t ACodec::configureTunneledVideoPlayback(
 status_t ACodec::setVideoPortFormatType(
         OMX_U32 portIndex,
         OMX_VIDEO_CODINGTYPE compressionFormat,
-        OMX_COLOR_FORMATTYPE colorFormat,
-        bool usingNativeBuffers) {
+        OMX_COLOR_FORMATTYPE colorFormat) {
     OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = portIndex;
@@ -2179,10 +2178,10 @@ status_t ACodec::setVideoPortFormatType(
 
         // substitute back flexible color format to codec supported format
         OMX_U32 flexibleEquivalent;
-        if (compressionFormat == OMX_VIDEO_CodingUnused
-                && isFlexibleColorFormat(
-                        mOMX, mNode, format.eColorFormat, usingNativeBuffers, &flexibleEquivalent)
-                && colorFormat == flexibleEquivalent) {
+        if (compressionFormat == OMX_VIDEO_CodingUnused &&
+                isFlexibleColorFormat(
+                        mOMX, mNode, format.eColorFormat, &flexibleEquivalent) &&
+                colorFormat == flexibleEquivalent) {
             ALOGI("[%s] using color format %#x in place of %#x",
                     mComponentName.c_str(), format.eColorFormat, colorFormat);
             colorFormat = format.eColorFormat;
@@ -2226,66 +2225,18 @@ status_t ACodec::setVideoPortFormatType(
     return err;
 }
 
-// Set optimal output format. OMX component lists output formats in the order
-// of preference, but this got more complicated since the introduction of flexible
-// YUV formats. We support a legacy behavior for applications that do not use
-// surface output, do not specify an output format, but expect a "usable" standard
-// OMX format. SW readable and standard formats must be flex-YUV.
-//
-// Suggested preference order:
-// - optimal format for texture rendering (mediaplayer behavior)
-// - optimal SW readable & texture renderable format (flex-YUV support)
-// - optimal SW readable non-renderable format (flex-YUV bytebuffer support)
-// - legacy "usable" standard formats
-//
-// For legacy support, we prefer a standard format, but will settle for a SW readable
-// flex-YUV format.
-status_t ACodec::setSupportedOutputFormat(bool getLegacyFlexibleFormat) {
-    OMX_VIDEO_PARAM_PORTFORMATTYPE format, legacyFormat;
+status_t ACodec::setSupportedOutputFormat() {
+    OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = kPortIndexOutput;
+    format.nIndex = 0;
 
-    InitOMXParams(&legacyFormat);
-    // this field will change when we find a suitable legacy format
-    legacyFormat.eColorFormat = OMX_COLOR_FormatUnused;
-
-    for (OMX_U32 index = 0; ; ++index) {
-        format.nIndex = index;
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
-        if (err != OK) {
-            // no more formats, pick legacy format if found
-            if (legacyFormat.eColorFormat != OMX_COLOR_FormatUnused) {
-                 memcpy(&format, &legacyFormat, sizeof(format));
-                 break;
-            }
-            return err;
-        }
-        if (format.eCompressionFormat != OMX_VIDEO_CodingUnused) {
-            return OMX_ErrorBadParameter;
-        }
-        if (!getLegacyFlexibleFormat) {
-            break;
-        }
-        // standard formats that were exposed to users before
-        if (format.eColorFormat == OMX_COLOR_FormatYUV420Planar
-                || format.eColorFormat == OMX_COLOR_FormatYUV420PackedPlanar
-                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
-                || format.eColorFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar
-                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
-            break;
-        }
-        // find best legacy non-standard format
-        OMX_U32 flexibleEquivalent;
-        if (legacyFormat.eColorFormat == OMX_COLOR_FormatUnused
-                && isFlexibleColorFormat(
-                        mOMX, mNode, format.eColorFormat, false /* usingNativeBuffers */,
-                        &flexibleEquivalent)
-                && flexibleEquivalent == OMX_COLOR_FormatYUV420Flexible) {
-            memcpy(&legacyFormat, &format, sizeof(format));
-        }
-    }
+    CHECK_EQ(err, (status_t)OK);
+    CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
+
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -2298,6 +2249,7 @@ static const struct VideoCodingMapEntry {
     { MEDIA_MIMETYPE_VIDEO_AVC, OMX_VIDEO_CodingAVC },
     { MEDIA_MIMETYPE_VIDEO_HEVC, OMX_VIDEO_CodingHEVC },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, OMX_VIDEO_CodingMPEG4 },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4_DP, OMX_VIDEO_CodingMPEG4 },
     { MEDIA_MIMETYPE_VIDEO_H263, OMX_VIDEO_CodingH263 },
     { MEDIA_MIMETYPE_VIDEO_MPEG2, OMX_VIDEO_CodingMPEG2 },
     { MEDIA_MIMETYPE_VIDEO_VP8, OMX_VIDEO_CodingVP8 },
@@ -2337,7 +2289,7 @@ static status_t GetMimeTypeForVideoCoding(
 }
 
 status_t ACodec::setupVideoDecoder(
-        const char *mime, const sp<AMessage> &msg, bool haveNativeWindow) {
+        const char *mime, const sp<AMessage> &msg) {
     int32_t width, height;
     if (!msg->findInt32("width", &width)
             || !msg->findInt32("height", &height)) {
@@ -2348,8 +2300,19 @@ status_t ACodec::setupVideoDecoder(
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setVideoFormat(msg, mime, &compressionFormat);
+        }
+#endif
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
         return err;
     }
+    }
 
     err = setVideoPortFormatType(
             kPortIndexInput, compressionFormat, OMX_COLOR_FormatUnused);
@@ -2363,31 +2326,22 @@ status_t ACodec::setupVideoDecoder(
         OMX_COLOR_FORMATTYPE colorFormat =
             static_cast<OMX_COLOR_FORMATTYPE>(tmp);
         err = setVideoPortFormatType(
-                kPortIndexOutput, OMX_VIDEO_CodingUnused, colorFormat, haveNativeWindow);
+                kPortIndexOutput, OMX_VIDEO_CodingUnused, colorFormat);
         if (err != OK) {
             ALOGW("[%s] does not support color format %d",
                   mComponentName.c_str(), colorFormat);
-            err = setSupportedOutputFormat(!haveNativeWindow /* getLegacyFlexibleFormat */);
+            err = setSupportedOutputFormat();
         }
     } else {
-        err = setSupportedOutputFormat(!haveNativeWindow /* getLegacyFlexibleFormat */);
+        err = setSupportedOutputFormat();
     }
 
     if (err != OK) {
         return err;
     }
 
-    int32_t frameRateInt;
-    float frameRateFloat;
-    if (!msg->findFloat("frame-rate", &frameRateFloat)) {
-        if (!msg->findInt32("frame-rate", &frameRateInt)) {
-            frameRateInt = -1;
-        }
-        frameRateFloat = (float)frameRateInt;
-    }
-
     err = setVideoFormatOnPort(
-            kPortIndexInput, width, height, compressionFormat, frameRateFloat);
+            kPortIndexInput, width, height, compressionFormat);
 
     if (err != OK) {
         return err;
@@ -2476,11 +2430,7 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
 
     video_def->xFramerate = (OMX_U32)(frameRate * 65536.0f);
     video_def->eCompressionFormat = OMX_VIDEO_CodingUnused;
-    // this is redundant as it was already set up in setVideoPortFormatType
-    // FIXME for now skip this only for flexible YUV formats
-    if (colorFormat != OMX_COLOR_FormatYUV420Flexible) {
         video_def->eColorFormat = colorFormat;
-    }
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
@@ -2498,8 +2448,20 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setVideoFormat(msg, mime, &compressionFormat);
+        }
+#endif
+        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
+            ALOGE("Not a supported video mime type: %s", mime);
         return err;
     }
+    }
 
     err = setVideoPortFormatType(
             kPortIndexOutput, compressionFormat, OMX_COLOR_FormatUnused);
@@ -2563,7 +2525,8 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
             break;
     }
 
-    ALOGI("setupVideoEncoder succeeded");
+    ALOGI("[%s] setupVideoEncoder %s", mComponentName.c_str(),
+            err == OK ? "succeeded" : "failed");
 
     return err;
 }
@@ -2688,6 +2651,7 @@ status_t ACodec::setupMPEG4EncoderParameters(const sp<AMessage> &msg) {
         mpeg4type.eProfile = static_cast<OMX_VIDEO_MPEG4PROFILETYPE>(profile);
         mpeg4type.eLevel = static_cast<OMX_VIDEO_MPEG4LEVELTYPE>(level);
     }
+    ExtendedUtils::setBFrames(mpeg4type, mComponentName.c_str());
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoMpeg4, &mpeg4type, sizeof(mpeg4type));
@@ -2886,6 +2850,8 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         err = verifySupportForProfileAndLevel(profile, level);
 
         if (err != OK) {
+            ALOGE("%s does not support profile %x @ level %x",
+                    mComponentName.c_str(), profile, level);
             return err;
         }
 
@@ -2894,11 +2860,14 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
     }
 
     // XXX
+    // Allow higher profiles to be set since the encoder seems to support
+#if 0
     if (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) {
         ALOGW("Use baseline profile instead of %d for AVC recording",
             h264type.eProfile);
         h264type.eProfile = OMX_VIDEO_AVCProfileBaseline;
     }
+#endif
 
     if (h264type.eProfile == OMX_VIDEO_AVCProfileBaseline) {
         h264type.nSliceHeaderSpacing = 0;
@@ -2918,6 +2887,8 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         h264type.bDirectSpatialTemporal = OMX_FALSE;
         h264type.nCabacInitIdc = 0;
     }
+    ExtendedUtils::setBFrames(h264type, iFrameInterval,
+            frameRate, mComponentName.c_str());
 
     if (h264type.nBFrames != 0) {
         h264type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
@@ -3140,7 +3111,7 @@ status_t ACodec::setupErrorCorrectionParameters() {
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
     errorCorrectionType.bEnableResync = OMX_TRUE;
-    errorCorrectionType.nResynchMarkerSpacing = 256;
+    errorCorrectionType.nResynchMarkerSpacing = 0;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
@@ -3151,8 +3122,7 @@ status_t ACodec::setupErrorCorrectionParameters() {
 
 status_t ACodec::setVideoFormatOnPort(
         OMX_U32 portIndex,
-        int32_t width, int32_t height, OMX_VIDEO_CODINGTYPE compressionFormat,
-        float frameRate) {
+        int32_t width, int32_t height, OMX_VIDEO_CODINGTYPE compressionFormat) {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
@@ -3180,9 +3150,6 @@ status_t ACodec::setVideoFormatOnPort(
     if (portIndex == kPortIndexInput) {
         video_def->eCompressionFormat = compressionFormat;
         video_def->eColorFormat = OMX_COLOR_FormatUnused;
-        if (frameRate >= 0) {
-            video_def->xFramerate = (OMX_U32)(frameRate * 65536.0f);
-        }
     }
 
     err = mOMX->setParameter(
@@ -3265,7 +3232,6 @@ bool ACodec::allYourBuffersAreBelongToUs() {
 }
 
 void ACodec::deferMessage(const sp<AMessage> &msg) {
-    bool wasEmptyBefore = mDeferredQueue.empty();
     mDeferredQueue.push_back(msg);
 }
 
@@ -3295,8 +3261,7 @@ bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
     if (fmt != OMX_COLOR_FormatYUV420Planar &&
         fmt != OMX_COLOR_FormatYUV420PackedPlanar &&
         fmt != OMX_COLOR_FormatYUV420SemiPlanar &&
-        fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar &&
-        fmt != HAL_PIXEL_FORMAT_YV12) {
+        fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar) {
         ALOGW("do not know color format 0x%x = %d", fmt, fmt);
         return false;
     }
@@ -3325,31 +3290,8 @@ bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
     image.mPlane[image.Y].mHorizSubsampling = 1;
     image.mPlane[image.Y].mVertSubsampling = 1;
 
-    switch ((int)fmt) {
-        case HAL_PIXEL_FORMAT_YV12:
-            if (params.bUsingNativeBuffers) {
-                size_t ystride = align(params.nStride, 16);
-                size_t cstride = align(params.nStride / 2, 16);
-                image.mPlane[image.Y].mRowInc = ystride;
-
-                image.mPlane[image.V].mOffset = ystride * params.nSliceHeight;
-                image.mPlane[image.V].mColInc = 1;
-                image.mPlane[image.V].mRowInc = cstride;
-                image.mPlane[image.V].mHorizSubsampling = 2;
-                image.mPlane[image.V].mVertSubsampling = 2;
-
-                image.mPlane[image.U].mOffset = image.mPlane[image.V].mOffset
-                        + (cstride * params.nSliceHeight / 2);
-                image.mPlane[image.U].mColInc = 1;
-                image.mPlane[image.U].mRowInc = cstride;
-                image.mPlane[image.U].mHorizSubsampling = 2;
-                image.mPlane[image.U].mVertSubsampling = 2;
-                break;
-            } else {
-                // fall through as YV12 is used for YUV420Planar by some codecs
-            }
-
-        case OMX_COLOR_FormatYUV420Planar:
+    switch (fmt) {
+        case OMX_COLOR_FormatYUV420Planar: // used for YV12
         case OMX_COLOR_FormatYUV420PackedPlanar:
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 1;
@@ -3409,7 +3351,7 @@ bool ACodec::describeColorFormat(
 // static
 bool ACodec::isFlexibleColorFormat(
          const sp<IOMX> &omx, IOMX::node_id node,
-         uint32_t colorFormat, bool usingNativeBuffers, OMX_U32 *flexibleEquivalent) {
+         uint32_t colorFormat, OMX_U32 *flexibleEquivalent) {
     DescribeColorFormatParams describeParams;
     InitOMXParams(&describeParams);
     describeParams.eColorFormat = (OMX_COLOR_FORMATTYPE)colorFormat;
@@ -3418,7 +3360,6 @@ bool ACodec::isFlexibleColorFormat(
     describeParams.nFrameHeight = 128;
     describeParams.nStride = 128;
     describeParams.nSliceHeight = 128;
-    describeParams.bUsingNativeBuffers = (OMX_BOOL)usingNativeBuffers;
 
     CHECK(flexibleEquivalent != NULL);
 
@@ -3476,7 +3417,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("slice-height", videoDef->nSliceHeight);
                     notify->setInt32("color-format", videoDef->eColorFormat);
 
-                    if (mNativeWindow == NULL) {
                         DescribeColorFormatParams describeParams;
                         InitOMXParams(&describeParams);
                         describeParams.eColorFormat = videoDef->eColorFormat;
@@ -3484,7 +3424,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                         describeParams.nFrameHeight = videoDef->nFrameHeight;
                         describeParams.nStride = videoDef->nStride;
                         describeParams.nSliceHeight = videoDef->nSliceHeight;
-                        describeParams.bUsingNativeBuffers = OMX_FALSE;
 
                         if (describeColorFormat(mOMX, mNode, describeParams)) {
                             notify->setBuffer(
@@ -3492,14 +3431,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                                     ABuffer::CreateAsCopy(
                                             &describeParams.sMediaImage,
                                             sizeof(describeParams.sMediaImage)));
-
-                            MediaImage *img = &describeParams.sMediaImage;
-                            ALOGV("[%s] MediaImage { F(%zux%zu) @%zu+%zu+%zu @%zu+%zu+%zu @%zu+%zu+%zu }",
-                                    mComponentName.c_str(), img->mWidth, img->mHeight,
-                                    img->mPlane[0].mOffset, img->mPlane[0].mColInc, img->mPlane[0].mRowInc,
-                                    img->mPlane[1].mOffset, img->mPlane[1].mColInc, img->mPlane[1].mRowInc,
-                                    img->mPlane[2].mOffset, img->mPlane[2].mColInc, img->mPlane[2].mRowInc);
-                        }
                     }
 
                     if (portIndex != kPortIndexOutput) {
@@ -3596,12 +3527,9 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     break;
                 }
             }
+
             notify->setInt32("width", videoDef->nFrameWidth);
             notify->setInt32("height", videoDef->nFrameHeight);
-            ALOGV("[%s] %s format is %s", mComponentName.c_str(),
-                    portIndex == kPortIndexInput ? "input" : "output",
-                    notify->debugString().c_str());
-
             break;
         }
 
@@ -3623,8 +3551,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 
                     CHECK_GT(params.nChannels, 0);
                     CHECK(params.nChannels == 1 || params.bInterleaved);
-                    CHECK_EQ(params.nBitPerSample, 16u);
-
                     CHECK_EQ((int)params.eNumData,
                              (int)OMX_NumericalDataSigned);
 
@@ -3635,6 +3561,11 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSamplingRate);
 
+                    CHECK(params.nBitPerSample == 16u ||
+                          params.nBitPerSample == 24u ||
+                          params.nBitPerSample == 32u);
+                    notify->setInt32("bits-per-sample", params.nBitPerSample);
+
                     if (mChannelMaskPresent) {
                         notify->setInt32("channel-mask", mChannelMask);
                     }
@@ -3753,24 +3684,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     break;
                 }
 
-                case OMX_AUDIO_CodingAndroidEAC3:
-                {
-                    OMX_AUDIO_PARAM_ANDROID_EAC3TYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = portIndex;
-
-                    CHECK_EQ((status_t)OK, mOMX->getParameter(
-                            mNode,
-                            (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidEac3,
-                            &params,
-                            sizeof(params)));
-
-                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_EAC3);
-                    notify->setInt32("channel-count", params.nChannels);
-                    notify->setInt32("sample-rate", params.nSampleRate);
-                    break;
-                }
-
                 case OMX_AUDIO_CodingAndroidOPUS:
                 {
                     OMX_AUDIO_PARAM_ANDROID_OPUSTYPE params;
@@ -3815,27 +3728,41 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     break;
                 }
 
-                case OMX_AUDIO_CodingGSMFR:
+                default:
                 {
-                    OMX_AUDIO_PARAM_MP3TYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = portIndex;
-
-                    CHECK_EQ(mOMX->getParameter(
-                                mNode, OMX_IndexParamAudioPcm,
-                                &params, sizeof(params)),
-                             (status_t)OK);
-
-                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_MSGSM);
-                    notify->setInt32("channel-count", params.nChannels);
-                    notify->setInt32("sample-rate", params.nSampleRate);
+                    AString mimeType;
+                    status_t err = ERROR_UNSUPPORTED;
+#ifdef ENABLE_AV_ENHANCEMENTS
+                    if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
+                        err = ExtendedCodec::handleSupportedAudioFormats(
+                            audioDef->eEncoding, &mimeType);
+                    }
+#endif
+                    if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
+                        err = FFMPEGSoftCodec::handleSupportedAudioFormats(
+                                audioDef->eEncoding, &mimeType);
+                    }
+                    if (err == OK) {
+                        int channelCount = 0;
+                        int sampleRate = 0;
+#ifdef ENABLE_AV_ENHANCEMENTS
+                        err = ExtendedCodec::getSupportedAudioFormatInfo(
+                                      &mimeType,
+                                      mOMX,
+                                      mNode,
+                                      portIndex,
+                                      &channelCount,
+                                      &sampleRate);
+#endif
+                        notify->setString("mime", mimeType.c_str());
+                        notify->setInt32("channel-count", channelCount);
+                        notify->setInt32("sample-rate", sampleRate);
                     break;
                 }
-
-                default:
                     ALOGE("UNKNOWN AUDIO CODING: %d\n", audioDef->eEncoding);
                     TRESPASS();
             }
+            }
             break;
         }
 
@@ -3847,7 +3774,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 }
 
 void ACodec::sendFormatChange(const sp<AMessage> &reply) {
-    sp<AMessage> notify = mBaseOutputFormat->dup();
+    sp<AMessage> notify = mNotify->dup();
     notify->setInt32("what", kWhatOutputFormatChanged);
 
     CHECK_EQ(getPortFormat(kPortIndexOutput, notify), (status_t)OK);
@@ -3898,9 +3825,6 @@ void ACodec::signalError(OMX_ERRORTYPE error, status_t internalError) {
             ALOGW("Invalid OMX error %#x", error);
         }
     }
-
-    mFatalError = true;
-
     notify->setInt32("err", internalError);
     notify->setInt32("actionCode", ACTION_CODE_FATAL); // could translate from OMX error.
     notify->post();
@@ -3976,7 +3900,6 @@ status_t ACodec::pushBlankBuffersToNativeWindow() {
     // on the screen and then been replaced, so an previous video frames are
     // guaranteed NOT to be currently displayed.
     for (int i = 0; i < numBufs + 1; i++) {
-        int fenceFd = -1;
         err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &anb);
         if (err != NO_ERROR) {
             ALOGE("error pushing blank frames: dequeueBuffer failed: %s (%d)",
@@ -4429,6 +4352,12 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                     }
                 }
 
+                if (mCodec->mMediaExtendedStats != NULL) {
+                    bool isVideo = mCodec->mComponentName.find("video") != -1;
+                    mCodec->mMediaExtendedStats->profileStartOnce(
+                            STATS_PROFILE_FIRST_BUFFER(isVideo));
+                }
+
                 CHECK_EQ(mCodec->mOMX->emptyBuffer(
                             mCodec->mNode,
                             bufferID,
@@ -4555,8 +4484,7 @@ bool ACodec::BaseState::onOMXFillBufferDone(
 
         case RESUBMIT_BUFFERS:
         {
-            if (rangeLength == 0 && (!(flags & OMX_BUFFERFLAG_EOS)
-                    || mCodec->mPortEOS[kPortIndexOutput])) {
+            if (rangeLength == 0 && !(flags & OMX_BUFFERFLAG_EOS)) {
                 ALOGV("[%s] calling fillBuffer %u",
                      mCodec->mComponentName.c_str(), info->mBufferID);
 
@@ -4596,6 +4524,7 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                 mCodec->mSkipCutBuffer->submit(info->mData);
             }
             info->mData->meta()->setInt64("timeUs", timeUs);
+            info->mData->meta()->setObject("graphic-buffer", info->mGraphicBuffer);
 
             sp<AMessage> notify = mCodec->mNotify->dup();
             notify->setInt32("what", CodecBase::kWhatDrainThisBuffer);
@@ -4659,6 +4588,12 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
         ATRACE_NAME("render");
         // The client wants this buffer to be rendered.
 
+        if (mCodec->mMediaExtendedStats != NULL) {
+            bool isVideo = mCodec->mComponentName.find("video") != -1;
+            mCodec->mMediaExtendedStats->profileStop(
+                STATS_PROFILE_FIRST_BUFFER(isVideo));
+        }
+
         int64_t timestampNs = 0;
         if (!msg->findInt64("timestampNs", &timestampNs)) {
             // TODO: it seems like we should use the timestamp
@@ -4695,6 +4630,13 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
         info->mStatus = BufferInfo::OWNED_BY_US;
     }
 
+    if (mCodec->mMediaExtendedStats != NULL) {
+        int32_t seeking;
+        if (info->mData->meta()->findInt32("seeking", &seeking)) {
+            mCodec->mMediaExtendedStats->profileStop(STATS_PROFILE_SEEK);
+        }
+    }
+
     PortMode mode = getPortMode(kPortIndexOutput);
 
     switch (mode) {
@@ -4837,7 +4779,7 @@ void ACodec::UninitializedState::onSetup(
 
 bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
     ALOGV("onAllocateComponent");
-
+    ATRACE_NAME("onAllocatecomponent");
     CHECK(mCodec->mNode == NULL);
 
     OMXClient client;
@@ -4877,6 +4819,43 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
             encoder = false;
         }
 
+        ALOGV("onAllocateComponent %s %d", mime.c_str(), encoder);
+#ifdef ENABLE_AV_ENHANCEMENTS
+    // Call UseQCHWAACEncoder with no arguments to get the correct state since
+    // MediaCodecSource does not pass the output format details when calling
+    // kInit leading to msg passed not having enough details
+    if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_AAC)
+        && ExtendedUtils::UseQCHWAACEncoder() && encoder) {
+        //use hw aac encoder
+        ALOGD("use QCOM HW AAC encoder");
+        OMXCodec::findMatchingCodecs(
+                mime.c_str(),
+                encoder, // createEncoder
+                "OMX.qcom.audio.encoder.aac",  // OMX.qcom.audio.encoder.aac
+                0,     // flags
+                &matchingCodecs);
+#ifdef QTI_FLAC_DECODER
+    } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_FLAC) && !encoder) {
+        //use google's raw decoder
+        OMXCodec::findMatchingCodecs(
+                MEDIA_MIMETYPE_AUDIO_RAW,
+                encoder, //createEncoder
+                "OMX.google.raw.decoder",
+                0, //flags
+                &matchingCodecs);
+#endif
+    } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_AAC)
+        && ExtendedUtils::UseQCHWAACDecoder(mime.c_str()) && !encoder) {
+        //use hw aac decoder
+        ALOGD("use QCOM HW AAC decoder");
+        OMXCodec::findMatchingCodecs(
+                mime.c_str(),
+                encoder, // createEncoder
+                "OMX.qcom.audio.decoder.multiaac",  // OMX.qcom.audio.decoder.multiaac
+                0,     // flags
+                &matchingCodecs);
+    } else
+#endif
         OMXCodec::findMatchingCodecs(
                 mime.c_str(),
                 encoder, // createEncoder
@@ -4892,6 +4871,8 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
             ++matchIndex) {
         componentName = matchingCodecs.itemAt(matchIndex).mName.string();
         quirks = matchingCodecs.itemAt(matchIndex).mQuirks;
+        // this doesn't work here as the format isn't passed in the message
+        //ExtendedCodec::overrideComponentName(quirks, msg, &componentName, &mime, encoder);
 
         pid_t tid = androidGetTid();
         int prevPriority = androidGetThreadPriority(tid);
@@ -4928,7 +4909,6 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
 
     if (componentName.endsWith(".secure")) {
         mCodec->mFlags |= kFlagIsSecure;
-        mCodec->mFlags |= kFlagIsGrallocUsageProtected;
         mCodec->mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;
     }
 
@@ -4967,7 +4947,6 @@ void ACodec::LoadedState::stateEntered() {
     mCodec->mRepeatFrameDelayUs = -1ll;
     mCodec->mInputFormat.clear();
     mCodec->mOutputFormat.clear();
-    mCodec->mBaseOutputFormat.clear();
 
     if (mCodec->mShutdownInProgress) {
         bool keepComponentAllocated = mCodec->mKeepComponentAllocated;
@@ -5071,6 +5050,21 @@ bool ACodec::LoadedState::onConfigureComponent(
         return false;
     }
 
+    sp<RefBase> obj;
+    if (msg->findObject("native-window", &obj)
+            && strncmp("OMX.google.", mCodec->mComponentName.c_str(), 11)
+            && strncmp("OMX.ffmpeg.", mCodec->mComponentName.c_str(), 11)) {
+        sp<NativeWindowWrapper> nativeWindow(
+                static_cast<NativeWindowWrapper *>(obj.get()));
+        CHECK(nativeWindow != NULL);
+        mCodec->mNativeWindow = nativeWindow->getNativeWindow();
+
+        native_window_set_scaling_mode(
+                mCodec->mNativeWindow.get(),
+                NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
+    }
+    CHECK_EQ((status_t)OK, mCodec->initNativeWindow());
+
     {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", CodecBase::kWhatComponentConfigured);
@@ -5634,6 +5628,11 @@ bool ACodec::ExecutingState::onOMXEvent(
                 mCodec->freeOutputBuffersNotOwnedByComponent();
 
                 mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
+
+                bool isVideo = mCodec->mComponentName.find("video") != -1;
+                if (isVideo) {
+                    CODEC_PLAYER_STATS(profileStart, STATS_PROFILE_RECONFIGURE);
+                }
             } else if (data2 == OMX_IndexConfigCommonOutputCrop) {
                 mCodec->mSentFormat = false;
             } else {
@@ -5680,6 +5679,7 @@ bool ACodec::OutputPortSettingsChangedState::onMessageReceived(
         case kWhatFlush:
         case kWhatShutdown:
         case kWhatResume:
+        case kWhatSetParameters:
         {
             if (msg->what() == kWhatResume) {
                 ALOGV("[%s] Deferring resume", mCodec->mComponentName.c_str());
@@ -5755,6 +5755,11 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
 
                 mCodec->changeState(mCodec->mExecutingState);
 
+                bool isVideo = mCodec->mComponentName.find("video") != -1;
+                if (isVideo) {
+                    CODEC_PLAYER_STATS(profileStop, STATS_PROFILE_RECONFIGURE);
+                }
+
                 return true;
             }
 
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 9f20b1d..29c0f45 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -40,14 +40,10 @@
 #include <cutils/properties.h>
 
 #include "include/ESDS.h"
-
-
-#ifndef __predict_false
-#define __predict_false(exp) __builtin_expect((exp) != 0, 0)
-#endif
+#include "include/ExtendedUtils.h"
 
 #define WARN_UNLESS(condition, message, ...) \
-( (__predict_false(condition)) ? false : ({ \
+( (CONDITION(condition)) ? false : ({ \
     ALOGW("Condition %s failed "  message, #condition, ##__VA_ARGS__); \
     true; \
 }))
@@ -80,6 +76,7 @@ public:
     bool isAvc() const { return mIsAvc; }
     bool isAudio() const { return mIsAudio; }
     bool isMPEG4() const { return mIsMPEG4; }
+    bool isHEVC() const { return mIsHEVC; }
     void addChunkOffset(off64_t offset);
     int32_t getTrackId() const { return mTrackId; }
     status_t dump(int fd, const Vector<String16>& args) const;
@@ -222,6 +219,7 @@ private:
     bool mIsAvc;
     bool mIsAudio;
     bool mIsMPEG4;
+    bool mIsHEVC;
     int32_t mTrackId;
     int64_t mTrackDurationUs;
     int64_t mMaxChunkDurationUs;
@@ -304,6 +302,7 @@ private:
     // Simple validation on the codec specific data
     status_t checkCodecSpecificData() const;
     int32_t mRotation;
+    int32_t mHFRRatio;
 
     void updateTrackSizeEstimate();
     void addOneStscTableEntry(size_t chunkId, size_t sampleId);
@@ -362,7 +361,10 @@ MPEG4Writer::MPEG4Writer(const char *filename)
       mLatitudex10000(0),
       mLongitudex10000(0),
       mAreGeoTagsAvailable(false),
-      mStartTimeOffsetMs(-1) {
+      mStartTimeOffsetMs(-1),
+      mHFRRatio(1),
+      mIsVideoHEVC(false),
+      mIsAudioAMR(false) {
 
     mFd = open(filename, O_CREAT | O_LARGEFILE | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);
     if (mFd >= 0) {
@@ -387,7 +389,10 @@ MPEG4Writer::MPEG4Writer(int fd)
       mLatitudex10000(0),
       mLongitudex10000(0),
       mAreGeoTagsAvailable(false),
-      mStartTimeOffsetMs(-1) {
+      mStartTimeOffsetMs(-1),
+      mHFRRatio(1),
+      mIsVideoHEVC(false),
+      mIsAudioAMR(false) {
 }
 
 MPEG4Writer::~MPEG4Writer() {
@@ -454,15 +459,31 @@ status_t MPEG4Writer::addSource(const sp<MediaSource> &source) {
 
     // A track of type other than video or audio is not supported.
     const char *mime;
-    source->getFormat()->findCString(kKeyMIMEType, &mime);
+    sp<MetaData> meta = source->getFormat();
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
     bool isAudio = !strncasecmp(mime, "audio/", 6);
     bool isVideo = !strncasecmp(mime, "video/", 6);
+
+    if (isVideo) {
+        mIsVideoHEVC = ExtendedUtils::HEVCMuxer::isVideoHEVC(mime);
+    }
+
+    if (isAudio) {
+        mIsAudioAMR = ExtendedUtils::isAudioAMR(mime);
+    }
+
     if (!isAudio && !isVideo) {
         ALOGE("Track (%s) other than video or audio is not supported",
             mime);
         return ERROR_UNSUPPORTED;
     }
 
+    // Check that muxing is supported for the given video type
+    if (isVideo && !ExtendedUtils::isVideoMuxFormatSupported(mime)) {
+        ALOGE("Muxing is not supported for %s", mime);
+        return ERROR_UNSUPPORTED;
+    }
+
     // At this point, we know the track to be added is either
     // video or audio. Thus, we only need to check whether it
     // is an audio track or not (if it is not, then it must be
@@ -482,6 +503,8 @@ status_t MPEG4Writer::addSource(const sp<MediaSource> &source) {
     Track *track = new Track(this, source, 1 + mTracks.size());
     mTracks.push_back(track);
 
+    mHFRRatio = ExtendedUtils::HFR::getHFRRatio(meta);
+
     return OK;
 }
 
@@ -522,7 +545,7 @@ int64_t MPEG4Writer::estimateMoovBoxSize(int32_t bitRate) {
 
     // If the estimation is wrong, we will pay the price of wasting
     // some reserved space. This should not happen so often statistically.
-    static const int32_t factor = mUse32BitOffset? 1: 2;
+    int32_t factor = mUse32BitOffset? 1: 2;
     static const int64_t MIN_MOOV_BOX_SIZE = 3 * 1024;  // 3 KB
     static const int64_t MAX_MOOV_BOX_SIZE = (180 * 3000000 * 6LL / 8000);
     int64_t size = MIN_MOOV_BOX_SIZE;
@@ -616,8 +639,6 @@ status_t MPEG4Writer::start(MetaData *param) {
         mIsRealTimeRecording = isRealTimeRecording;
     }
 
-    mStartTimestampUs = -1;
-
     if (mStarted) {
         if (mPaused) {
             mPaused = false;
@@ -626,6 +647,8 @@ status_t MPEG4Writer::start(MetaData *param) {
         return OK;
     }
 
+    mStartTimestampUs = -1;
+
     if (!param ||
         !param->findInt32(kKeyTimeScale, &mTimeScale)) {
         mTimeScale = 1000;
@@ -946,7 +969,7 @@ void MPEG4Writer::writeMvhdBox(int64_t durationUs) {
     writeInt32(0);             // version=0, flags=0
     writeInt32(now);           // creation time
     writeInt32(now);           // modification time
-    writeInt32(mTimeScale);    // mvhd timescale
+    writeInt32(mTimeScale / mHFRRatio);    // mvhd timescale
     int32_t duration = (durationUs * mTimeScale + 5E5) / 1E6;
     writeInt32(duration);
     writeInt32(0x10000);       // rate: 1.0
@@ -983,8 +1006,11 @@ void MPEG4Writer::writeFtypBox(MetaData *param) {
     beginBox("ftyp");
 
     int32_t fileType;
-    if (param && param->findInt32(kKeyFileType, &fileType) &&
-        fileType != OUTPUT_FORMAT_MPEG_4) {
+    if (mIsVideoHEVC) {
+        ExtendedUtils::HEVCMuxer::writeHEVCFtypBox(this);
+    } else if ((param && param->findInt32(kKeyFileType, &fileType) &&
+            fileType != OUTPUT_FORMAT_MPEG_4) || mIsAudioAMR) {
+        // 'damr' is only supported by the 3gp4 standard, not mp42
         writeFourcc("3gp4");
         writeInt32(0);
         writeFourcc("isom");
@@ -1371,16 +1397,18 @@ MPEG4Writer::Track::Track(
       mCodecSpecificDataSize(0),
       mGotAllCodecSpecificData(false),
       mReachedEOS(false),
-      mRotation(0) {
-    getCodecSpecificDataFromInputFormatIfPossible();
-
+      mRotation(0),
+      mHFRRatio(1) {
     const char *mime;
     mMeta->findCString(kKeyMIMEType, &mime);
+
     mIsAvc = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC);
     mIsAudio = !strncasecmp(mime, "audio/", 6);
     mIsMPEG4 = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4) ||
                !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC);
+    mIsHEVC = ExtendedUtils::HEVCMuxer::isVideoHEVC(mime);
 
+    getCodecSpecificDataFromInputFormatIfPossible();
     setTimeScale();
 }
 
@@ -1496,7 +1524,22 @@ void MPEG4Writer::Track::getCodecSpecificDataFromInputFormatIfPossible() {
                 mGotAllCodecSpecificData = true;
             }
         }
+    } else if (mIsHEVC) {
+        uint32_t type;
+        const void *data;
+        size_t size;
+        //kKeyHVCC needs to be populated
+        if (ExtendedUtils::HEVCMuxer::getHEVCCodecConfigData(mMeta, &data, &size)) {
+            mCodecSpecificData = malloc(size);
+            CHECK(mCodecSpecificData != NULL);
+            mCodecSpecificDataSize = size;
+            memcpy(mCodecSpecificData, data, size);
+            mGotAllCodecSpecificData = true;
+        } else {
+            ALOGW("getHEVCCodecConfigData:: failed to find kKeyHvcc");
+    }
     }
+
 }
 
 MPEG4Writer::Track::~Track() {
@@ -1573,7 +1616,7 @@ void MPEG4Writer::writeChunkToFile(Chunk* chunk) {
     while (!chunk->mSamples.empty()) {
         List<MediaBuffer *>::iterator it = chunk->mSamples.begin();
 
-        off64_t offset = chunk->mTrack->isAvc()
+        off64_t offset = (chunk->mTrack->isAvc() | chunk->mTrack->isHEVC())
                                 ? addLengthPrefixedSample_l(*it)
                                 : addSample_l(*it);
 
@@ -1747,6 +1790,12 @@ status_t MPEG4Writer::Track::start(MetaData *params) {
 
     meta->setInt64(kKeyTime, startTimeUs);
 
+    if (params) {
+        RecorderExtendedStats* rStats = NULL;
+        params->findPointer(ExtendedStats::MEDIA_STATS_FLAG, (void**)&rStats);
+        meta->setPointer(ExtendedStats::MEDIA_STATS_FLAG, rStats);
+    }
+
     status_t err = mSource->start(meta.get());
     if (err != OK) {
         mDone = mReachedEOS = true;
@@ -1768,6 +1817,8 @@ status_t MPEG4Writer::Track::start(MetaData *params) {
     pthread_create(&mThread, &attr, ThreadWrapper, this);
     pthread_attr_destroy(&attr);
 
+    mHFRRatio = ExtendedUtils::HFR::getHFRRatio(mMeta);
+
     return OK;
 }
 
@@ -1796,7 +1847,10 @@ status_t MPEG4Writer::Track::stop() {
     pthread_join(mThread, &dummy);
     status_t err = static_cast<status_t>(reinterpret_cast<uintptr_t>(dummy));
 
-    ALOGD("%s track stopped", mIsAudio? "Audio": "Video");
+    if (mOwner->exceedsFileSizeLimit() && mStszTableEntries->count() == 0) {
+        ALOGE(" Filesize limit exceeded and zero samples written ");
+        return ERROR_END_OF_STREAM;
+    }
     return err;
 }
 
@@ -2075,6 +2129,7 @@ void MPEG4Writer::Track::updateDriftTime(const sp<MetaData>& meta) {
 }
 
 status_t MPEG4Writer::Track::threadEntry() {
+	ALOGE("PATCH:MPEG4Writer:threadEntry");	
     int32_t count = 0;
     const int64_t interleaveDurationUs = mOwner->interleaveDuration();
     const bool hasMultipleTracks = (mOwner->numTracks() > 1);
@@ -2096,12 +2151,15 @@ status_t MPEG4Writer::Track::threadEntry() {
     uint32_t lastSamplesPerChunk = 0;
 
     if (mIsAudio) {
+		ALOGE("PATCH:MPEG4Writer:threadEntry AudioTrackEncoding");
         prctl(PR_SET_NAME, (unsigned long)"AudioTrackEncoding", 0, 0, 0);
     } else {
+		ALOGE("PATCH:MPEG4Writer:threadEntry VideoTrackEncoding");
         prctl(PR_SET_NAME, (unsigned long)"VideoTrackEncoding", 0, 0, 0);
     }
 
     if (mOwner->isRealTimeRecording()) {
+		ALOGE("PATCH:MPEG4Writer:threadEntry isRealTimeRecording");
         androidSetThreadPriority(0, ANDROID_PRIORITY_AUDIO);
     }
 
@@ -2110,8 +2168,11 @@ status_t MPEG4Writer::Track::threadEntry() {
     status_t err = OK;
     MediaBuffer *buffer;
     const char *trackName = mIsAudio ? "Audio" : "Video";
+	ALOGE("PATCH:MPEG4Writer:threadEntry(%s)", trackName);
     while (!mDone && (err = mSource->read(&buffer)) == OK) {
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) read(buffer)", trackName);
         if (buffer->range_length() == 0) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) range_length 0", trackName);
             buffer->release();
             buffer = NULL;
             ++nZeroLengthFrames;
@@ -2122,6 +2183,7 @@ status_t MPEG4Writer::Track::threadEntry() {
         // After the codec specific data is received, discard what we received
         // when the track is to be paused.
         if (mPaused && !mResumed) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mPaused && !mResumed", trackName);
             buffer->release();
             buffer = NULL;
             continue;
@@ -2135,18 +2197,29 @@ status_t MPEG4Writer::Track::threadEntry() {
             CHECK(!mGotAllCodecSpecificData);
 
             if (mIsAvc) {
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mIsAvc", trackName);
                 status_t err = makeAVCCodecSpecificData(
                         (const uint8_t *)buffer->data()
                             + buffer->range_offset(),
                         buffer->range_length());
                 CHECK_EQ((status_t)OK, err);
             } else if (mIsMPEG4) {
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mIsMPEG4", trackName);
                 mCodecSpecificDataSize = buffer->range_length();
                 mCodecSpecificData = malloc(mCodecSpecificDataSize);
                 memcpy(mCodecSpecificData,
                         (const uint8_t *)buffer->data()
                             + buffer->range_offset(),
                        buffer->range_length());
+            } else if (mIsHEVC) {
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mIsHEVC", trackName);
+                status_t err = ExtendedUtils::HEVCMuxer::makeHEVCCodecSpecificData(
+                        (const uint8_t *)buffer->data() + buffer->range_offset(),
+                        buffer->range_length(), &mCodecSpecificData, &mCodecSpecificDataSize);
+                if ((status_t)OK != err) {
+                    ALOGE("hevc codec config creation failed, bailing out");
+                    return err;
+                }
             }
 
             buffer->release();
@@ -2156,23 +2229,40 @@ status_t MPEG4Writer::Track::threadEntry() {
             continue;
         }
 
+        MediaBuffer *copy = NULL;
+        int32_t deferRelease = false;
+        // Check if the upstream source hints it is OK to hold on to the
+        // buffer without releasing immediately and avoid cloning the buffer
+        buffer->meta_data()->findInt32(kKeyCanDeferRelease, &deferRelease);
+        if (deferRelease) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) deferRelease", trackName);
+            copy = buffer;
+            meta_data = new MetaData(*buffer->meta_data().get());
+        } else {
         // Make a deep copy of the MediaBuffer and Metadata and release
         // the original as soon as we can
-        MediaBuffer *copy = new MediaBuffer(buffer->range_length());
+            copy = new MediaBuffer(buffer->range_length());
         memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
                 buffer->range_length());
         copy->set_range(0, buffer->range_length());
         meta_data = new MetaData(*buffer->meta_data().get());
         buffer->release();
         buffer = NULL;
+        }
 
-        if (mIsAvc) StripStartcode(copy);
+        if (mIsAvc || mIsHEVC) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mIsAvc || mIsHEVC StripStartcode", trackName);
+            StripStartcode(copy);
+        }
 
         size_t sampleSize = copy->range_length();
-        if (mIsAvc) {
+        if (mIsAvc || mIsHEVC) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mIsAvc || mIsHEVC", trackName);
             if (mOwner->useNalLengthFour()) {
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) sampleSize += 4", trackName);
                 sampleSize += 4;
             } else {
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) sampleSize += 2", trackName);
                 sampleSize += 2;
             }
         }
@@ -2182,10 +2272,12 @@ status_t MPEG4Writer::Track::threadEntry() {
         updateTrackSizeEstimate();
 
         if (mOwner->exceedsFileSizeLimit()) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) exceedsFileSizeLimit", trackName);
             mOwner->notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0);
             break;
         }
         if (mOwner->exceedsFileDurationLimit()) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) exceedsFileDurationLimit", trackName);
             mOwner->notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0);
             break;
         }
@@ -2193,40 +2285,35 @@ status_t MPEG4Writer::Track::threadEntry() {
 
         int32_t isSync = false;
         meta_data->findInt32(kKeyIsSyncFrame, &isSync);
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) findInt32 (kKeyIsSyncFrame) = %i", trackName, isSync);
         CHECK(meta_data->findInt64(kKeyTime, &timestampUs));
-
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) findInt64 (kKeyTime) timestampUs = %i", trackName, timestampUs);
 ////////////////////////////////////////////////////////////////////////////////
         if (mStszTableEntries->count() == 0) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) count() == 0 mFirstSampleTimeRealUs = %i", trackName, mFirstSampleTimeRealUs);
             mFirstSampleTimeRealUs = systemTime() / 1000;
             mStartTimestampUs = timestampUs;
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) count() == 0 mStartTimestampUs = %i AND SET", trackName, mStartTimestampUs);
             mOwner->setStartTimestampUs(mStartTimestampUs);
             previousPausedDurationUs = mStartTimestampUs;
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) count() == 0 previousPausedDurationUs = %i", trackName, previousPausedDurationUs);
         }
 
         if (mResumed) {
-            int64_t durExcludingEarlierPausesUs = timestampUs - previousPausedDurationUs;
-            if (WARN_UNLESS(durExcludingEarlierPausesUs >= 0ll, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
-            }
-
-            int64_t pausedDurationUs = durExcludingEarlierPausesUs - mTrackDurationUs;
-            if (WARN_UNLESS(pausedDurationUs >= lastDurationUs, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
-            }
-
-            previousPausedDurationUs += pausedDurationUs - lastDurationUs;
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) mResumed false", trackName);
             mResumed = false;
         }
 
         timestampUs -= previousPausedDurationUs;
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) (timestampUs(%i) -= previousPausedDurationUs(%i)) ", trackName, timestampUs, previousPausedDurationUs);
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) timestampUs(%i) >= 0ll ERROR_MALFORMED 1", trackName, timestampUs);
+            //copy->release();
+            //return ERROR_MALFORMED;
         }
 
         if (!mIsAudio) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) !mIsAudio", trackName);
             /*
              * Composition time: timestampUs
              * Decoding time: decodingTimeUs
@@ -2234,52 +2321,87 @@ status_t MPEG4Writer::Track::threadEntry() {
              */
             int64_t decodingTimeUs;
             CHECK(meta_data->findInt64(kKeyDecodingTime, &decodingTimeUs));
+			
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) findInt64(kKeyDecodingTime) decodingTimeUs = %i", trackName, decodingTimeUs);
+			
             decodingTimeUs -= previousPausedDurationUs;
+			
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) (decodingTimeUs(%i) -= previousPausedDurationUs(%i))", trackName, decodingTimeUs, previousPausedDurationUs);
+            
             cttsOffsetTimeUs =
-                    timestampUs + kMaxCttsOffsetTimeUs - decodingTimeUs;
-            if (WARN_UNLESS(cttsOffsetTimeUs >= 0ll, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                    timestampUs - decodingTimeUs;
+					
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) (cttsOffsetTimeUs(%i) = timestampUs(%i) - decodingTimeUs(%i))", trackName, cttsOffsetTimeUs, timestampUs, decodingTimeUs);
+            		
+            if (WARN_UNLESS(kMaxCttsOffsetTimeUs >= decodingTimeUs - timestampUs, "for %s track", trackName)) {
+				
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) kMaxCttsOffsetTimeUs(%i) >= (%i) decodingTimeUs - timestampUs ERROR_MALFORMED 2", trackName, kMaxCttsOffsetTimeUs, decodingTimeUs - timestampUs);
+            
+               // copy->release();
+               // return ERROR_MALFORMED;
             }
 
             timestampUs = decodingTimeUs;
+			
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  timestampUs(%i) = decodingTimeUs(%i);", trackName, timestampUs, decodingTimeUs);
+            
             ALOGV("decoding time: %" PRId64 " and ctts offset time: %" PRId64,
                 timestampUs, cttsOffsetTimeUs);
 
             // Update ctts box table if necessary
             currCttsOffsetTimeTicks =
                     (cttsOffsetTimeUs * mTimeScale + 500000LL) / 1000000LL;
+					
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) currCttsOffsetTimeTicks(%i) = (cttsOffsetTimeUs(%i) * mTimeScale + 500000LL) / 1000000LL", trackName, currCttsOffsetTimeTicks, cttsOffsetTimeUs);
+			
             if (WARN_UNLESS(currCttsOffsetTimeTicks <= 0x0FFFFFFFFLL, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+				
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) currCttsOffsetTimeTicks(%i) <= 0x0FFFFFFFFLL ERROR_MALFORMED 3", trackName, currCttsOffsetTimeTicks);
+		
+                //copy->release();
+                //return ERROR_MALFORMED;
             }
 
             if (mStszTableEntries->count() == 0) {
                 // Force the first ctts table entry to have one single entry
                 // so that we can do adjustment for the initial track start
                 // time offset easily in writeCttsBox().
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) count() == 0", trackName);
                 lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks;
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) count() == 0 lastCttsOffsetTimeTicks(%i) = currCttsOffsetTimeTicks(%i)", trackName, lastCttsOffsetTimeTicks, currCttsOffsetTimeTicks);
                 addOneCttsTableEntry(1, currCttsOffsetTimeTicks);
                 cttsSampleCount = 0;      // No sample in ctts box is pending
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s) count() == 0  cttsSampleCount = 0", trackName);
             } else {
                 if (currCttsOffsetTimeTicks != lastCttsOffsetTimeTicks) {
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s) currCttsOffsetTimeTicks(%i) != lastCttsOffsetTimeTicks(%i)", trackName, currCttsOffsetTimeTicks, lastCttsOffsetTimeTicks);
                     addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks);
                     lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks;
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s) lastCttsOffsetTimeTicks(%i) = currCttsOffsetTimeTicks(%i)", trackName, lastCttsOffsetTimeTicks, currCttsOffsetTimeTicks);
+                
                     cttsSampleCount = 1;  // One sample in ctts box is pending
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s) cttsSampleCount = 1", trackName);
                 } else {
                     ++cttsSampleCount;
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  ++cttsSampleCount(%i)", trackName, cttsSampleCount);
                 }
             }
 
             // Update ctts time offset range
             if (mStszTableEntries->count() == 0) {
                 mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks;
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  mMinCttsOffsetTimeUs(%i) = currCttsOffsetTimeTicks(%i)", trackName, mMinCttsOffsetTimeUs, currCttsOffsetTimeTicks);
                 mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks;
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  mMaxCttsOffsetTimeUs(%i) = currCttsOffsetTimeTicks(%i)", trackName, mMaxCttsOffsetTimeUs, currCttsOffsetTimeTicks);
             } else {
                 if (currCttsOffsetTimeTicks > mMaxCttsOffsetTimeUs) {
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  currCttsOffsetTimeTicks(%i) > mMaxCttsOffsetTimeUs(%i)", trackName, mMaxCttsOffsetTimeUs, currCttsOffsetTimeTicks);
                     mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks;
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  mMaxCttsOffsetTimeUs(%i) = currCttsOffsetTimeTicks(%i)", trackName, mMaxCttsOffsetTimeUs, currCttsOffsetTimeTicks);
                 } else if (currCttsOffsetTimeTicks < mMinCttsOffsetTimeUs) {
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  currCttsOffsetTimeTicks(%i) <  mMinCttsOffsetTimeUs(%i)", trackName, mMaxCttsOffsetTimeUs, mMinCttsOffsetTimeUs);
                     mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks;
+					ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  mMinCttsOffsetTimeUs(%i) = currCttsOffsetTimeTicks(%i)", trackName, mMinCttsOffsetTimeUs, currCttsOffsetTimeTicks);
                 }
             }
 
@@ -2287,19 +2409,23 @@ status_t MPEG4Writer::Track::threadEntry() {
 
         if (mOwner->isRealTimeRecording()) {
             if (mIsAudio) {
+				ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  updateDriftTime", trackName);
                 updateDriftTime(meta_data);
             }
         }
 
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) timestampUs(%i) >= 0ll ERROR_MALFORMED 4", trackName, timestampUs);
+            //copy->release();
+            //return ERROR_MALFORMED;
         }
 
         ALOGV("%s media time stamp: %" PRId64 " and previous paused duration %" PRId64,
                 trackName, timestampUs, previousPausedDurationUs);
         if (timestampUs > mTrackDurationUs) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s) timestampUs(%i) > mTrackDurationUs(%i)", trackName, timestampUs, mTrackDurationUs);
             mTrackDurationUs = timestampUs;
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  mTrackDurationUs(%i) = timestampUs (%i)", trackName, mTrackDurationUs, timestampUs);
         }
 
         // We need to use the time scale based ticks, rather than the
@@ -2310,11 +2436,15 @@ status_t MPEG4Writer::Track::threadEntry() {
         currDurationTicks =
             ((timestampUs * mTimeScale + 500000LL) / 1000000LL -
                 (lastTimestampUs * mTimeScale + 500000LL) / 1000000LL);
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  currDurationTicks (%i)", trackName, currDurationTicks);		
         if (currDurationTicks < 0ll) {
+			ALOGE("PATCH:MPEG4Writer:threadEntry(%s)  currDurationTicks (%i) < 0ll UNKNOWN_ERROR", trackName, currDurationTicks);
             ALOGE("timestampUs %" PRId64 " < lastTimestampUs %" PRId64 " for %s track",
                 timestampUs, lastTimestampUs, trackName);
-            copy->release();
-            return UNKNOWN_ERROR;
+            //copy->release();
+            //err = UNKNOWN_ERROR;
+            //mSource->notifyError(err);
+            //return err;
         }
 
         // if the duration is different for this sample, see if it is close enough to the previous
@@ -2369,7 +2499,7 @@ status_t MPEG4Writer::Track::threadEntry() {
             trackProgressStatus(timestampUs);
         }
         if (!hasMultipleTracks) {
-            off64_t offset = mIsAvc? mOwner->addLengthPrefixedSample_l(copy)
+            off64_t offset = (mIsAvc | mIsHEVC) ? mOwner->addLengthPrefixedSample_l(copy)
                                  : mOwner->addSample_l(copy);
 
             uint32_t count = (mOwner->use32BitFileOffset()
@@ -2412,13 +2542,16 @@ status_t MPEG4Writer::Track::threadEntry() {
     }
 
     if (isTrackMalFormed()) {
-        err = ERROR_MALFORMED;
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) isTrackMalFormed ERROR_MALFORMED", trackName);
+   		//err = ERROR_MALFORMED;
     }
 
     mOwner->trackProgressStatus(mTrackId, -1, err);
 
+	ALOGE("PATCH:MPEG4Writer:threadEntry(%s) trackProgressStatus err = %i", trackName, err);
+
     // Last chunk
-    if (!hasMultipleTracks) {
+    if (!hasMultipleTracks && mIsAudio) {
         addOneStscTableEntry(1, mStszTableEntries->count());
     } else if (!mChunkSamples.empty()) {
         addOneStscTableEntry(++nChunks, mChunkSamples.size());
@@ -2464,8 +2597,11 @@ status_t MPEG4Writer::Track::threadEntry() {
     }
 
     if (err == ERROR_END_OF_STREAM) {
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) return OK err = %i", trackName, err);
+		ALOGE("PATCH:MPEG4Writer:threadEntry(%s) return OK", trackName);
         return OK;
     }
+	ALOGE("PATCH:MPEG4Writer:threadEntry(%s) err = %i", trackName, err);
     return err;
 }
 
@@ -2621,7 +2757,8 @@ status_t MPEG4Writer::Track::checkCodecSpecificData() const {
     CHECK(mMeta->findCString(kKeyMIMEType, &mime));
     if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AAC, mime) ||
         !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
-        !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime) ||
+        mIsHEVC) {
         if (!mCodecSpecificData ||
             mCodecSpecificDataSize <= 0) {
             ALOGE("Missing codec specific data");
@@ -2642,6 +2779,11 @@ void MPEG4Writer::Track::writeTrackHeader(bool use32BitOffset) {
     ALOGV("%s track time scale: %d",
         mIsAudio? "Audio": "Video", mTimeScale);
 
+    if (mMdatSizeBytes == 0) {
+      ALOGV("Track data is not available.");
+      return;
+    }
+
     uint32_t now = getMpeg4Time();
     mOwner->beginBox("trak");
         writeTkhdBox(now);
@@ -2693,6 +2835,8 @@ void MPEG4Writer::Track::writeVideoFourCCBox() {
         mOwner->beginBox("s263");
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
         mOwner->beginBox("avc1");
+    } else if (mIsHEVC) {
+        ExtendedUtils::HEVCMuxer::beginHEVCBox(mOwner);
     } else {
         ALOGE("Unknown mime type '%s'.", mime);
         CHECK(!"should not be here, unknown mime type.");
@@ -2731,9 +2875,16 @@ void MPEG4Writer::Track::writeVideoFourCCBox() {
         writeD263Box();
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
         writeAvccBox();
+    } else if (mIsHEVC) {
+        ExtendedUtils::HEVCMuxer::writeHvccBox(mOwner, mCodecSpecificData,
+                                               mCodecSpecificDataSize,
+                                               mOwner->useNalLengthFour());
     }
 
+    if (!mIsHEVC) {
     writePaspBox();
+    }
+
     mOwner->endBox();  // mp4v, s263 or avc1
 }
 
@@ -2800,8 +2951,10 @@ void MPEG4Writer::Track::writeMp4aEsdsBox() {
 
     mOwner->writeInt16(0x03);  // XXX
     mOwner->writeInt8(0x00);   // buffer size 24-bit
-    mOwner->writeInt32(96000); // max bit rate
-    mOwner->writeInt32(96000); // avg bit rate
+    int32_t bitRate;
+    bool success = mMeta->findInt32(kKeyBitRate, &bitRate);
+    mOwner->writeInt32(success ? bitRate : 96000); // max bit rate
+    mOwner->writeInt32(success ? bitRate : 96000); // avg bit rate
 
     mOwner->writeInt8(0x05);   // DecoderSpecificInfoTag
     mOwner->writeInt8(mCodecSpecificDataSize);
@@ -2931,7 +3084,9 @@ void MPEG4Writer::Track::writeMdhdBox(uint32_t now) {
     mOwner->writeInt32(0);             // version=0, flags=0
     mOwner->writeInt32(now);           // creation time
     mOwner->writeInt32(now);           // modification time
-    mOwner->writeInt32(mTimeScale);    // media timescale
+
+    int32_t timeScale = mTimeScale / mHFRRatio;
+    mOwner->writeInt32(timeScale);    // media timescale
     int32_t mdhdDuration = (trakDurationUs * mTimeScale + 5E5) / 1E6;
     mOwner->writeInt32(mdhdDuration);  // use media timescale
     // Language follows the three letter standard ISO-639-2/T
@@ -3010,7 +3165,7 @@ void MPEG4Writer::Track::writePaspBox() {
 int32_t MPEG4Writer::Track::getStartTimeOffsetScaledTime() const {
     int64_t trackStartTimeOffsetUs = 0;
     int64_t moovStartTimeUs = mOwner->getStartTimestampUs();
-    if (mStartTimestampUs != moovStartTimeUs) {
+    if (mStartTimestampUs != moovStartTimeUs && mStszTableEntries->count() != 0) {
         CHECK_GT(mStartTimestampUs, moovStartTimeUs);
         trackStartTimeOffsetUs = mStartTimestampUs - moovStartTimeUs;
     }
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 6cb0775..ecd8e99 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
- *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -24,6 +23,8 @@
 #endif
 
 #include <utils/Log.h>
+#define ATRACE_TAG ATRACE_TAG_VIDEO
+#include <utils/Trace.h>
 
 #include "include/AACEncoder.h"
 
@@ -47,16 +48,58 @@
 #include <media/stagefright/SkipCutBuffer.h>
 #include <utils/Vector.h>
 
+#include <OMX_Audio.h>
 #include <OMX_AudioExt.h>
 #include <OMX_Component.h>
 #include <OMX_IndexExt.h>
-#include <OMX_VideoExt.h>
-#include <OMX_AsString.h>
+
+#include "include/ExtendedUtils.h"
 
 #include "include/avc_utils.h"
 
+#include <media/stagefright/ExtendedCodec.h>
+#include <media/stagefright/FFMPEGSoftCodec.h>
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+#include <QCMediaDefs.h>
+#include <QCMetaData.h>
+#include <QOMX_AudioExtensions.h>
+#endif
+
+#ifdef QTI_FLAC_DECODER
+#include "include/FLACDecoder.h"
+#endif
+
+#ifdef USE_SAMSUNG_COLORFORMAT
+#include <sec_format.h>
+#endif
+
+#ifdef USE_S3D_SUPPORT
+#include "Exynos_OMX_Def.h"
+#include "ExynosHWCService.h"
+#endif
+
 namespace android {
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+static const int OMX_SEC_COLOR_FormatNV12TPhysicalAddress = 0x7F000001;
+static const int OMX_SEC_COLOR_FormatNV12LPhysicalAddress = 0x7F000002;
+static const int OMX_SEC_COLOR_FormatNV12LVirtualAddress = 0x7F000003;
+static const int OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002;
+static int calc_plane(int width, int height)
+{
+    int mbX, mbY;
+
+    mbX = (width + 15)/16;
+    mbY = (height + 15)/16;
+
+    /* Alignment for interlaced processing */
+    mbY = (mbY + 1) / 2 * 2;
+
+    return (mbX * 16) * (mbY * 16);
+}
+#endif // USE_SAMSUNG_COLORFORMAT
+
 // Treat time out as an error if we have not received any output
 // buffers after 3 seconds.
 const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
@@ -68,6 +111,10 @@ const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
 // component in question is buggy or not.
 const static uint32_t kMaxColorFormatSupported = 1000;
 
+#define FACTORY_CREATE(name) \
+static sp<MediaSource> Make##name(const sp<MediaSource> &source) { \
+    return new name(source); \
+}
 #define FACTORY_CREATE_ENCODER(name) \
 static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaData> &meta) { \
     return new name(source, meta); \
@@ -75,6 +122,9 @@ static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaDa
 
 #define FACTORY_REF(name) { #name, Make##name },
 
+#ifdef QTI_FLAC_DECODER
+FACTORY_CREATE(FLACDecoder)
+#endif
 FACTORY_CREATE_ENCODER(AACEncoder)
 
 static sp<MediaSource> InstantiateSoftwareEncoder(
@@ -98,6 +148,29 @@ static sp<MediaSource> InstantiateSoftwareEncoder(
     return NULL;
 }
 
+#ifdef QTI_FLAC_DECODER
+static sp<MediaSource> InstantiateSoftwareDecoder(
+        const char *name, const sp<MediaSource> &source) {
+    struct FactoryInfo {
+        const char *name;
+        sp<MediaSource> (*CreateFunc)(const sp<MediaSource> &);
+    };
+
+    static const FactoryInfo kFactoryInfo[] = {
+        FACTORY_REF(FLACDecoder)
+    };
+    for (size_t i = 0;
+         i < sizeof(kFactoryInfo) / sizeof(kFactoryInfo[0]); ++i) {
+        if (!strcmp(name, kFactoryInfo[i].name)) {
+            return (*kFactoryInfo[i].CreateFunc)(source);
+        }
+
+    }
+
+    return NULL;
+}
+#endif
+
 #undef FACTORY_CREATE_ENCODER
 #undef FACTORY_REF
 
@@ -146,11 +219,16 @@ static void InitOMXParams(T *params) {
 }
 
 static bool IsSoftwareCodec(const char *componentName) {
-    if (!strncmp("OMX.google.", componentName, 11)) {
+	ALOGE("PATCH:OMXCodec:IsSoftwareCodec: %s", componentName);
+    if (!strncmp("OMX.google.", componentName, 11)
+        || !strncmp("OMX.ffmpeg.", componentName, 11)
+        || !strncmp("OMX.PV.", componentName, 7)) {
+		ALOGE("PATCH:OMXCodec:IsSoftwareCodec: %s YES", componentName);	
         return true;
     }
 
     if (!strncmp("OMX.", componentName, 4)) {
+		ALOGE("PATCH:OMXCodec:IsSoftwareCodec: %s NO", componentName);
         return false;
     }
 
@@ -197,6 +275,8 @@ void OMXCodec::findMatchingCodecs(
         bool createEncoder, const char *matchComponentName,
         uint32_t flags,
         Vector<CodecNameAndQuirks> *matchingCodecs) {
+			
+		ALOGE("PATCH:OMXCodec:findMatchingCodecs");	
     matchingCodecs->clear();
 
     const sp<IMediaCodecList> list = MediaCodecList::getInstance();
@@ -205,6 +285,43 @@ void OMXCodec::findMatchingCodecs(
     }
 
     size_t index = 0;
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+    //Check if application specially reuqested for aac hardware encoder/decoder
+    //This is not a part of  mediacodec list
+    if (matchComponentName &&
+            !strncmp("OMX.qcom.audio.encoder.aac", matchComponentName, 26)) {
+        matchingCodecs->add();
+
+        CodecNameAndQuirks *entry = &matchingCodecs->editItemAt(index);
+        entry->mName = String8("OMX.qcom.audio.encoder.aac");
+        entry->mQuirks = 0;
+        return;
+    }
+
+#ifdef QTI_FLAC_DECODER
+    if (matchComponentName && !strncmp("FLACDecoder", matchComponentName, strlen("FLACDecoder"))) {
+            matchingCodecs->add();
+
+            CodecNameAndQuirks *entry = &matchingCodecs->editItemAt(index);
+            entry->mName = String8("FLACDecoder");
+            entry->mQuirks = 0;
+            return;
+    }
+#endif
+
+    if (matchComponentName &&
+            !strncmp("OMX.qcom.audio.decoder.multiaac", matchComponentName, 31)) {
+        matchingCodecs->add();
+
+        CodecNameAndQuirks *entry = &matchingCodecs->editItemAt(index);
+        entry->mName = String8("OMX.qcom.audio.decoder.multiaac");
+        entry->mQuirks |= kRequiresAllocateBufferOnInputPorts;
+        entry->mQuirks |= kRequiresAllocateBufferOnOutputPorts;
+        return;
+    }
+#endif
+
     for (;;) {
         ssize_t matchIndex =
             list->findCodecByType(mime, createEncoder, index);
@@ -250,33 +367,71 @@ void OMXCodec::findMatchingCodecs(
 // static
 uint32_t OMXCodec::getComponentQuirks(
         const sp<MediaCodecInfo> &info) {
+		ALOGE("PATCH:OMXCodec:getComponentQuirks");	
     uint32_t quirks = 0;
     if (info->hasQuirk("requires-allocate-on-input-ports")) {
+		ALOGE("PATCH:OMXCodec:getComponentQuirks: requires-allocate-on-input-ports");	
         quirks |= kRequiresAllocateBufferOnInputPorts;
     }
     if (info->hasQuirk("requires-allocate-on-output-ports")) {
+		ALOGE("PATCH:OMXCodec:getComponentQuirks: requires-allocate-on-output-ports");
         quirks |= kRequiresAllocateBufferOnOutputPorts;
     }
     if (info->hasQuirk("output-buffers-are-unreadable")) {
+		ALOGE("PATCH:OMXCodec:getComponentQuirks: output-buffers-are-unreadable");
         quirks |= kOutputBuffersAreUnreadable;
     }
+    if (info->hasQuirk("requies-loaded-to-idle-after-allocation")) {
+		ALOGE("PATCH:OMXCodec:getComponentQuirks: requies-loaded-to-idle-after-allocation");
+        quirks |= kRequiresLoadedToIdleAfterAllocation;
+    }
+    if (info->hasQuirk("requires-global-flush")) {
+		ALOGE("PATCH:OMXCodec:getComponentQuirks: requires-global-flush");
+        quirks |= kRequiresGlobalFlush;
+    }
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+    quirks |= ExtendedCodec::getComponentQuirks(info);
+#endif
 
     return quirks;
 }
 
 // static
 bool OMXCodec::findCodecQuirks(const char *componentName, uint32_t *quirks) {
+	ALOGE("PATCH:OMXCodec:findCodecQuirks");
     const sp<IMediaCodecList> list = MediaCodecList::getInstance();
     if (list == NULL) {
         return false;
     }
+#ifdef ENABLE_AV_ENHANCEMENTS
+    //Check for aac hardware encoder
+    //This is not a part of  mediacodec list
+    if (componentName &&
+            !strncmp("OMX.qcom.audio.encoder.aac", componentName, 26)) {
+        *quirks = 0;
+        return true;
+    }
+#endif
 
     ssize_t index = list->findCodecByName(componentName);
 
     if (index < 0) {
+		ALOGE("PATCH:OMXCodec:findCodecQuirks: findCodecByName<0");
         return false;
     }
 
+#ifdef ENABLE_AV_ENHANCEMENTS
+    //Check for aac hardware decoder
+    //This is not a part of  mediacodec list
+    if (componentName &&
+            !strncmp("OMX.qcom.audio.decoder.multiaac", componentName, 31)) {
+        *quirks |= kRequiresAllocateBufferOnInputPorts;
+        *quirks |= kRequiresAllocateBufferOnOutputPorts;
+        return true;
+    }
+#endif
+
     const sp<MediaCodecInfo> info = list->getCodecInfo(index);
     CHECK(info != NULL);
     *quirks = getComponentQuirks(info);
@@ -292,6 +447,7 @@ sp<MediaSource> OMXCodec::Create(
         const char *matchComponentName,
         uint32_t flags,
         const sp<ANativeWindow> &nativeWindow) {
+		ALOGE("PATCH:OMXCodec:Create");	
     int32_t requiresSecureBuffers;
     if (source->getFormat()->findInt32(
                 kKeyRequiresSecureBuffers,
@@ -305,11 +461,28 @@ sp<MediaSource> OMXCodec::Create(
     bool success = meta->findCString(kKeyMIMEType, &mime);
     CHECK(success);
 
+	ALOGE("PATCH:OMXCodec:Create: mime = %s", mime);	
+
     Vector<CodecNameAndQuirks> matchingCodecs;
+
+#ifdef QTI_FLAC_DECODER
+    if (!strncmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC, strlen(MEDIA_MIMETYPE_AUDIO_FLAC))) {
+        findMatchingCodecs(mime, createEncoder,
+            "FLACDecoder", flags, &matchingCodecs);
+    } else
+#endif
+    if (!strncmp(mime, MEDIA_MIMETYPE_AUDIO_AAC, 15) &&
+            ExtendedUtils::UseQCHWAACDecoder(mime)) {
+        findMatchingCodecs(mime, createEncoder,
+            "OMX.qcom.audio.decoder.multiaac", flags, &matchingCodecs);
+    } else {
+		ALOGE("PATCH:OMXCodec:Create: findMatchingCodecs");
     findMatchingCodecs(
             mime, createEncoder, matchComponentName, flags, &matchingCodecs);
+    }
 
     if (matchingCodecs.isEmpty()) {
+		ALOGE("PATCH:OMXCodec:Create: findMatchingCodecs isEmpty return null");
         ALOGV("No matching codecs! (mime: %s, createEncoder: %s, "
                 "matchComponentName: %s, flags: 0x%x)",
                 mime, createEncoder ? "true" : "false", matchComponentName, flags);
@@ -324,23 +497,41 @@ sp<MediaSource> OMXCodec::Create(
         uint32_t quirks = matchingCodecs[i].mQuirks;
         const char *componentName = componentNameBase;
 
+		ALOGE("PATCH:OMXCodec:Create: codec %s", componentName);
+
         AString tmp;
         if (flags & kUseSecureInputBuffers) {
+			
             tmp = componentNameBase;
             tmp.append(".secure");
 
             componentName = tmp.c_str();
+			
+			ALOGE("PATCH:OMXCodec:Create: (flags & kUseSecureInputBuffers) codec %s", componentName);
         }
 
+        sp<MediaSource> softwareCodec;
         if (createEncoder) {
-            sp<MediaSource> softwareCodec =
-                InstantiateSoftwareEncoder(componentName, source, meta);
+            softwareCodec = InstantiateSoftwareEncoder(componentName, source, meta);
+			ALOGE("PATCH:OMXCodec:Create: createEncoder codec %s", componentName);
+        }
+#ifdef QTI_FLAC_DECODER
+        else {
+            softwareCodec = InstantiateSoftwareDecoder(componentName, source);
+			ALOGE("PATCH:OMXCodec:Create: createDecoder codec %s", componentName);
+        }
+#endif
 
             if (softwareCodec != NULL) {
                 ALOGV("Successfully allocated software codec '%s'", componentName);
-
+			ALOGE("PATCH:OMXCodec:Create: Successfully allocated software codec '%s'", componentName);
                 return softwareCodec;
             }
+
+        const char* ext_componentName = ExtendedCodec::overrideComponentName(quirks, meta, mime, createEncoder);
+        if(ext_componentName != NULL) {
+          componentName = ext_componentName;
+		  ALOGE("PATCH:OMXCodec:Create: ExtendedCodec codec '%s'", componentName);
         }
 
         ALOGV("Attempting to allocate OMX node '%s'", componentName);
@@ -360,9 +551,26 @@ sp<MediaSource> OMXCodec::Create(
             }
         }
 
+        //STATS profiling
+        PlayerExtendedStats* tempPtr = NULL;
+        meta->findPointer(ExtendedStats::MEDIA_STATS_FLAG, (void**)&tempPtr);
+
+        bool isVideo = !strncasecmp("video/", mime, 6);
+        if (tempPtr) {
+			ALOGE("PATCH:OMXCodec:Create: profileStart isVideo codec '%s', isvideo %i", componentName, isVideo);
+            tempPtr->profileStart(STATS_PROFILE_ALLOCATE_NODE(isVideo));
+        }
+		
+		ALOGE("PATCH:OMXCodec:Create: allocateNode codec '%s'", componentName);
         status_t err = omx->allocateNode(componentName, observer, &node);
+
+        if (tempPtr) {
+			ALOGE("PATCH:OMXCodec:Create: profileStop isVideo codec '%s', isvideo", componentName, isVideo);
+            tempPtr->profileStop(STATS_PROFILE_ALLOCATE_NODE(isVideo));
+        }
+
         if (err == OK) {
-            ALOGV("Successfully allocated OMX node '%s'", componentName);
+            ALOGD("Successfully allocated OMX node '%s'", componentName);
 
             sp<OMXCodec> codec = new OMXCodec(
                     omx, node, quirks, flags,
@@ -371,8 +579,19 @@ sp<MediaSource> OMXCodec::Create(
 
             observer->setCodec(codec);
 
+            { //profile configure codec
+                ExtendedStats::AutoProfile autoProfile(
+                        STATS_PROFILE_CONFIGURE_CODEC(isVideo), tempPtr);
+				ALOGE("PATCH:OMXCodec:Create: configureCodec %s meta", componentName);		
             err = codec->configureCodec(meta);
+            }
+
+            /* set the stats pointer if we haven't yet and it exists */
+            if(codec->mPlayerExtendedStats == NULL && tempPtr)
+                codec->mPlayerExtendedStats = tempPtr;
+
             if (err == OK) {
+				ALOGE("PATCH:OMXCodec:Create: '%s' OK", componentName);	
                 return codec;
             }
 
@@ -386,6 +605,8 @@ sp<MediaSource> OMXCodec::Create(
 status_t OMXCodec::parseHEVCCodecSpecificData(
         const void *data, size_t size,
         unsigned *profile, unsigned *level) {
+			
+	ALOGE("PATCH:OMXCodec:parseHEVCCodecSpecificData");		
     const uint8_t *ptr = (const uint8_t *)data;
 
     // verify minimum size and configurationVersion == 1.
@@ -437,10 +658,12 @@ status_t OMXCodec::parseHEVCCodecSpecificData(
 status_t OMXCodec::parseAVCCodecSpecificData(
         const void *data, size_t size,
         unsigned *profile, unsigned *level) {
+	ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData");			
     const uint8_t *ptr = (const uint8_t *)data;
 
     // verify minimum size and configurationVersion == 1.
     if (size < 7 || ptr[0] != 1) {
+		ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData ERROR_MALFORMED");
         return ERROR_MALFORMED;
     }
 
@@ -451,7 +674,7 @@ status_t OMXCodec::parseAVCCodecSpecificData(
     // assertion, let's be lenient for now...
     // CHECK((ptr[4] >> 2) == 0x3f);  // reserved
 
-    size_t lengthSize = 1 + (ptr[4] & 3);
+    size_t lengthSize __unused = 1 + (ptr[4] & 3);
 
     // commented out check below as H264_QVGA_500_NO_AUDIO.3gp
     // violates it...
@@ -464,6 +687,7 @@ status_t OMXCodec::parseAVCCodecSpecificData(
 
     for (size_t i = 0; i < numSeqParameterSets; ++i) {
         if (size < 2) {
+			ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData ERROR_MALFORMED 2");
             return ERROR_MALFORMED;
         }
 
@@ -473,6 +697,7 @@ status_t OMXCodec::parseAVCCodecSpecificData(
         size -= 2;
 
         if (size < length) {
+			ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData ERROR_MALFORMED 3");
             return ERROR_MALFORMED;
         }
 
@@ -483,6 +708,7 @@ status_t OMXCodec::parseAVCCodecSpecificData(
     }
 
     if (size < 1) {
+		ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData ERROR_MALFORMED 4");
         return ERROR_MALFORMED;
     }
 
@@ -492,6 +718,7 @@ status_t OMXCodec::parseAVCCodecSpecificData(
 
     for (size_t i = 0; i < numPictureParameterSets; ++i) {
         if (size < 2) {
+			ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData ERROR_MALFORMED 5");
             return ERROR_MALFORMED;
         }
 
@@ -501,9 +728,11 @@ status_t OMXCodec::parseAVCCodecSpecificData(
         size -= 2;
 
         if (size < length) {
+			ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData ERROR_MALFORMED 6");
             return ERROR_MALFORMED;
         }
 
+		ALOGE("PATCH:OMXCodec:parseAVCCodecSpecificData addCodecSpecificData ptr = %i, Len= %i", ptr, length);
         addCodecSpecificData(ptr, length);
 
         ptr += length;
@@ -517,11 +746,14 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     ALOGV("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
 
+	ALOGE("PATCH:OMXCodec:configureCodec[%s]", mComponentName);
     if (!(mFlags & kIgnoreCodecSpecificData)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s]  !(mFlags & kIgnoreCodecSpecificData", mComponentName);
         uint32_t type;
         const void *data;
         size_t size;
         if (meta->findData(kKeyESDS, &type, &data, &size)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyESDS)", mComponentName);
             ESDS esds((const char *)data, size);
             CHECK_EQ(esds.InitCheck(), (status_t)OK);
 
@@ -530,9 +762,17 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             esds.getCodecSpecificInfo(
                     &codec_specific_data, &codec_specific_data_size);
 
+            const char * mime_type;
+            meta->findCString(kKeyMIMEType, &mime_type);
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findCString(kKeyMIMEType = %s)", mComponentName, mime_type);
+            if (strncmp(mime_type,
+                        MEDIA_MIMETYPE_AUDIO_MPEG,
+                        strlen(MEDIA_MIMETYPE_AUDIO_MPEG))) {
             addCodecSpecificData(
                     codec_specific_data, codec_specific_data_size);
+            }
         } else if (meta->findData(kKeyAVCC, &type, &data, &size)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyAVCC)", mComponentName);
             // Parse the AVCDecoderConfigurationRecord
 
             unsigned profile, level;
@@ -543,10 +783,17 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
                 return err;
             }
 
+#ifdef QCOM_BSP_LEGACY
+	        ExtendedUtils::setArbitraryModeIfInterlaced((const uint8_t *)data, meta);
+#endif
+
             CODEC_LOGI(
                     "AVC profile = %u (%s), level = %u",
                     profile, AVCProfileToString(profile), level);
+			ALOGE("PATCH:OMXCodec:configureCodec findData(kKeyAVCC) AVC profile = %u (%s), level = %u", profile, AVCProfileToString(profile), level);			
+        
         } else if (meta->findData(kKeyHVCC, &type, &data, &size)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyHVCC)", mComponentName);	
             // Parse the HEVCDecoderConfigurationRecord
 
             unsigned profile, level;
@@ -561,39 +808,65 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
                     "HEVC profile = %u , level = %u",
                     profile, level);
         } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyVorbisInfo)", mComponentName);
             addCodecSpecificData(data, size);
 
             CHECK(meta->findData(kKeyVorbisBooks, &type, &data, &size));
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyVorbisBooks)", mComponentName);
             addCodecSpecificData(data, size);
         } else if (meta->findData(kKeyOpusHeader, &type, &data, &size)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyOpusHeader)", mComponentName);
             addCodecSpecificData(data, size);
 
             CHECK(meta->findData(kKeyOpusCodecDelay, &type, &data, &size));
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyOpusCodecDelay)", mComponentName);
             addCodecSpecificData(data, size);
             CHECK(meta->findData(kKeyOpusSeekPreRoll, &type, &data, &size));
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyOpusSeekPreRoll)", mComponentName);
             addCodecSpecificData(data, size);
+        } else if (meta->findData(kKeyRawCodecSpecificData, &type, &data, &size)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] findData(kKeyRawCodecSpecificData) found kKeyRawCodecSpecificData of size %d\n", mComponentName, size);
+            ALOGV("OMXCodec::configureCodec found kKeyRawCodecSpecificData of size %d\n", size);
+            addCodecSpecificData(data, size);
+#ifdef ENABLE_AV_ENHANCEMENTS
+        } else {
+            ExtendedCodec::getRawCodecSpecificData(meta, data, size);
+            if (size) {
+                addCodecSpecificData(data, size);
+            }
+#endif
         }
     }
 
+    if (!strncasecmp(mMIME, "audio/", 6)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ = %s", mComponentName, mMIME);
+            
+
     int32_t bitRate = 0;
     if (mIsEncoder) {
         CHECK(meta->findInt32(kKeyBitRate, &bitRate));
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ mIsEncoder bitrate= %i", mComponentName, bitRate);
     }
     if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB, mMIME)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_AMR_NB", mComponentName);
         setAMRFormat(false /* isWAMR */, bitRate);
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB, mMIME)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_AMR_WB", mComponentName);
         setAMRFormat(true /* isWAMR */, bitRate);
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AAC, mMIME)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_AAC", mComponentName);
         int32_t numChannels, sampleRate, aacProfile;
         CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
         CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
 
         if (!meta->findInt32(kKeyAACProfile, &aacProfile)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ findInt32(kKeyAACProfile)", mComponentName);
             aacProfile = OMX_AUDIO_AACObjectNull;
         }
 
         int32_t isADTS;
         if (!meta->findInt32(kKeyIsADTS, &isADTS)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/  findInt32(kKeyIsADTS) NOT", mComponentName);
             isADTS = false;
         }
 
@@ -602,10 +875,23 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             CODEC_LOGE("setAACFormat() failed (err = %d)", err);
             return err;
         }
+
+#ifdef ENABLE_AV_ENHANCEMENTS
+        uint32_t type;
+        const void *data;
+        size_t size;
+
+        if (meta->findData(kKeyAacCodecSpecificData, &type, &data, &size)) {
+            ALOGV("OMXCodec:: configureCodec[%s] found kKeyAacCodecSpecificData of size %d\n", mComponentName, size);
+            addCodecSpecificData(data, size);
+        }
+#endif
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG, mMIME)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_MPEG", mComponentName);
         int32_t numChannels, sampleRate;
         if (meta->findInt32(kKeyChannelCount, &numChannels)
                 && meta->findInt32(kKeySampleRate, &sampleRate)) {
+				ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ findInt32(kKeyChannelCount) && findInt32(kKeyChannelCount)", mComponentName);
             // Since we did not always check for these, leave them optional
             // and have the decoder figure it all out.
             setRawAudioFormat(
@@ -614,6 +900,7 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
                     numChannels);
         }
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AC3, mMIME)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_AC3", mComponentName);
         int32_t numChannels;
         int32_t sampleRate;
         CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
@@ -628,12 +915,13 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             || !strcasecmp(MEDIA_MIMETYPE_AUDIO_G711_MLAW, mMIME)) {
         // These are PCM-like formats with a fixed sample rate but
         // a variable number of channels.
-
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_G711_ALAW", mComponentName);
         int32_t numChannels;
         CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
 
         setG711Format(numChannels);
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_RAW, mMIME)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ MEDIA_MIMETYPE_AUDIO_RAW", mComponentName);
         CHECK(!mIsEncoder);
 
         int32_t numChannels, sampleRate;
@@ -641,31 +929,73 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
 
         setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+    } else {
+        if (mIsEncoder && !mIsVideo) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ mIsEncoder && !mIsVideo", mComponentName);
+            int32_t numChannels, sampleRate;
+            CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
+            CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+            setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
     }
+        status_t err = OK;
 
-    if (!strncasecmp(mMIME, "video/", 6)) {
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setAudioFormat(
+                    meta, mMIME, mOMX, mNode, mIsEncoder);
+        }
+#endif
+        if (!strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ FFMPEGSoftCodec", mComponentName);
+            err = FFMPEGSoftCodec::setAudioFormat(
+                    meta, mMIME, mOMX, mNode, mIsEncoder);
+        }
+        if (OK != err) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] audio/ ERROR", mComponentName);
+            return err;
+        }
+    }
+    }
 
+    if (!strncasecmp(mMIME, "video/", 6)) {
+	ALOGE("PATCH:OMXCodec:configureCodec[%s] video/", mComponentName);
         if (mIsEncoder) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] mIsEncoder  video/ setVideoInputFormat", mComponentName);
             setVideoInputFormat(mMIME, meta);
         } else {
-            status_t err = setVideoOutputFormat(
-                    mMIME, meta);
-
+#ifdef ENABLE_AV_ENHANCEMENTS
+            ExtendedCodec::configureVideoDecoder(
+                    meta, mMIME, mOMX, mFlags, mNode, mComponentName);
+#endif
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ setVideoOutputFormat", mComponentName);
+            status_t err = setVideoOutputFormat(mMIME, meta);
             if (err != OK) {
+				ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ setVideoOutputFormat ERROR", mComponentName);
                 return err;
             }
+#ifdef ENABLE_AV_ENHANCEMENTS
+            ExtendedCodec::enableSmoothStreaming(
+                    mOMX, mNode, &mInSmoothStreamingMode, mComponentName);
+#endif
         }
     }
 
     int32_t maxInputSize;
     if (meta->findInt32(kKeyMaxInputSize, &maxInputSize)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ setVideoOutputFormat findInt32(kKeyMaxInputSize) = %i", mComponentName, maxInputSize);
         setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);
-    }
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ setMinBufferSize = %i, port = %u", mComponentName, maxInputSize, kPortIndexInput);
+    }//else if (!strncmp(mComponentName, "OMX.brcm.video.h264.hw.decoder", 30)) {
+     //   setMinBufferSize(kPortIndexInput, (1080 * 720 * 3) / 2);
+	//	ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ setMinBufferSize for BRCM, port = %u", mComponentName, kPortIndexInput);
+   // }
 
+	ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ initOutputFormat", mComponentName);
     initOutputFormat(meta);
 
     if ((mFlags & kClientNeedsFramebuffer)
             && !strncmp(mComponentName, "OMX.SEC.", 8)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ OMX.SEC.", mComponentName);		
         // This appears to no longer be needed???
 
         OMX_INDEXTYPE index;
@@ -697,8 +1027,10 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         && !mIsEncoder
         && !strncasecmp(mMIME, "video/", 6)
         && !strncmp(mComponentName, "OMX.", 4)) {
+		ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ initNativeWindow", mComponentName);		
         status_t err = initNativeWindow();
         if (err != OK) {
+			ALOGE("PATCH:OMXCodec:configureCodec[%s] video/ initNativeWindow ERROR", mComponentName);	
             return err;
         }
     }
@@ -707,27 +1039,33 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
 }
 
 void OMXCodec::setMinBufferSize(OMX_U32 portIndex, OMX_U32 size) {
+	ALOGE("PATCH:OMXCodec:setMinBufferSize port = %u", portIndex);
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+	ALOGE("PATCH:OMXCodec:setMinBufferSize port = %u getParameter OMX_IndexParamPortDefinition", portIndex);		
     CHECK_EQ(err, (status_t)OK);
 
     if ((portIndex == kPortIndexInput && (mQuirks & kInputBufferSizesAreBogus))
         || (def.nBufferSize < size)) {
         def.nBufferSize = size;
+		ALOGE("PATCH:OMXCodec:setMinBufferSize port = %u def.nBufferSize = size = %i", portIndex, size);
     }
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+		ALOGE("PATCH:OMXCodec:setMinBufferSize port = %u setParameter OMX_IndexParamPortDefinition", portIndex);	
     CHECK_EQ(err, (status_t)OK);
 
     err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGE("PATCH:OMXCodec:setMinBufferSize port = %u getParameter OMX_IndexParamPortDefinition for check", portIndex);
+
     // Make sure the setting actually stuck.
     if (portIndex == kPortIndexInput
             && (mQuirks & kInputBufferSizesAreBogus)) {
@@ -741,6 +1079,7 @@ status_t OMXCodec::setVideoPortFormatType(
         OMX_U32 portIndex,
         OMX_VIDEO_CODINGTYPE compressionFormat,
         OMX_COLOR_FORMATTYPE colorFormat) {
+	ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u, compres = %i, color = %i ", portIndex, compressionFormat, colorFormat);		
     OMX_VIDEO_PARAM_PORTFORMATTYPE format;
     InitOMXParams(&format);
     format.nPortIndex = portIndex;
@@ -753,8 +1092,10 @@ status_t OMXCodec::setVideoPortFormatType(
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
+		ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u getParameter OMX_IndexParamVideoPortFormat", portIndex);		
 
         if (err != OK) {
+			ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u getParameter OMX_IndexParamVideoPortFormat ERROR", portIndex);	
             return err;
         }
 
@@ -767,8 +1108,13 @@ status_t OMXCodec::setVideoPortFormatType(
              index, format.eCompressionFormat, format.eColorFormat);
 #endif
 
+	ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u compressionFormat = %i, format.eCompressionForma(from codec) = %i", portIndex, compressionFormat, format.eCompressionFormat);	
+	ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u colorFormat = %i, colormat.eColorFormat(from codec) = %i", portIndex, colorFormat, format.eColorFormat);	
+
         if (format.eCompressionFormat == compressionFormat
                 && format.eColorFormat == colorFormat) {
+			ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u compressionFormat = %i, format.eCompressionForma(from codec) = %i FOUND", portIndex, compressionFormat, format.eCompressionFormat);		
+            ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u colorFormat = %i, colormat.eColorFormat(from codec) = %i FOUND", portIndex, colorFormat, format.eColorFormat);	
             found = true;
             break;
         }
@@ -777,27 +1123,38 @@ status_t OMXCodec::setVideoPortFormatType(
         if (index >= kMaxColorFormatSupported) {
             CODEC_LOGE("color format %d or compression format %d is not supported",
                 colorFormat, compressionFormat);
+			ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u compressionFormat = %i, format.eCompressionForma(from codec) = %i NOT FOUND", portIndex, compressionFormat, format.eCompressionFormat);		
+            ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u colorFormat = %i, colormat.eColorFormat(from codec) = %i NOT FOUND", portIndex, colorFormat, format.eColorFormat);		
             return UNKNOWN_ERROR;
         }
     }
 
     if (!found) {
+		ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u not found a match.", portIndex);		   
+        CODEC_LOGE("not found a match.");
         return UNKNOWN_ERROR;
     }
 
     CODEC_LOGV("found a match.");
+	ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u found a match.", portIndex);	
     status_t err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
-
+	ALOGE("PATCH:OMXCodec:setVideoPortFormatType port = %u setParameter OMX_IndexParamVideoPortFormat", portIndex);	
     return err;
 }
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+#define ALIGN(x, a) (((x) + (a) - 1) & ~((a) - 1))
+#endif
+
 static size_t getFrameSize(
         OMX_COLOR_FORMATTYPE colorFormat, int32_t width, int32_t height) {
+	ALOGE("PATCH:OMXCodec:getFrameSize colorFormat = %i, wh = %i, hg = %i", colorFormat, width, height);		
     switch (colorFormat) {
         case OMX_COLOR_FormatYCbYCr:
         case OMX_COLOR_FormatCbYCrY:
+			ALOGE("PATCH:OMXCodec:getFrameSize colorFormat = %i sizeframe = %i", colorFormat, width * height * 2);
             return width * height * 2;
 
         case OMX_COLOR_FormatYUV420Planar:
@@ -812,24 +1169,42 @@ static size_t getFrameSize(
         * this part in the future
         */
         case OMX_COLOR_FormatAndroidOpaque:
+#ifdef USE_SAMSUNG_COLORFORMAT
+        case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
+        case OMX_SEC_COLOR_FormatNV12LPhysicalAddress:
+#endif
+			ALOGE("PATCH:OMXCodec:getFrameSize colorFormat = %i sizeframe = %i", colorFormat, (width * height * 3) / 2);
             return (width * height * 3) / 2;
-
+#ifdef USE_SAMSUNG_COLORFORMAT
+
+        case OMX_SEC_COLOR_FormatNV12LVirtualAddress:
+            return ALIGN((ALIGN(width, 16) * ALIGN(height, 16)), 2048) + ALIGN((ALIGN(width, 16) * ALIGN(height >> 1, 8)), 2048);
+        case OMX_SEC_COLOR_FormatNV12Tiled:
+            static unsigned int frameBufferYSise = calc_plane(width, height);
+            static unsigned int frameBufferUVSise = calc_plane(width, height >> 1);
+            return (frameBufferYSise + frameBufferUVSise);
+#endif
         default:
+			ALOGE("PATCH:OMXCodec:getFrameSize colorFormat = %i Unsupported", colorFormat);
             CHECK(!"Should not be here. Unsupported color format.");
             break;
     }
-    return 0;
 }
 
 status_t OMXCodec::findTargetColorFormat(
         const sp<MetaData>& meta, OMX_COLOR_FORMATTYPE *colorFormat) {
     ALOGV("findTargetColorFormat");
+	ALOGE("PATCH:OMXCodec:findTargetColorFormat kPortIndexInput = %u, color = %i", kPortIndexInput, colorFormat);
     CHECK(mIsEncoder);
 
     *colorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+	ALOGE("PATCH:OMXCodec:findTargetColorFormat kPortIndexInput = %u, DEFAULT SET OMX_COLOR_FormatYUV420SemiPlanar color = %i", kPortIndexInput, colorFormat);
     int32_t targetColorFormat;
     if (meta->findInt32(kKeyColorFormat, &targetColorFormat)) {
+		ALOGE("PATCH:OMXCodec:findTargetColorFormat kPortIndexInput = %u, findInt32(kKeyColorFormat)", kPortIndexInput);
+    
         *colorFormat = (OMX_COLOR_FORMATTYPE) targetColorFormat;
+		ALOGE("PATCH:OMXCodec:findTargetColorFormat kPortIndexInput = %u, SET colorform = %i", kPortIndexInput, colorFormat);
     }
 
     // Check whether the target color format is supported.
@@ -839,7 +1214,7 @@ status_t OMXCodec::findTargetColorFormat(
 status_t OMXCodec::isColorFormatSupported(
         OMX_COLOR_FORMATTYPE colorFormat, int portIndex) {
     ALOGV("isColorFormatSupported: %d", static_cast<int>(colorFormat));
-
+	ALOGE("PATCH:OMXCodec:isColorFormatSupported PortIndex = %u, SET colorform = %i", portIndex, colorFormat);
     // Enumerate all the color formats supported by
     // the omx component to see whether the given
     // color format is supported.
@@ -852,19 +1227,23 @@ status_t OMXCodec::isColorFormatSupported(
         if (OMX_ErrorNone != mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &portFormat, sizeof(portFormat))) {
+				ALOGE("PATCH:OMXCodec:isColorFormatSupported PortIndex = %u, getParameter OMX_IndexParamVideoPortFormat", portIndex);
             break;
         }
         // Make sure that omx component does not overwrite
         // the incremented index (bug 2897413).
         CHECK_EQ(index, portFormat.nIndex);
+		ALOGE("PATCH:OMXCodec:isColorFormatSupported PortIndex = %u, portFormat.eColorFormat(from codec) = %i, colorFormat = %i", portIndex, portFormat.eColorFormat, colorFormat);
         if (portFormat.eColorFormat == colorFormat) {
             CODEC_LOGV("Found supported color format: %d", portFormat.eColorFormat);
+			ALOGE("PATCH:OMXCodec:isColorFormatSupported PortIndex = %u, FOUND", portIndex);
             return OK;  // colorFormat is supported!
         }
         ++index;
         portFormat.nIndex = index;
 
         if (index >= kMaxColorFormatSupported) {
+			ALOGE("PATCH:OMXCodec:isColorFormatSupported PortIndex = %u, NOT FOUND", portIndex);
             CODEC_LOGE("More than %u color formats are supported???", index);
             break;
         }
@@ -876,43 +1255,75 @@ status_t OMXCodec::isColorFormatSupported(
 
 void OMXCodec::setVideoInputFormat(
         const char *mime, const sp<MetaData>& meta) {
-
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u", kPortIndexInput);
     int32_t width, height, frameRate, bitRate, stride, sliceHeight;
     bool success = meta->findInt32(kKeyWidth, &width);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findInt32(kKeyWidth) = %i", kPortIndexInput, width);
     success = success && meta->findInt32(kKeyHeight, &height);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findInt32(kKeyHeight) = %i", kPortIndexInput, height);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findInt32(kKeyFrameRate) = %i", kPortIndexInput, frameRate);
     success = success && meta->findInt32(kKeyBitRate, &bitRate);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findInt32(kKeyBitRate) = %i", kPortIndexInput, bitRate);
     success = success && meta->findInt32(kKeyStride, &stride);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findInt32(kKeyStride) = %i", kPortIndexInput, stride);
     success = success && meta->findInt32(kKeySliceHeight, &sliceHeight);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findInt32(kKeySliceHeight) = %i", kPortIndexInput, sliceHeight);
     CHECK(success);
     CHECK(stride != 0);
 
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u MEDIA_MIMETYPE_VIDEO_AVC", kPortIndexInput);
         compressionFormat = OMX_VIDEO_CodingAVC;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u MEDIA_MIMETYPE_VIDEO_HEVC", kPortIndexInput);
         compressionFormat = OMX_VIDEO_CodingHEVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
+            !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4_DP, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u MEDIA_MIMETYPE_VIDEO_MPEG4", kPortIndexInput);		
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u MEDIA_MIMETYPE_VIDEO_H263", kPortIndexInput);
         compressionFormat = OMX_VIDEO_CodingH263;
     } else {
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u ERROR_UNSUPPORTED", kPortIndexInput);
+        status_t err = ERROR_UNSUPPORTED;
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setVideoFormat(meta, mime, &compressionFormat);
+        }
+#endif
+        if (err != OK && !strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
+			ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u FFMPEGSoftCodec::setVideoFormat", kPortIndexInput);
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    meta, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
         ALOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
     }
+    }
 
     OMX_COLOR_FORMATTYPE colorFormat;
     CHECK_EQ((status_t)OK, findTargetColorFormat(meta, &colorFormat));
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u findTargetColorFormat", kPortIndexInput);
+            
     status_t err;
     OMX_PARAM_PORTDEFINITIONTYPE def;
     OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
 
     //////////////////////// Input port /////////////////////////
+	
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat Input port kPortIndexInput = %u", kPortIndexInput);
+	
     CHECK_EQ(setVideoPortFormatType(
             kPortIndexInput, OMX_VIDEO_CodingUnused,
             colorFormat), (status_t)OK);
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u setVideoPortFormatType colorfomat = %i", kPortIndexInput, colorFormat);		
+
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexInput;
 
@@ -920,9 +1331,13 @@ void OMXCodec::setVideoInputFormat(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u getParameter OMX_IndexParamPortDefinition", kPortIndexInput);		
+
     def.nBufferSize = getFrameSize(colorFormat,
             stride > 0? stride: -stride, sliceHeight);
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u getFrameSize = %i", kPortIndexInput, def.nBufferSize);		
+		
     CHECK_EQ((int)def.eDomain, (int)OMX_PortDomainVideo);
 
     video_def->nFrameWidth = width;
@@ -937,16 +1352,26 @@ void OMXCodec::setVideoInputFormat(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexInput = %u setParameter OMX_IndexParamPortDefinition", kPortIndexInput);
+
     //////////////////////// Output port /////////////////////////
+	
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat Output port kPortIndexOutput = %u", kPortIndexOutput);
+	
     CHECK_EQ(setVideoPortFormatType(
             kPortIndexOutput, compressionFormat, OMX_COLOR_FormatUnused),
             (status_t)OK);
+			
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u setVideoPortFormatType compressionFormat = %i", kPortIndexOutput, compressionFormat);
+		
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
     err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u getParameter OMX_IndexParamPortDefinition", kPortIndexOutput);		
+
     CHECK_EQ(err, (status_t)OK);
     CHECK_EQ((int)def.eDomain, (int)OMX_PortDomainVideo);
 
@@ -956,40 +1381,63 @@ void OMXCodec::setVideoInputFormat(
     video_def->nBitrate = bitRate;  // Q16 format
     video_def->eCompressionFormat = compressionFormat;
     video_def->eColorFormat = OMX_COLOR_FormatUnused;
+	
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u width = %i", kPortIndexOutput, width);		
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u height = %i", kPortIndexOutput, height);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u bitRate = %i", kPortIndexOutput, bitRate);
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u compressionFormat = %i", kPortIndexOutput, compressionFormat);
+	
     if (mQuirks & kRequiresLargerEncoderOutputBuffer) {
         // Increases the output buffer size
         def.nBufferSize = ((def.nBufferSize * 3) >> 1);
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u (mQuirks & kRequiresLargerEncoderOutputBuffer) def.nBufferSize = %i", kPortIndexOutput, def.nBufferSize);
     }
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u setParameter OMX_IndexParamPortDefinition", kPortIndexOutput);
+    
     /////////////////// Codec-specific ////////////////////////
     switch (compressionFormat) {
         case OMX_VIDEO_CodingMPEG4:
         {
+			ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u Codec-specific setupMPEG4EncoderParameters", kPortIndexOutput);
             CHECK_EQ(setupMPEG4EncoderParameters(meta), (status_t)OK);
             break;
         }
 
         case OMX_VIDEO_CodingH263:
+		ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u Codec-specific setupH263EncoderParameters", kPortIndexOutput);
             CHECK_EQ(setupH263EncoderParameters(meta), (status_t)OK);
             break;
 
         case OMX_VIDEO_CodingAVC:
         {
+			ALOGE("PATCH:OMXCodec:setVideoInputFormat kPortIndexOutput = %u Codec-specific OMX_VIDEO_CodingAVC", kPortIndexOutput);
             CHECK_EQ(setupAVCEncoderParameters(meta), (status_t)OK);
             break;
         }
 
         default:
+        {
+#ifdef ENABLE_AV_ENHANCEMENTS
+            bool retVal = ExtendedCodec::checkIfCompressionHEVC((int)compressionFormat);
+            if (retVal) {
+                CHECK_EQ(ExtendedCodec::setupHEVCEncoderParameters(meta, mOMX,
+                         mNode, mComponentName, kPortIndexOutput, this), (status_t)OK);
+            } else {
             CHECK(!"Support for this compressionFormat to be implemented.");
+            }
+#endif
             break;
     }
+    }
 }
 
 static OMX_U32 setPFramesSpacing(int32_t iFramesInterval, int32_t frameRate) {
+	ALOGE("PATCH:OMXCodec:setPFramesSpacing");	
     if (iFramesInterval < 0) {
         return 0xFFFFFFFF;
     } else if (iFramesInterval == 0) {
@@ -1000,28 +1448,34 @@ static OMX_U32 setPFramesSpacing(int32_t iFramesInterval, int32_t frameRate) {
 }
 
 status_t OMXCodec::setupErrorCorrectionParameters() {
+	ALOGE("PATCH:OMXCodec:setupErrorCorrectionParameters kPortIndexOutput = %u", kPortIndexOutput);
     OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE errorCorrectionType;
     InitOMXParams(&errorCorrectionType);
     errorCorrectionType.nPortIndex = kPortIndexOutput;
 
+	ALOGE("PATCH:OMXCodec:setupErrorCorrectionParameters kPortIndexOutput = %u, getParameter OMX_IndexParamVideoErrorCorrection", kPortIndexOutput);
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoErrorCorrection,
             &errorCorrectionType, sizeof(errorCorrectionType));
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:setupErrorCorrectionParameters kPortIndexOutput = %u, getParameter OMX_IndexParamVideoErrorCorrection ERROR", kPortIndexOutput);
         ALOGW("Error correction param query is not supported");
         return OK;  // Optional feature. Ignore this failure
     }
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
-    errorCorrectionType.bEnableResync = OMX_TRUE;
-    errorCorrectionType.nResynchMarkerSpacing = 256;
+    errorCorrectionType.bEnableResync = OMX_FALSE;
+    errorCorrectionType.nResynchMarkerSpacing = 0;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
+	ALOGE("PATCH:OMXCodec:setupErrorCorrectionParameters kPortIndexOutput = %u, setParameter OMX_IndexParamVideoErrorCorrection", kPortIndexOutput);
+
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoErrorCorrection,
             &errorCorrectionType, sizeof(errorCorrectionType));
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:setupErrorCorrectionParameters kPortIndexOutput = %u, setParameter OMX_IndexParamVideoErrorCorrection ERROR", kPortIndexOutput);
         ALOGW("Error correction param configuration is not supported");
     }
 
@@ -1030,10 +1484,14 @@ status_t OMXCodec::setupErrorCorrectionParameters() {
 }
 
 status_t OMXCodec::setupBitRate(int32_t bitRate) {
+	ALOGE("PATCH:OMXCodec:setupBitRate kPortIndexOutput = %u, bitRate = %i", kPortIndexOutput, bitRate);
+        
     OMX_VIDEO_PARAM_BITRATETYPE bitrateType;
     InitOMXParams(&bitrateType);
     bitrateType.nPortIndex = kPortIndexOutput;
 
+	ALOGE("PATCH:OMXCodec:setupBitRate kPortIndexOutput = %u, getParameter OMX_IndexParamVideoBitrate", kPortIndexOutput);
+
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoBitrate,
             &bitrateType, sizeof(bitrateType));
@@ -1042,6 +1500,8 @@ status_t OMXCodec::setupBitRate(int32_t bitRate) {
     bitrateType.eControlRate = OMX_Video_ControlRateVariable;
     bitrateType.nTargetBitrate = bitRate;
 
+	
+	ALOGE("PATCH:OMXCodec:setupBitRate kPortIndexOutput = %u, setParameter OMX_IndexParamVideoBitrate", kPortIndexOutput);
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoBitrate,
             &bitrateType, sizeof(bitrateType));
@@ -1053,6 +1513,7 @@ status_t OMXCodec::getVideoProfileLevel(
         const sp<MetaData>& meta,
         const CodecProfileLevel& defaultProfileLevel,
         CodecProfileLevel &profileLevel) {
+	ALOGE("PATCH:OMXCodec:getVideoProfileLevel kPortIndexOutput = %u", kPortIndexOutput);		
     CODEC_LOGV("Default profile: %ld, level %ld",
             defaultProfileLevel.mProfile, defaultProfileLevel.mLevel);
 
@@ -1099,6 +1560,7 @@ status_t OMXCodec::getVideoProfileLevel(
 }
 
 status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
+	ALOGE("PATCH:OMXCodec:setupH263EncoderParameters kPortIndexOutput = %u", kPortIndexOutput);
     int32_t iFramesInterval, frameRate, bitRate;
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
@@ -1146,6 +1608,7 @@ status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
 }
 
 status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
+	ALOGE("PATCH:OMXCodec:setupMPEG4EncoderParameters kPortIndexOutput = %u", kPortIndexOutput);
     int32_t iFramesInterval, frameRate, bitRate;
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
@@ -1198,6 +1661,7 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
 }
 
 status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
+	ALOGE("PATCH:OMXCodec:setupAVCEncoderParameters kPortIndexOutput = %u", kPortIndexOutput);
     int32_t iFramesInterval, frameRate, bitRate;
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
@@ -1273,7 +1737,7 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
 
 status_t OMXCodec::setVideoOutputFormat(
         const char *mime, const sp<MetaData>& meta) {
-
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s]", mComponentName);
     int32_t width, height;
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
@@ -1283,28 +1747,53 @@ status_t OMXCodec::setVideoOutputFormat(
 
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingAVC", mComponentName);
         compressionFormat = OMX_VIDEO_CodingAVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
+            !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4_DP, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingMPEG4", mComponentName);		
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingHEVC", mComponentName);	
         compressionFormat = OMX_VIDEO_CodingHEVC;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingH263", mComponentName);
         compressionFormat = OMX_VIDEO_CodingH263;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP8, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingVP8", mComponentName);
         compressionFormat = OMX_VIDEO_CodingVP8;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP9, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingVP9", mComponentName);
         compressionFormat = OMX_VIDEO_CodingVP9;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] OMX_VIDEO_CodingMPEG2", mComponentName);
         compressionFormat = OMX_VIDEO_CodingMPEG2;
     } else {
+        status_t err = ERROR_UNSUPPORTED;
+#ifdef ENABLE_AV_ENHANCEMENTS
+        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
+            err = ExtendedCodec::setVideoFormat(meta, mime, &compressionFormat);
+        }
+#endif
+        if(err != OK && !strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] FFMPEGSoftCodec::setVideoFormat", mComponentName);
+            err = FFMPEGSoftCodec::setVideoFormat(
+                    meta, mMIME, mOMX, mNode, mIsEncoder, &compressionFormat);
+        }
+        if (err != OK) {
         ALOGE("Not a supported video mime type: %s", mime);
-        CHECK(!"Should not be here. Not a supported video mime type.");
+            return err;
+    }
     }
+	
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] setVideoPortFormatType", mComponentName);
 
     status_t err = setVideoPortFormatType(
             kPortIndexInput, compressionFormat, OMX_COLOR_FormatUnused);
 
+
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] setVideoPortFormatType ERROR", mComponentName);
         return err;
     }
 
@@ -1315,37 +1804,89 @@ status_t OMXCodec::setVideoOutputFormat(
         format.nPortIndex = kPortIndexOutput;
         format.nIndex = 0;
 
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] getParameter OMX_IndexParamVideoPortFormat", mComponentName);
+
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
+				
         CHECK_EQ(err, (status_t)OK);
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+#if 0
+        CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
+               || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
+               || format.eColorFormat == OMX_COLOR_FormatCbYCrY
+               || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+               || format.eColorFormat == OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
+#ifdef USE_SAMSUNG_COLORFORMAT
+               || format.eColorFormat == OMX_SEC_COLOR_FormatNV12TPhysicalAddress
+               || format.eColorFormat == OMX_SEC_COLOR_FormatNV12Tiled
+#endif
+               );
+
+#ifdef USE_SAMSUNG_COLORFORMAT
+        if (!strncmp("OMX.SEC.", mComponentName, 8)) {
+            if (mNativeWindow == NULL)
+                format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            else
+                format.eColorFormat = (OMX_COLOR_FORMATTYPE)OMX_SEC_COLOR_FormatNV12Tiled;
+        }
+#endif
+
+#endif
+
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] format.eColorFormat(from codec) = %i", mComponentName, format.eColorFormat);
+		
         int32_t colorFormat;
+		
+		if (!strncmp("OMX.brcm.video.h264.hw.decoder", mComponentName, 30)) {
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat = %i FOUND BRCM set 19", mComponentName, colorFormat);	
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+		}
+		
         if (meta->findInt32(kKeyColorFormat, &colorFormat)
                 && colorFormat != OMX_COLOR_FormatUnused
                 && colorFormat != format.eColorFormat) {
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat = %i", mComponentName, colorFormat);		
+					
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat(%i) != format.eColorFormat (%i)", mComponentName, colorFormat, format.eColorFormat);		
 
             while (OMX_ErrorNoMore != err) {
                 format.nIndex++;
+				ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] port index = %i", mComponentName, format.nIndex);
+				ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) colorFormat(%i) != format.eColorFormat (%i)", mComponentName, colorFormat, format.eColorFormat);
+                
                 err = mOMX->getParameter(
                         mNode, OMX_IndexParamVideoPortFormat,
                             &format, sizeof(format));
+							
                 if (format.eColorFormat == colorFormat) {
+					ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat(%i) == format.eColorFormat (%i)", mComponentName, colorFormat, format.eColorFormat);
                     break;
                 }
+				
+				if(err == 0x80001005){
+					ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) colorFormat(%i) != format.eColorFormat (%i) OMX_ErrorNoMore", mComponentName, colorFormat, format.eColorFormat);
+					err = OMX_ErrorNoMore;
+				}
             }
             if (format.eColorFormat != colorFormat) {
+				ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat(%i) != format.eColorFormat (%i) not supported", mComponentName, colorFormat, format.eColorFormat);
                 CODEC_LOGE("Color format %d is not supported", colorFormat);
                 return ERROR_UNSUPPORTED;
             }
         }
 
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] setParameter OMX_IndexParamVideoPortFormat", mComponentName);
+                
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
 
         if (err != OK) {
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] setParameter OMX_IndexParamVideoPortFormat ERROR", mComponentName);
             return err;
         }
     }
@@ -1355,18 +1896,32 @@ status_t OMXCodec::setVideoOutputFormat(
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexInput;
 
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] ", mComponentName, kPortIndexInput);
+            
     OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
 
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] getParameter OMX_IndexParamPortDefinition", mComponentName, kPortIndexInput);
+
     err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] video_def->eCompressionFormat = %i", mComponentName, kPortIndexInput, video_def->eCompressionFormat);
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] video_def->eColorFormat = %i", mComponentName, kPortIndexInput, video_def->eColorFormat);
+	
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
-    const size_t X = 64 * 1024;
+//#ifdef USE_SAMSUNG_COLORFORMAT
+    const size_t X = 64 * 8 * 1024;
+//#else
+//    const size_t X = 64 * 1024;
+//#endif
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] X = %i", mComponentName, kPortIndexInput, X);
     if (def.nBufferSize < X) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] def.nBufferSize = %i", mComponentName, kPortIndexInput, def.nBufferSize);
         def.nBufferSize = X;
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] def.nBufferSize < X = %i", mComponentName, kPortIndexInput, def.nBufferSize);
     }
 #endif
 
@@ -1378,31 +1933,56 @@ status_t OMXCodec::setVideoOutputFormat(
     video_def->eCompressionFormat = compressionFormat;
     video_def->eColorFormat = OMX_COLOR_FormatUnused;
 
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] video_def->nFrameWidth = %i", mComponentName, kPortIndexInput, video_def->nFrameWidth);
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] video_def->nFrameHeight = %i", mComponentName, kPortIndexInput, video_def->nFrameHeight);
+	
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] video_def->eCompressionFormat = %i", mComponentName, kPortIndexInput, video_def->eCompressionFormat);
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] video_def->eColorFormat = %i", mComponentName, kPortIndexInput, video_def->eColorFormat);
+	
+
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] setParameter OMX_IndexParamPortDefinition", mComponentName, kPortIndexInput);
+	
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] setParameter OMX_IndexParamPortDefinition ERROR", mComponentName, kPortIndexInput);
         return err;
     }
 
     ////////////////////////////////////////////////////////////////////////////
+    int32_t frameRate;
+    if (meta->findInt32(kKeyFrameRate, &frameRate)) {
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexInput = %u] PLAYER_STATS", mComponentName, kPortIndexInput);
+            PLAYER_STATS(setFrameRate, frameRate);
+    }
+    ////////////////////////////////////////////////////////////////////////////
 
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexOutput = %u] getParameter OMX_IndexParamPortDefinition", mComponentName, kPortIndexOutput);
+            
     err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			
     CHECK_EQ(err, (status_t)OK);
     CHECK_EQ((int)def.eDomain, (int)OMX_PortDomainVideo);
 
 #if 0
     def.nBufferSize =
         (((width + 15) & -16) * ((height + 15) & -16) * 3) / 2;  // YUV420
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexOutput = %u] def.nBufferSize = %i", mComponentName, kPortIndexOutput, def.nBufferSize);
+    	
 #endif
 
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
 
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexOutput = %u] video_def->nFrameWidth = %i", mComponentName, kPortIndexOutput,  video_def->nFrameWidth);
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexOutput = %u] video_def->nFrameHeight = %i", mComponentName, kPortIndexOutput,  video_def->nFrameHeight);
+
+	ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s][kPortIndexOutput = %u] setParameter OMX_IndexParamPortDefinition", mComponentName, kPortIndexOutput);
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -1441,10 +2021,16 @@ OMXCodec::OMXCodec(
       mLeftOverBuffer(NULL),
       mPaused(false),
       mNativeWindow(
-              (!strncmp(componentName, "OMX.google.", 11))
-                        ? NULL : nativeWindow) {
-    mPortStatus[kPortIndexInput] = ENABLED;
-    mPortStatus[kPortIndexOutput] = ENABLED;
+              (!strncmp(componentName, "OMX.google.", 11)
+              || !strncmp(componentName, "OMX.ffmpeg.", 11))
+                        ? NULL : nativeWindow),
+      mNumBFrames(0),
+      mInSmoothStreamingMode(false),
+      mOutputCropChanged(false) {
+    mPortStatus[kPortIndexInput] = ENABLING;
+    mPortStatus[kPortIndexOutput] = ENABLING;
+	
+	ALOGE("PATCH:OMXCodec:OMXCodec[%s] setComponentRole", mComponentName);
 
     setComponentRole();
 }
@@ -1453,6 +2039,8 @@ OMXCodec::OMXCodec(
 void OMXCodec::setComponentRole(
         const sp<IOMX> &omx, IOMX::node_id node, bool isEncoder,
         const char *mime) {
+			
+		ALOGE("PATCH:OMXCodec:setComponentRole");	
     struct MimeToRole {
         const char *mime;
         const char *decoderRole;
@@ -1470,6 +2058,10 @@ void OMXCodec::setComponentRole(
             "audio_decoder.amrnb", "audio_encoder.amrnb" },
         { MEDIA_MIMETYPE_AUDIO_AMR_WB,
             "audio_decoder.amrwb", "audio_encoder.amrwb" },
+#ifdef ENABLE_AV_ENHANCEMENTS
+        { MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS,
+            "audio_decoder.amrwbplus", "audio_encoder.amrwbplus" },
+#endif
         { MEDIA_MIMETYPE_AUDIO_AAC,
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
@@ -1480,12 +2072,26 @@ void OMXCodec::setComponentRole(
             "audio_decoder.g711mlaw", "audio_encoder.g711mlaw" },
         { MEDIA_MIMETYPE_AUDIO_G711_ALAW,
             "audio_decoder.g711alaw", "audio_encoder.g711alaw" },
+#ifdef ENABLE_AV_ENHANCEMENTS
+        { MEDIA_MIMETYPE_AUDIO_EVRC,
+            "audio_decoder.evrchw", "audio_encoder.evrc" },
+        { MEDIA_MIMETYPE_AUDIO_QCELP,
+            "audio_decoder,qcelp13Hw", "audio_encoder.qcelp13" },
+#ifdef DOLBY_UDC
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+            "audio_decoder.ac3", NULL },
+        { MEDIA_MIMETYPE_AUDIO_EAC3,
+            "audio_decoder.ec3", NULL },
+#endif // DOLBY_END
+#endif
         { MEDIA_MIMETYPE_VIDEO_AVC,
             "video_decoder.avc", "video_encoder.avc" },
         { MEDIA_MIMETYPE_VIDEO_HEVC,
             "video_decoder.hevc", "video_encoder.hevc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
+        { MEDIA_MIMETYPE_VIDEO_MPEG4_DP,
+            "video_decoder.mpeg4", NULL },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
         { MEDIA_MIMETYPE_VIDEO_VP8,
@@ -1515,6 +2121,14 @@ void OMXCodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
+        status_t err = ERROR_UNSUPPORTED;
+#ifdef ENABLE_AV_ENHANCEMENTS
+        err = ExtendedCodec::setSupportedRole(omx, node, isEncoder, mime);
+#endif
+        if (err != OK) {
+			ALOGE("PATCH:OMXCodec:setComponentRole FFMPEGSoftCodec::setSupportedRole");
+            err = FFMPEGSoftCodec::setSupportedRole(omx, node, isEncoder, mime);
+        }
         return;
     }
 
@@ -1531,11 +2145,14 @@ void OMXCodec::setComponentRole(
 
         roleParams.cRole[OMX_MAX_STRINGNAME_SIZE - 1] = '\0';
 
+		ALOGE("PATCH:OMXCodec:setComponentRole setParameter OMX_IndexParamStandardComponentRole");
+
         status_t err = omx->setParameter(
                 node, OMX_IndexParamStandardComponentRole,
                 &roleParams, sizeof(roleParams));
 
         if (err != OK) {
+			ALOGE("PATCH:OMXCodec:setComponentRole setParameter OMX_IndexParamStandardComponentRole ERROR");
             ALOGW("Failed to set standard component role '%s'.", role);
         }
     }
@@ -1546,6 +2163,7 @@ void OMXCodec::setComponentRole() {
 }
 
 OMXCodec::~OMXCodec() {
+	ALOGE("PATCH:OMXCodec:~OMXCodec");
     mSource.clear();
 
     CHECK(mState == LOADED || mState == ERROR || mState == LOADED_TO_IDLE);
@@ -1567,25 +2185,27 @@ OMXCodec::~OMXCodec() {
 
 status_t OMXCodec::init() {
     // mLock is held.
-
+	ALOGE("PATCH:OMXCodec:init");
     CHECK_EQ((int)mState, (int)LOADED);
 
     status_t err;
     if (!(mQuirks & kRequiresLoadedToIdleAfterAllocation)) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
+		ALOGE("PATCH:OMXCodec:init kRequiresLoadedToIdleAfterAllocation LOADED_TO_IDLE");
         setState(LOADED_TO_IDLE);
     }
 
     err = allocateBuffers();
     if (err != (status_t)OK) {
+		ALOGE("PATCH:OMXCodec:init allocateBuffers ERROR");
         return err;
     }
 
     if (mQuirks & kRequiresLoadedToIdleAfterAllocation) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
-
+		ALOGE("PATCH:OMXCodec:init kRequiresLoadedToIdleAfterAllocation LOADED_TO_IDLE 2");
         setState(LOADED_TO_IDLE);
     }
 
@@ -1601,22 +2221,34 @@ bool OMXCodec::isIntermediateState(State state) {
     return state == LOADED_TO_IDLE
         || state == IDLE_TO_EXECUTING
         || state == EXECUTING_TO_IDLE
+        || state == PAUSING
+        || state == FLUSHING
         || state == IDLE_TO_LOADED
         || state == RECONFIGURING;
 }
 
 status_t OMXCodec::allocateBuffers() {
+	ALOGE("PATCH:OMXCodec:allocateBuffers[kPortIndexInput = %u]", kPortIndexInput);
     status_t err = allocateBuffersOnPort(kPortIndexInput);
 
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:allocateBuffers ERROR");
         return err;
     }
 
+	ALOGE("PATCH:OMXCodec:allocateBuffers[kPortIndexOutput = %u]", kPortIndexOutput);
     return allocateBuffersOnPort(kPortIndexOutput);
 }
 
 status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
+	ALOGE("PATCH:OMXCodec:allocateBuffersOnPort[portIndex = %u]", portIndex);
+    const char* type = portIndex == kPortIndexInput ?
+                                    STATS_PROFILE_ALLOCATE_INPUT(mIsVideo) :
+                                    STATS_PROFILE_ALLOCATE_OUTPUT(mIsVideo);
+    ExtendedStats::AutoProfile autoProfile(type, mPlayerExtendedStats);
+
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
+		ALOGE("PATCH:OMXCodec:allocateBuffersOnPort[portIndex = %u] allocateOutputBuffersFromNativeWindow", portIndex);
         return allocateOutputBuffersFromNativeWindow();
     }
 
@@ -1628,8 +2260,10 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     status_t err = OK;
     if ((mFlags & kStoreMetaDataInVideoBuffers)
             && portIndex == kPortIndexInput) {
+		ALOGE("PATCH:OMXCodec:allocateBuffersOnPort[kPortIndexInput = %u] kStoreMetaDataInVideoBuffers storeMetaDataInBuffers", kPortIndexInput);		
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
         if (err != OK) {
+			ALOGE("PATCH:OMXCodec:allocateBuffersOnPort[kPortIndexInput = %u] kStoreMetaDataInVideoBuffers storeMetaDataInBuffers ERROR", kPortIndexInput);
             ALOGE("Storing meta data in video buffers is not supported");
             return err;
         }
@@ -1639,20 +2273,20 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
+	ALOGE("PATCH:OMXCodec:allocateBuffersOnPort[portIndex = %u] getParameter OMX_IndexParamPortDefinition", portIndex);
+
     err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:allocateBuffersOnPort[portIndex = %u] getParameter OMX_IndexParamPortDefinition ERROR", portIndex);
         return err;
     }
 
-    CODEC_LOGV("allocating %lu buffers of size %lu on %s port",
+    CODEC_LOGI("allocating %lu buffers of size %lu on %s port",
             def.nBufferCountActual, def.nBufferSize,
             portIndex == kPortIndexInput ? "input" : "output");
 
-    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
-        return BAD_VALUE;
-    }
     size_t totalSize = def.nBufferCountActual * def.nBufferSize;
     mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
 
@@ -1670,11 +2304,12 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                     || (mFlags & kUseSecureInputBuffers))) {
             if (mOMXLivesLocally) {
                 mem.clear();
-
+				ALOGE("PATCH:OMXCodec:allocateBuffersOnPort allocateBuffer");	
                 err = mOMX->allocateBuffer(
                         mNode, portIndex, def.nBufferSize, &buffer,
                         &info.mData);
             } else {
+				ALOGE("PATCH:OMXCodec:allocateBuffersOnPort allocateBufferWithBackup");	
                 err = mOMX->allocateBufferWithBackup(
                         mNode, portIndex, mem, &buffer);
             }
@@ -1682,15 +2317,17 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
             if (mOMXLivesLocally) {
                 mem.clear();
-
+				ALOGE("PATCH:OMXCodec:allocateBuffersOnPort allocateBuffer 2");	
                 err = mOMX->allocateBuffer(
                         mNode, portIndex, def.nBufferSize, &buffer,
                         &info.mData);
             } else {
+				ALOGE("PATCH:OMXCodec:allocateBuffersOnPort allocateBufferWithBackup 2");	
                 err = mOMX->allocateBufferWithBackup(
                         mNode, portIndex, mem, &buffer);
             }
         } else {
+			ALOGE("PATCH:OMXCodec:allocateBuffersOnPort useBuffer");
             err = mOMX->useBuffer(mNode, portIndex, mem, &buffer);
         }
 
@@ -1707,6 +2344,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         info.mStatus = OWNED_BY_US;
         info.mMem = mem;
         info.mMediaBuffer = NULL;
+        info.mOutputCropChanged = false;
 
         if (portIndex == kPortIndexOutput) {
             // Fail deferred MediaBuffer creation until FILL_BUFFER_DONE;
@@ -1722,7 +2360,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
         mPortBuffers[portIndex].push(info);
 
-        CODEC_LOGV("allocated buffer %p on %s port", buffer,
+        CODEC_LOGI("allocated buffer %p on %s port", buffer,
              portIndex == kPortIndexInput ? "input" : "output");
     }
 
@@ -1783,6 +2421,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 }
 
 status_t OMXCodec::applyRotation() {
+	ALOGE("PATCH:OMXCodec:applyRotation");
     sp<MetaData> meta = mSource->getFormat();
 
     int32_t rotationDegrees;
@@ -1812,23 +2451,68 @@ status_t OMXCodec::applyRotation() {
 }
 
 status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
+	ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow");
     // Get the number of buffers needed.
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
+	ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow getParameter OMX_IndexParamPortDefinition");
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow getParameter OMX_IndexParamPortDefinition ERROR");
         CODEC_LOGE("getParameter failed: %d", err);
         return err;
     }
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
+    setNativeWindowColorFormat(eNativeColorFormat);
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+    eNativeColorFormat);
+#elif defined(MTK_HARDWARE)
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
             def.format.video.eColorFormat);
+#else
+	ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat = %i", def.format.video.eColorFormat);
+
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	status_t errss;
+	
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, OMX_COLOR_FormatYUV420Planar);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			errss = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			if (errss != OK){
+				ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow setParameter failed: %d", errss);
+			}		
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		case OMX_COLOR_FormatYUV420Planar:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		default:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+			HalColorFormat = def.format.video.eColorFormat;
+		break;
+	}
+	
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+            def.format.video.nFrameWidth,
+            def.format.video.nFrameHeight,
+            HalColorFormat);
+#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -1836,8 +2520,10 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+	ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow applyRotation");
     err = applyRotation();
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow applyRotation ERROR");
         return err;
     }
 
@@ -1851,6 +2537,10 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
     if (mFlags & kEnableGrallocUsageProtected) {
         usage |= GRALLOC_USAGE_PROTECTED;
+#ifdef GRALLOC_USAGE_PRIVATE_NONSECURE
+        if (!(mFlags & kUseSecureInputBuffers))
+            usage |= GRALLOC_USAGE_PRIVATE_NONSECURE;
+#endif
     }
 
     // Make sure to check whether either Stagefright or the video decoder
@@ -1873,8 +2563,20 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
 
     ALOGV("native_window_set_usage usage=0x%lx", usage);
+
+#ifdef MTK_HARDWARE
+    usage |= (GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_SW_READ_OFTEN);
+#endif
+
+#ifdef EXYNOS4_ENHANCEMENTS
+    err = native_window_set_usage(
+            mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP
+            | GRALLOC_USAGE_HW_FIMC1 | GRALLOC_USAGE_HWC_HWOVERLAY);
+#else
     err = native_window_set_usage(
             mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
+#endif
+
     if (err != 0) {
         ALOGE("native_window_set_usage failed: %s (%d)", strerror(-err), -err);
         return err;
@@ -1902,11 +2604,17 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     //    plus an extra buffer to account for incorrect minUndequeuedBufs
     CODEC_LOGI("OMX-buffers: min=%u actual=%u undeq=%d+1",
             def.nBufferCountMin, def.nBufferCountActual, minUndequeuedBufs);
-
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    // Some devices don't like to set OMX_IndexParamPortDefinition at this
+    // point (even with an unmodified def), so skip it if possible.
+    // This check was present in KitKat.
+    if (def.nBufferCountActual < def.nBufferCountMin + minUndequeuedBufs) {
+#endif
     for (OMX_U32 extraBuffers = 2 + 1; /* condition inside loop */; extraBuffers--) {
         OMX_U32 newBufferCount =
             def.nBufferCountMin + minUndequeuedBufs + extraBuffers;
         def.nBufferCountActual = newBufferCount;
+		ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow setParameter OMX_IndexParamPortDefinition");
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -1924,6 +2632,9 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
     CODEC_LOGI("OMX-buffers: min=%u actual=%u undeq=%d+1",
             def.nBufferCountMin, def.nBufferCountActual, minUndequeuedBufs);
+#ifdef BOARD_CANT_REALLOCATE_OMX_BUFFERS
+    }
+#endif
 
     err = native_window_set_buffer_count(
             mNativeWindow.get(), def.nBufferCountActual);
@@ -1933,6 +2644,16 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+#ifdef QCOM_BSP_LEGACY
+    err = mNativeWindow.get()->perform(mNativeWindow.get(),
+			     NATIVE_WINDOW_SET_BUFFERS_SIZE, def.nBufferSize);
+    if (err != 0) {
+	ALOGE("mNativeWindow.get()->perform() faild: %s (%d)", strerror(-err),
+		-err);
+	return err; 
+    }	 
+#endif
+
     CODEC_LOGV("allocating %u buffers from a native window of size %u on "
             "output port", def.nBufferCountActual, def.nBufferSize);
 
@@ -1953,7 +2674,6 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         info.mMem = NULL;
         info.mMediaBuffer = new MediaBuffer(graphicBuffer);
         info.mMediaBuffer->setObserver(this);
-        mPortBuffers[kPortIndexOutput].push(info);
 
         IOMX::buffer_id bufferId;
         err = mOMX->useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,
@@ -1961,9 +2681,12 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         if (err != 0) {
             CODEC_LOGE("registering GraphicBuffer with OMX IL component "
                     "failed: %d", err);
+            info.mMediaBuffer->setObserver(NULL);
+            info.mMediaBuffer->release();
             break;
         }
 
+        mPortBuffers[kPortIndexOutput].push(info);
         mPortBuffers[kPortIndexOutput].editItemAt(i).mBuffer = bufferId;
 
         CODEC_LOGV("registered graphic buffer with ID %u (pointer = %p)",
@@ -1991,7 +2714,32 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     return err;
 }
 
+#ifdef USE_SAMSUNG_COLORFORMAT
+void OMXCodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
+{
+    // Convert OpenMAX color format to native color format
+    switch (eNativeColorFormat) {
+        // In case of SAMSUNG color format
+        case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
+            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_SP_TILED;
+            break;
+        case OMX_SEC_COLOR_FormatNV12Tiled:
+            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED;
+            break;
+        // In case of OpenMAX color formats
+        case OMX_COLOR_FormatYUV420SemiPlanar:
+            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
+            break;
+        case OMX_COLOR_FormatYUV420Planar:
+            default:
+            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
+            break;
+    }
+}
+#endif // USE_SAMSUNG_COLORFORMAT
+
 status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {
+	ALOGE("PATCH:OMXCodec:cancelBufferToNativeWindow");
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
     CODEC_LOGV("Calling cancelBuffer on buffer %u", info->mBuffer);
     int err = mNativeWindow->cancelBuffer(
@@ -2000,6 +2748,7 @@ status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {
       CODEC_LOGE("cancelBuffer failed w/ error 0x%08x", err);
 
       setState(ERROR);
+	  ALOGE("PATCH:OMXCodec:cancelBufferToNativeWindow ERROR");
       return err;
     }
     info->mStatus = OWNED_BY_NATIVE_WINDOW;
@@ -2007,14 +2756,15 @@ status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {
 }
 
 OMXCodec::BufferInfo* OMXCodec::dequeueBufferFromNativeWindow() {
+	ALOGE("PATCH:OMXCodec:dequeueBufferFromNativeWindow");
     // Dequeue the next buffer from the native window.
     ANativeWindowBuffer* buf;
-    int fenceFd = -1;
     int err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf);
     if (err != 0) {
       CODEC_LOGE("dequeueBuffer failed w/ error 0x%08x", err);
 
       setState(ERROR);
+	  ALOGE("PATCH:OMXCodec:dequeueBufferFromNativeWindow ERROR");
       return 0;
     }
 
@@ -2045,6 +2795,7 @@ OMXCodec::BufferInfo* OMXCodec::dequeueBufferFromNativeWindow() {
 }
 
 status_t OMXCodec::pushBlankBuffersToNativeWindow() {
+	ALOGE("PATCH:OMXCodec:pushBlankBuffersToNativeWindow");
     status_t err = NO_ERROR;
     ANativeWindowBuffer* anb = NULL;
     int numBufs = 0;
@@ -2058,6 +2809,7 @@ status_t OMXCodec::pushBlankBuffersToNativeWindow() {
     if (err != NO_ERROR) {
         ALOGE("error pushing blank frames: api_disconnect failed: %s (%d)",
                 strerror(-err), -err);
+		ALOGE("PATCH:OMXCodec:pushBlankBuffersToNativeWindow ERROR");		
         return err;
     }
 
@@ -2114,7 +2866,6 @@ status_t OMXCodec::pushBlankBuffersToNativeWindow() {
     // on the screen and then been replaced, so an previous video frames are
     // guaranteed NOT to be currently displayed.
     for (int i = 0; i < numBufs + 1; i++) {
-        int fenceFd = -1;
         err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &anb);
         if (err != NO_ERROR) {
             ALOGE("error pushing blank frames: dequeueBuffer failed: %s (%d)",
@@ -2190,22 +2941,26 @@ error:
 }
 
 int64_t OMXCodec::getDecodingTimeUs() {
+	ALOGE("PATCH:OMXCodec:getDecodingTimeUs");
     CHECK(mIsEncoder && mIsVideo);
 
     if (mDecodingTimeList.empty()) {
         CHECK(mSignalledEOS || mNoMoreOutputData);
         // No corresponding input frame available.
         // This could happen when EOS is reached.
+		ALOGE("PATCH:OMXCodec:getDecodingTimeUs return 0");
         return 0;
     }
 
     List<int64_t>::iterator it = mDecodingTimeList.begin();
     int64_t timeUs = *it;
     mDecodingTimeList.erase(it);
+	ALOGE("PATCH:OMXCodec:getDecodingTimeUs return timeUs");
     return timeUs;
 }
 
 void OMXCodec::on_message(const omx_message &msg) {
+	//ALOGE("PATCH:OMXCodec:on_message");
     if (mState == ERROR) {
         /*
          * only drop EVENT messages, EBD and FBD are still
@@ -2229,6 +2984,7 @@ void OMXCodec::on_message(const omx_message &msg) {
 
         case omx_message::EMPTY_BUFFER_DONE:
         {
+            ATRACE_BEGIN("EMPTY_BUFFER_DONE");
             IOMX::buffer_id buffer = msg.u.extended_buffer_data.buffer;
 
             CODEC_LOGV("EMPTY_BUFFER_DONE(buffer: %u)", buffer);
@@ -2269,11 +3025,13 @@ void OMXCodec::on_message(const omx_message &msg) {
                     drainInputBuffer(&buffers->editItemAt(i));
                 }
             }
+            ATRACE_END();
             break;
         }
 
         case omx_message::FILL_BUFFER_DONE:
         {
+            ATRACE_BEGIN("FILL_BUFFER_DONE");
             IOMX::buffer_id buffer = msg.u.extended_buffer_data.buffer;
             OMX_U32 flags = msg.u.extended_buffer_data.flags;
 
@@ -2373,6 +3131,7 @@ void OMXCodec::on_message(const omx_message &msg) {
                                 msg.u.extended_buffer_data.timestamp);
 
                         fillOutputBuffer(info);
+                        ATRACE_END();
                         break;
                     }
 
@@ -2384,13 +3143,23 @@ void OMXCodec::on_message(const omx_message &msg) {
                     mTargetTimeUs = -1;
                 }
 
+                if (mOutputCropChanged) {
+                    mOutputCropChanged = false;
+                    info->mOutputCropChanged = true;
+                }
                 mFilledBuffers.push_back(i);
                 mBufferFilled.signal();
+                if (!strncasecmp(mMIME, "video/", 6)) {
+                    ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
+                    ATRACE_INT("Output Buffers with OMX client",
+                            countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
+                }
                 if (mIsEncoder) {
                     sched_yield();
                 }
             }
 
+            ATRACE_END();
             break;
         }
 
@@ -2405,12 +3174,15 @@ void OMXCodec::on_message(const omx_message &msg) {
 // Has the format changed in any way that the client would have to be aware of?
 static bool formatHasNotablyChanged(
         const sp<MetaData> &from, const sp<MetaData> &to) {
+	ALOGE("PATCH:OMXCodec:formatHasNotablyChanged");		
     if (from.get() == NULL && to.get() == NULL) {
+		ALOGE("PATCH:OMXCodec:formatHasNotablyChanged false");
         return false;
     }
 
     if ((from.get() == NULL && to.get() != NULL)
         || (from.get() != NULL && to.get() == NULL)) {
+		ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 1");	
         return true;
     }
 
@@ -2419,6 +3191,7 @@ static bool formatHasNotablyChanged(
     CHECK(to->findCString(kKeyMIMEType, &mime_to));
 
     if (strcasecmp(mime_from, mime_to)) {
+		ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 2");
         return true;
     }
 
@@ -2428,6 +3201,7 @@ static bool formatHasNotablyChanged(
         CHECK(to->findInt32(kKeyColorFormat, &colorFormat_to));
 
         if (colorFormat_from != colorFormat_to) {
+			ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 3");
             return true;
         }
 
@@ -2436,6 +3210,7 @@ static bool formatHasNotablyChanged(
         CHECK(to->findInt32(kKeyWidth, &width_to));
 
         if (width_from != width_to) {
+			ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 4");
             return true;
         }
 
@@ -2444,6 +3219,7 @@ static bool formatHasNotablyChanged(
         CHECK(to->findInt32(kKeyHeight, &height_to));
 
         if (height_from != height_to) {
+			ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 5");
             return true;
         }
 
@@ -2459,6 +3235,7 @@ static bool formatHasNotablyChanged(
 
         if (left_to != left_from || top_to != top_from
                 || right_to != right_from || bottom_to != bottom_from) {
+			ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 6");		
             return true;
         }
     } else if (!strcasecmp(mime_from, MEDIA_MIMETYPE_AUDIO_RAW)) {
@@ -2467,6 +3244,7 @@ static bool formatHasNotablyChanged(
         CHECK(to->findInt32(kKeyChannelCount, &numChannels_to));
 
         if (numChannels_from != numChannels_to) {
+			ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 7");
             return true;
         }
 
@@ -2475,17 +3253,20 @@ static bool formatHasNotablyChanged(
         CHECK(to->findInt32(kKeySampleRate, &sampleRate_to));
 
         if (sampleRate_from != sampleRate_to) {
+			ALOGE("PATCH:OMXCodec:formatHasNotablyChanged true 8");
             return true;
         }
     }
-
+	ALOGE("PATCH:OMXCodec:formatHasNotablyChanged false 2");
     return false;
 }
 
 void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
+	//ALOGE("PATCH:OMXCodec:onEvent");
     switch (event) {
         case OMX_EventCmdComplete:
         {
+			//ALOGE("PATCH:OMXCodec:onEvent OMX_EventCmdComplete");
             onCmdComplete((OMX_COMMANDTYPE)data1, data2);
             break;
         }
@@ -2493,13 +3274,14 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
         case OMX_EventError:
         {
             CODEC_LOGE("OMX_EventError(0x%08x, %u)", data1, data2);
-
+			//ALOGE("PATCH:OMXCodec:onEvent OMX_EventError");	
             setState(ERROR);
             break;
         }
 
         case OMX_EventPortSettingsChanged:
         {
+			//ALOGE("PATCH:OMXCodec:onEvent OMX_EventPortSettingsChanged");
             CODEC_LOGV("OMX_EventPortSettingsChanged(port=%u, data2=0x%08x)",
                        data1, data2);
 
@@ -2557,6 +3339,7 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
 #if 0
         case OMX_EventBufferFlag:
         {
+			//ALOGE("PATCH:OMXCodec:onEvent OMX_EventBufferFlag");
             CODEC_LOGV("EVENT_BUFFER_FLAG(%ld)", data1);
 
             if (data1 == kPortIndexOutput) {
@@ -2565,7 +3348,40 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
             break;
         }
 #endif
+#ifdef USE_S3D_SUPPORT
+        case (OMX_EVENTTYPE)OMX_EventS3DInformation:
+        {
+            if (mFlags & kClientNeedsFramebuffer)
+                break;
+
+            sp<IServiceManager> sm = defaultServiceManager();
+            sp<android::IExynosHWCService> hwc = interface_cast<android::IExynosHWCService>(sm->getService(String16("Exynos.HWCService")));
+            if (hwc != NULL) {
+                if (data1 == OMX_TRUE) {
+                    int eS3DMode;
+                    switch (data2) {
+                    case OMX_SEC_FPARGMT_SIDE_BY_SIDE:
+                        eS3DMode = S3D_SBS;
+                        break;
+                    case OMX_SEC_FPARGMT_TOP_BOTTOM:
+                        eS3DMode = S3D_TB;
+                        break;
+                    case OMX_SEC_FPARGMT_CHECKERBRD_INTERL: // unsupport format at HDMI
+                    case OMX_SEC_FPARGMT_COLUMN_INTERL:
+                    case OMX_SEC_FPARGMT_ROW_INTERL:
+                    case OMX_SEC_FPARGMT_TEMPORAL_INTERL:
+                    default:
+                        eS3DMode = S3D_NONE;
+                    }
 
+                    hwc->setHdmiResolution(0, eS3DMode);
+                }
+            } else {
+                ALOGE("Exynos.HWCService is unavailable");
+            }
+            break;
+        }
+#endif
         default:
         {
             CODEC_LOGV("EVENT(%d, %u, %u)", event, data1, data2);
@@ -2575,6 +3391,7 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
 }
 
 void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
+	//ALOGE("PATCH:OMXCodec:onCmdComplete");
     switch (cmd) {
         case OMX_CommandStateSet:
         {
@@ -2653,11 +3470,18 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
 
             CODEC_LOGV("FLUSH_DONE(%u)", portIndex);
 
+            if (portIndex == (OMX_U32) -1) {
+                CHECK_EQ((int)mPortStatus[kPortIndexInput], (int)SHUTTING_DOWN);
+                mPortStatus[kPortIndexInput] = ENABLED;
+                CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)SHUTTING_DOWN);
+                mPortStatus[kPortIndexOutput] = ENABLED;
+            } else {
             CHECK_EQ((int)mPortStatus[portIndex], (int)SHUTTING_DOWN);
             mPortStatus[portIndex] = ENABLED;
 
             CHECK_EQ(countBuffersWeOwn(mPortBuffers[portIndex]),
                      mPortBuffers[portIndex].size());
+            }
 
             if (mSkipCutBuffer != NULL && mPortStatus[kPortIndexOutput] == ENABLED) {
                 mSkipCutBuffer->clear();
@@ -2690,6 +3514,7 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
 
                     // We implicitly resume pulling on our upstream source.
                     mPaused = false;
+                    mNoMoreOutputData = false;
 
                     drainInputBuffers();
                     fillOutputBuffers();
@@ -2728,6 +3553,10 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
 
                 CHECK_EQ(err, (status_t)OK);
 
+                //Both ports should be enabled by now
+                mPortStatus[kPortIndexInput] = ENABLED;
+                mPortStatus[kPortIndexOutput] = ENABLED;
+
                 setState(IDLE_TO_EXECUTING);
             } else {
                 CHECK_EQ((int)mState, (int)EXECUTING_TO_IDLE);
@@ -2764,14 +3593,31 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
                 mPortStatus[kPortIndexInput] = ENABLED;
                 mPortStatus[kPortIndexOutput] = ENABLED;
 
-                if ((mFlags & kEnableGrallocUsageProtected) &&
-                        mNativeWindow != NULL) {
+                if (mNativeWindow != NULL) {
+#ifdef QCOM_BSP_LEGACY
+		    /*
+		     * reset buffer size field with SurfaceTexture
+		     * back to 0. This wil ensure proper size
+		     * buffers are allocated if the same SurfaceTexture
+		     * is re-used in a different decode session
+		     */
+		    int err = 
+			mNativeWindow.get()->perform(mNativeWindow.get(), 
+						     NATIVE_WINDOW_SET_BUFFERS_SIZE,
+						     0);
+		    if (err != 0) {
+		    	ALOGE("mNativeWindow.get()->Perform() failed: %s (%d)", strerror(-err),
+				-err);	
+		    }		 
+#endif
+		    if (mFlags & kEnableGrallocUsageProtected) {	
                     // We push enough 1x1 blank buffers to ensure that one of
                     // them has made it to the display.  This allows the OMX
                     // component teardown to zero out any protected buffers
                     // without the risk of scanning out one of those buffers.
                     pushBlankBuffersToNativeWindow();
                 }
+                }
 
                 setState(IDLE_TO_LOADED);
             }
@@ -2806,6 +3652,14 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
             break;
         }
 
+        case OMX_StatePause:
+        {
+            CODEC_LOGV("Now paused.");
+            CHECK_EQ((int)mState, (int)PAUSING);
+            setState(PAUSED);
+            break;
+        }
+
         case OMX_StateInvalid:
         {
             setState(ERROR);
@@ -2822,6 +3676,7 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
 
 // static
 size_t OMXCodec::countBuffersWeOwn(const Vector<BufferInfo> &buffers) {
+	//ALOGE("PATCH:OMXCodec:countBuffersWeOwn");
     size_t n = 0;
     for (size_t i = 0; i < buffers.size(); ++i) {
         if (buffers[i].mStatus != OWNED_BY_COMPONENT) {
@@ -2834,6 +3689,7 @@ size_t OMXCodec::countBuffersWeOwn(const Vector<BufferInfo> &buffers) {
 
 status_t OMXCodec::freeBuffersOnPort(
         OMX_U32 portIndex, bool onlyThoseWeOwn) {
+		//ALOGE("PATCH:OMXCodec:freeBuffersOnPort");	
     Vector<BufferInfo> *buffers = &mPortBuffers[portIndex];
 
     status_t stickyErr = OK;
@@ -2864,6 +3720,7 @@ status_t OMXCodec::freeBuffersOnPort(
 }
 
 status_t OMXCodec::freeBuffer(OMX_U32 portIndex, size_t bufIndex) {
+	//ALOGE("PATCH:OMXCodec:freeBuffer");	
     Vector<BufferInfo> *buffers = &mPortBuffers[portIndex];
 
     BufferInfo *info = &buffers->editItemAt(bufIndex);
@@ -2895,6 +3752,7 @@ status_t OMXCodec::freeBuffer(OMX_U32 portIndex, size_t bufIndex) {
 }
 
 void OMXCodec::onPortSettingsChanged(OMX_U32 portIndex) {
+	ALOGE("PATCH:OMXCodec:onPortSettingsChanged");	
     CODEC_LOGV("PORT_SETTINGS_CHANGED(%ld)", portIndex);
 
     CHECK(mState == EXECUTING || mState == EXECUTING_TO_IDLE);
@@ -2919,9 +3777,14 @@ void OMXCodec::onPortSettingsChanged(OMX_U32 portIndex) {
 }
 
 bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
+	ALOGE("PATCH:OMXCodec:flushPortAsync");	
     CHECK(mState == EXECUTING || mState == RECONFIGURING
-            || mState == EXECUTING_TO_IDLE);
+            || mState == EXECUTING_TO_IDLE || mState == FLUSHING);
 
+    if (portIndex == (OMX_U32) -1 ) {
+        mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
+        mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
+    } else {
     CODEC_LOGV("flushPortAsync(%ld): we own %d out of %d buffers already.",
          portIndex, countBuffersWeOwn(mPortBuffers[portIndex]),
          mPortBuffers[portIndex].size());
@@ -2937,6 +3800,7 @@ bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
 
         return false;
     }
+    }
 
     status_t err =
         mOMX->sendCommand(mNode, OMX_CommandFlush, portIndex);
@@ -2946,6 +3810,7 @@ bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
 }
 
 void OMXCodec::disablePortAsync(OMX_U32 portIndex) {
+	ALOGE("PATCH:OMXCodec:disablePortAsync:");	
     CHECK(mState == EXECUTING || mState == RECONFIGURING);
 
     CHECK_EQ((int)mPortStatus[portIndex], (int)ENABLED);
@@ -2970,7 +3835,8 @@ status_t OMXCodec::enablePortAsync(OMX_U32 portIndex) {
 }
 
 void OMXCodec::fillOutputBuffers() {
-    CHECK_EQ((int)mState, (int)EXECUTING);
+	//ALOGE("PATCH:OMXCodec:fillOutputBuffers");	
+    CHECK(mState == EXECUTING || mState == FLUSHING);
 
     // This is a workaround for some decoders not properly reporting
     // end-of-output-stream. If we own all input buffers and also own
@@ -2997,7 +3863,8 @@ void OMXCodec::fillOutputBuffers() {
 }
 
 void OMXCodec::drainInputBuffers() {
-    CHECK(mState == EXECUTING || mState == RECONFIGURING);
+	//ALOGE("PATCH:OMXCodec:drainInputBuffers");	
+    CHECK(mState == EXECUTING || mState == RECONFIGURING || mState == FLUSHING);
 
     if (mFlags & kUseSecureInputBuffers) {
         Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
@@ -3028,10 +3895,12 @@ void OMXCodec::drainInputBuffers() {
 }
 
 bool OMXCodec::drainAnyInputBuffer() {
+	ALOGE("PATCH:OMXCodec:drainAnyInputBuffer");
     return drainInputBuffer((BufferInfo *)NULL);
 }
 
 OMXCodec::BufferInfo *OMXCodec::findInputBufferByDataPointer(void *ptr) {
+	ALOGE("PATCH:OMXCodec:findInputBufferByDataPointer");
     Vector<BufferInfo> *infos = &mPortBuffers[kPortIndexInput];
     for (size_t i = 0; i < infos->size(); ++i) {
         BufferInfo *info = &infos->editItemAt(i);
@@ -3050,6 +3919,7 @@ OMXCodec::BufferInfo *OMXCodec::findInputBufferByDataPointer(void *ptr) {
 }
 
 OMXCodec::BufferInfo *OMXCodec::findEmptyInputBuffer() {
+	ALOGE("PATCH:OMXCodec:findEmptyInputBuffer");
     Vector<BufferInfo> *infos = &mPortBuffers[kPortIndexInput];
     for (size_t i = 0; i < infos->size(); ++i) {
         BufferInfo *info = &infos->editItemAt(i);
@@ -3063,6 +3933,8 @@ OMXCodec::BufferInfo *OMXCodec::findEmptyInputBuffer() {
 }
 
 bool OMXCodec::drainInputBuffer(BufferInfo *info) {
+	ALOGE("PATCH:OMXCodec:drainInputBuffer BufferInfo *info");
+    ATRACE_CALL();
     if (info != NULL) {
         CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
     }
@@ -3125,6 +3997,9 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
     size_t offset = 0;
     int32_t n = 0;
 
+    int32_t interlaceFormatDetected = false;
+    int32_t interlaceFrameCount = 0;
+
 
     for (;;) {
         MediaBuffer *srcBuffer;
@@ -3171,6 +4046,9 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
             break;
         }
 
+	sp<MetaData> metaData = mSource->getFormat();
+	interlaceFormatDetected = ExtendedUtils::checkIsInterlace(metaData);
+
         if (mFlags & kUseSecureInputBuffers) {
             info = findInputBufferByDataPointer(srcBuffer->data());
             CHECK(info != NULL);
@@ -3210,16 +4088,55 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                 CHECK(info->mMediaBuffer == NULL);
                 info->mMediaBuffer = srcBuffer;
         } else {
+#ifdef USE_SAMSUNG_COLORFORMAT
+            OMX_PARAM_PORTDEFINITIONTYPE def;
+            InitOMXParams(&def);
+            def.nPortIndex = kPortIndexInput;
+
+            status_t err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,
+            &def, sizeof(def));
+            CHECK_EQ(err, (status_t)OK);
+
+            if (def.eDomain == OMX_PortDomainVideo) {
+                OMX_VIDEO_PORTDEFINITIONTYPE *videoDef = &def.format.video;
+                switch (videoDef->eColorFormat) {
+                    case OMX_SEC_COLOR_FormatNV12LVirtualAddress: {
+                        CHECK(srcBuffer->data() != NULL);
+                        void *pSharedMem = (void *)(srcBuffer->data());
+                        memcpy((uint8_t *)info->mData + offset,
+                        (const void *)&pSharedMem, sizeof(void *));
+                        break;
+                    }
+                    default:
+                        CHECK(srcBuffer->data() != NULL);
+                        memcpy((uint8_t *)info->mData + offset,
+                        (const uint8_t *)srcBuffer->data()
+                        + srcBuffer->range_offset(),
+                        srcBuffer->range_length());
+                        break;
+                    }
+            } else {
+                CHECK(srcBuffer->data() != NULL);
+                memcpy((uint8_t *)info->mData + offset,
+                        (const uint8_t *)srcBuffer->data()
+                            + srcBuffer->range_offset(),
+                        srcBuffer->range_length());
+            }
+#else
             CHECK(srcBuffer->data() != NULL) ;
             memcpy((uint8_t *)info->mData + offset,
                     (const uint8_t *)srcBuffer->data()
                         + srcBuffer->range_offset(),
                     srcBuffer->range_length());
+#endif // USE_SAMSUNG_COLORFORMAT
         }
 
         int64_t lastBufferTimeUs;
         CHECK(srcBuffer->meta_data()->findInt64(kKeyTime, &lastBufferTimeUs));
         CHECK(lastBufferTimeUs >= 0);
+
+        PLAYER_STATS(logBitRate, srcBuffer->range_length(), lastBufferTimeUs);
+
         if (mIsEncoder && mIsVideo) {
             mDecodingTimeList.push_back(lastBufferTimeUs);
         }
@@ -3272,8 +4189,25 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;
 
+    if(interlaceFormatDetected) {
+	interlaceFrameCount++;
+    }
+
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
+    } else if (ExtendedUtils::checkIsThumbNailMode(mFlags, mComponentName)
+			&& (!interlaceFormatDetected || interlaceFrameCount >= 2)) {
+	// Because we don't get EOS after getting the first frame, we 
+	// nee to notify the component with OMX_BUFFERFLAG_EOS, set
+	//mNoMoreOutputData to false so fillOutputBuffer gets called on 
+	// the first output buffer (see comment in fillOutputBuffer), and 
+	// mSignalledEOS must be true so drainInputBuffer is not executed
+	// on extra frames. Setting mFinalStatus to ERROR_END_OF_STREAM as 
+	// we dont want to return OK and NULL buffer in read.
+	flags |= OMX_BUFFERFLAG_EOS;
+	mNoMoreOutputData = false;
+	mSignalledEOS = true;
+	mFinalStatus = ERROR_END_OF_STREAM;
     } else {
         mNoMoreOutputData = false;
     }
@@ -3288,6 +4222,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         info = findEmptyInputBuffer();
     }
 
+    PLAYER_STATS(profileStartOnce, STATS_PROFILE_FIRST_BUFFER(mIsVideo));
     CODEC_LOGV("Calling emptyBuffer on buffer %p (length %d), "
                "timestamp %lld us (%.2f secs)",
                info->mBuffer, offset,
@@ -3308,6 +4243,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 }
 
 void OMXCodec::fillOutputBuffer(BufferInfo *info) {
+	//ALOGE("PATCH:OMXCodec:fillOutputBuffer(BufferInfo *info");
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
 
     if (mNoMoreOutputData) {
@@ -3330,6 +4266,7 @@ void OMXCodec::fillOutputBuffer(BufferInfo *info) {
 }
 
 bool OMXCodec::drainInputBuffer(IOMX::buffer_id buffer) {
+	ALOGE("PATCH:OMXCodec:drainInputBuffer(IOMX::buffer_id buffer)");
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
     for (size_t i = 0; i < buffers->size(); ++i) {
         if ((*buffers)[i].mBuffer == buffer) {
@@ -3343,6 +4280,7 @@ bool OMXCodec::drainInputBuffer(IOMX::buffer_id buffer) {
 }
 
 void OMXCodec::fillOutputBuffer(IOMX::buffer_id buffer) {
+	ALOGE("PATCH:OMXCodec:fillOutputBuffer(IOMX::buffer_id buffer)");
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];
     for (size_t i = 0; i < buffers->size(); ++i) {
         if ((*buffers)[i].mBuffer == buffer) {
@@ -3355,6 +4293,7 @@ void OMXCodec::fillOutputBuffer(IOMX::buffer_id buffer) {
 }
 
 void OMXCodec::setState(State newState) {
+	//ALOGE("PATCH:OMXCodec:setState");
     mState = newState;
     mAsyncCompletion.signal();
 
@@ -3364,14 +4303,21 @@ void OMXCodec::setState(State newState) {
 }
 
 status_t OMXCodec::waitForBufferFilled_l() {
-
-    if (mIsEncoder) {
+//ALOGE("PATCH:OMXCodec:waitForBufferFilled_l");
+    ATRACE_CALL();
+    if (mIsEncoder && mIsVideo) {
         // For timelapse video recording, the timelapse video recording may
         // not send an input frame for a _long_ time. Do not use timeout
         // for video encoding.
         return mBufferFilled.wait(mLock);
     }
     status_t err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNs);
+    if ((err == -ETIMEDOUT) && (mPaused == true)){
+        // When the audio playback is paused, the fill buffer maybe timed out
+        // if input data is not available to decode. Hence, considering the
+        // timed out as a valid case.
+        err = OK;
+    }
     if (err != OK) {
         CODEC_LOGE("Timed out waiting for output buffers: %d/%d",
             countBuffersWeOwn(mPortBuffers[kPortIndexInput]),
@@ -3383,10 +4329,12 @@ status_t OMXCodec::waitForBufferFilled_l() {
 void OMXCodec::setRawAudioFormat(
         OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels) {
 
+	ALOGE("PATCH:OMXCodec:setRawAudioFormat");
     // port definition
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
+    def.format.audio.cMIMEType = NULL;
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
@@ -3465,6 +4413,7 @@ static OMX_AUDIO_AMRBANDMODETYPE pickModeFromBitRate(bool isAMRWB, int32_t bps)
 }
 
 void OMXCodec::setAMRFormat(bool isWAMR, int32_t bitRate) {
+	ALOGE("PATCH:OMXCodec:setAMRFormat");
     OMX_U32 portIndex = mIsEncoder ? kPortIndexOutput : kPortIndexInput;
 
     OMX_AUDIO_PARAM_AMRTYPE def;
@@ -3497,6 +4446,7 @@ void OMXCodec::setAMRFormat(bool isWAMR, int32_t bitRate) {
 
 status_t OMXCodec::setAACFormat(
         int32_t numChannels, int32_t sampleRate, int32_t bitRate, int32_t aacProfile, bool isADTS) {
+		ALOGE("PATCH:OMXCodec:setAACFormat");	
     if (numChannels > 2) {
         ALOGW("Number of channels: (%d) \n", numChannels);
     }
@@ -3597,6 +4547,7 @@ status_t OMXCodec::setAACFormat(
 }
 
 status_t OMXCodec::setAC3Format(int32_t numChannels, int32_t sampleRate) {
+	ALOGE("PATCH:OMXCodec:setAC3Format");	
     OMX_AUDIO_PARAM_ANDROID_AC3TYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexInput;
@@ -3628,6 +4579,7 @@ void OMXCodec::setG711Format(int32_t numChannels) {
 
 void OMXCodec::setImageOutputFormat(
         OMX_COLOR_FORMATTYPE format, OMX_U32 width, OMX_U32 height) {
+	ALOGE("PATCH:OMXCodec:setImageOutputFormat");		
     CODEC_LOGV("setImageOutputFormat(%ld, %ld)", width, height);
 
 #if 0
@@ -3700,6 +4652,7 @@ void OMXCodec::setImageOutputFormat(
 
 void OMXCodec::setJPEGInputFormat(
         OMX_U32 width, OMX_U32 height, OMX_U32 compressedSize) {
+	ALOGE("PATCH:OMXCodec:setJPEGInputFormat");		
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexInput;
@@ -3724,6 +4677,7 @@ void OMXCodec::setJPEGInputFormat(
 }
 
 void OMXCodec::addCodecSpecificData(const void *data, size_t size) {
+	ALOGE("PATCH:OMXCodec:addCodecSpecificData");	
     CodecSpecificData *specific =
         (CodecSpecificData *)malloc(sizeof(CodecSpecificData) + size - 1);
 
@@ -3734,6 +4688,7 @@ void OMXCodec::addCodecSpecificData(const void *data, size_t size) {
 }
 
 void OMXCodec::clearCodecSpecificData() {
+	ALOGE("PATCH:OMXCodec:clearCodecSpecificData");
     for (size_t i = 0; i < mCodecSpecificData.size(); ++i) {
         free(mCodecSpecificData.editItemAt(i));
     }
@@ -3742,8 +4697,14 @@ void OMXCodec::clearCodecSpecificData() {
 }
 
 status_t OMXCodec::start(MetaData *meta) {
+	ALOGE("PATCH:OMXCodec:start");
     Mutex::Autolock autoLock(mLock);
 
+    if (mPaused) {
+        status_t err = resumeLocked(true);
+        return err;
+    }
+
     if (mState != LOADED) {
         CODEC_LOGE("called start in the unexpected state: %d", mState);
         return UNKNOWN_ERROR;
@@ -3797,10 +4758,19 @@ status_t OMXCodec::start(MetaData *meta) {
         CODEC_LOGE("source failed to start: %d", err);
         return err;
     }
-    return init();
+    if ((err = init()) != OK) {
+        CODEC_LOGE("init failed: %d", err);
+        //Something went wrong..component refused to move to idle or allocation
+        //failed. Set state to error and force stopping component to cleanup as
+        //much as possible
+        setState(ERROR);
+        stopOmxComponent_l();
+    }
+    return err;
 }
 
 status_t OMXCodec::stop() {
+	ALOGE("PATCH:OMXCodec:stop");
     CODEC_LOGV("stop mState=%d", mState);
     Mutex::Autolock autoLock(mLock);
     status_t err = stopOmxComponent_l();
@@ -3811,6 +4781,7 @@ status_t OMXCodec::stop() {
 }
 
 status_t OMXCodec::stopOmxComponent_l() {
+	ALOGE("PATCH:OMXCodec:stopOmxComponent_l");
     CODEC_LOGV("stopOmxComponent_l mState=%d", mState);
 
     while (isIntermediateState(mState)) {
@@ -3854,6 +4825,7 @@ status_t OMXCodec::stopOmxComponent_l() {
             isError = true;
         }
 
+        case PAUSED:
         case EXECUTING:
         {
             setState(EXECUTING_TO_IDLE);
@@ -3862,6 +4834,14 @@ status_t OMXCodec::stopOmxComponent_l() {
                 CODEC_LOGV("This component requires a flush before transitioning "
                      "from EXECUTING to IDLE...");
 
+                //DSP supports flushing of ports simultaneously.
+                //Flushing individual port is not supported.
+                if(mQuirks & kRequiresGlobalFlush) {
+                    bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
+                    if (emulateFlushCompletion) {
+                        onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
+                    }
+                } else {
                 bool emulateInputFlushCompletion =
                     !flushPortAsync(kPortIndexInput);
 
@@ -3875,6 +4855,7 @@ status_t OMXCodec::stopOmxComponent_l() {
                 if (emulateOutputFlushCompletion) {
                     onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
                 }
+                }
             } else {
                 mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
                 mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
@@ -3913,6 +4894,7 @@ status_t OMXCodec::stopOmxComponent_l() {
 }
 
 sp<MetaData> OMXCodec::getFormat() {
+	ALOGE("PATCH:OMXCodec:getFormat");	
     Mutex::Autolock autoLock(mLock);
 
     return mOutputFormat;
@@ -3920,11 +4902,21 @@ sp<MetaData> OMXCodec::getFormat() {
 
 status_t OMXCodec::read(
         MediaBuffer **buffer, const ReadOptions *options) {
+	ALOGE("PATCH:OMXCodec:read");		
+    ATRACE_CALL();
     status_t err = OK;
     *buffer = NULL;
 
     Mutex::Autolock autoLock(mLock);
 
+    if (mPaused) {
+        err = resumeLocked(false);
+        if(err != OK) {
+            CODEC_LOGE("Failed to restart codec err= %d", err);
+            return err;
+        }
+    }
+
     if (mState != EXECUTING && mState != RECONFIGURING) {
         return UNKNOWN_ERROR;
     }
@@ -3950,13 +4942,13 @@ status_t OMXCodec::read(
             mPaused = false;
         }
 
-        drainInputBuffers();
 
         if (mState == EXECUTING) {
             // Otherwise mState == RECONFIGURING and this code will trigger
             // after the output port is reenabled.
             fillOutputBuffers();
         }
+        drainInputBuffers();
     }
 
     if (seeking) {
@@ -3981,7 +4973,24 @@ status_t OMXCodec::read(
         mFilledBuffers.clear();
 
         CHECK_EQ((int)mState, (int)EXECUTING);
+        //DSP supports flushing of ports simultaneously. Flushing individual port is not supported.
+        setState(FLUSHING);
+
+        if(mQuirks & kRequiresGlobalFlush) {
+            bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
+            if (emulateFlushCompletion) {
+                onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
+            }
+        } else {
 
+            //DSP supports flushing of ports simultaneously.
+            //Flushing individual port is not supported.
+            if(mQuirks & kRequiresGlobalFlush) {
+                bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
+                if (emulateFlushCompletion) {
+                    onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
+                }
+            } else {
         bool emulateInputFlushCompletion = !flushPortAsync(kPortIndexInput);
         bool emulateOutputFlushCompletion = !flushPortAsync(kPortIndexOutput);
 
@@ -3992,6 +5001,8 @@ status_t OMXCodec::read(
         if (emulateOutputFlushCompletion) {
             onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
         }
+            }
+        }
 
         while (mSeekTimeUs >= 0) {
             if ((err = waitForBufferFilled_l()) != OK) {
@@ -4000,6 +5011,12 @@ status_t OMXCodec::read(
         }
     }
 
+    if (!strncasecmp(mMIME, "video/", 6)) {
+        ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
+        ATRACE_INT("Output Buffers with OMX client",
+                countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
+    }
+
     while (mState != ERROR && !mNoMoreOutputData && mFilledBuffers.empty()) {
         if ((err = waitForBufferFilled_l()) != OK) {
             return err;
@@ -4010,6 +5027,11 @@ status_t OMXCodec::read(
         return UNKNOWN_ERROR;
     }
 
+    if (seeking) {
+        CHECK_EQ((int)mState, (int)FLUSHING);
+        setState(EXECUTING);
+    }
+
     if (mFilledBuffers.empty()) {
         return mSignalledEOS ? mFinalStatus : ERROR_END_OF_STREAM;
     }
@@ -4022,6 +5044,11 @@ status_t OMXCodec::read(
 
     size_t index = *mFilledBuffers.begin();
     mFilledBuffers.erase(mFilledBuffers.begin());
+    if (!strncasecmp(mMIME, "video/", 6)) {
+        ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
+        ATRACE_INT("Output Buffers with OMX client",
+                countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
+    }
 
     BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(index);
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
@@ -4033,10 +5060,15 @@ status_t OMXCodec::read(
     }
     *buffer = info->mMediaBuffer;
 
+    if (info->mOutputCropChanged) {
+        initNativeWindowCrop();
+        info->mOutputCropChanged = false;
+    }
     return OK;
 }
 
 void OMXCodec::signalBufferReturned(MediaBuffer *buffer) {
+	ALOGE("PATCH:OMXCodec:signalBufferReturned");	
     Mutex::Autolock autoLock(mLock);
 
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];
@@ -4082,6 +5114,291 @@ void OMXCodec::signalBufferReturned(MediaBuffer *buffer) {
     CHECK(!"should not be here.");
 }
 
+static const char *imageCompressionFormatString(OMX_IMAGE_CODINGTYPE type) {
+    static const char *kNames[] = {
+        "OMX_IMAGE_CodingUnused",
+        "OMX_IMAGE_CodingAutoDetect",
+        "OMX_IMAGE_CodingJPEG",
+        "OMX_IMAGE_CodingJPEG2K",
+        "OMX_IMAGE_CodingEXIF",
+        "OMX_IMAGE_CodingTIFF",
+        "OMX_IMAGE_CodingGIF",
+        "OMX_IMAGE_CodingPNG",
+        "OMX_IMAGE_CodingLZW",
+        "OMX_IMAGE_CodingBMP",
+    };
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
+static const char *colorFormatString(OMX_COLOR_FORMATTYPE type) {
+    static const char *kNames[] = {
+        "OMX_COLOR_FormatUnused",
+        "OMX_COLOR_FormatMonochrome",
+        "OMX_COLOR_Format8bitRGB332",
+        "OMX_COLOR_Format12bitRGB444",
+        "OMX_COLOR_Format16bitARGB4444",
+        "OMX_COLOR_Format16bitARGB1555",
+        "OMX_COLOR_Format16bitRGB565",
+        "OMX_COLOR_Format16bitBGR565",
+        "OMX_COLOR_Format18bitRGB666",
+        "OMX_COLOR_Format18bitARGB1665",
+        "OMX_COLOR_Format19bitARGB1666",
+        "OMX_COLOR_Format24bitRGB888",
+        "OMX_COLOR_Format24bitBGR888",
+        "OMX_COLOR_Format24bitARGB1887",
+        "OMX_COLOR_Format25bitARGB1888",
+        "OMX_COLOR_Format32bitBGRA8888",
+        "OMX_COLOR_Format32bitARGB8888",
+        "OMX_COLOR_FormatYUV411Planar",
+        "OMX_COLOR_FormatYUV411PackedPlanar",
+        "OMX_COLOR_FormatYUV420Planar",
+        "OMX_COLOR_FormatYUV420PackedPlanar",
+        "OMX_COLOR_FormatYUV420SemiPlanar",
+        "OMX_COLOR_FormatYUV422Planar",
+        "OMX_COLOR_FormatYUV422PackedPlanar",
+        "OMX_COLOR_FormatYUV422SemiPlanar",
+        "OMX_COLOR_FormatYCbYCr",
+        "OMX_COLOR_FormatYCrYCb",
+        "OMX_COLOR_FormatCbYCrY",
+        "OMX_COLOR_FormatCrYCbY",
+        "OMX_COLOR_FormatYUV444Interleaved",
+        "OMX_COLOR_FormatRawBayer8bit",
+        "OMX_COLOR_FormatRawBayer10bit",
+        "OMX_COLOR_FormatRawBayer8bitcompressed",
+        "OMX_COLOR_FormatL2",
+        "OMX_COLOR_FormatL4",
+        "OMX_COLOR_FormatL8",
+        "OMX_COLOR_FormatL16",
+        "OMX_COLOR_FormatL24",
+        "OMX_COLOR_FormatL32",
+        "OMX_COLOR_FormatYUV420PackedSemiPlanar",
+        "OMX_COLOR_FormatYUV422PackedSemiPlanar",
+        "OMX_COLOR_Format18BitBGR666",
+        "OMX_COLOR_Format24BitARGB6666",
+        "OMX_COLOR_Format24BitABGR6666",
+    };
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
+        return "OMX_TI_COLOR_FormatYUV420PackedSemiPlanar";
+    }
+#ifdef USE_SAMSUNG_COLORFORMAT
+    if (type == OMX_SEC_COLOR_FormatNV12TPhysicalAddress) {
+        return "OMX_SEC_COLOR_FormatNV12TPhysicalAddress";
+    }
+    if (type == OMX_SEC_COLOR_FormatNV12LPhysicalAddress) {
+        return "OMX_SEC_COLOR_FormatNV12LPhysicalAddress";
+    }
+    if (type == OMX_SEC_COLOR_FormatNV12LVirtualAddress) {
+        return "OMX_SEC_COLOR_FormatNV12LVirtualAddress";
+    }
+    if (type == OMX_SEC_COLOR_FormatNV12Tiled) {
+        return "OMX_SEC_COLOR_FormatNV12Tiled";
+    }
+#endif // USE_SAMSUNG_COLORFORMAT
+    else if (type == OMX_QCOM_COLOR_FormatYVU420SemiPlanar) {
+        return "OMX_QCOM_COLOR_FormatYVU420SemiPlanar";
+    } else if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
+static const char *vendorVideoCompressionFormatString(OMX_VIDEO_CODINGTYPE type) {
+    static const char *kVendorNames[] = {
+        "OMX_VIDEO_CodingVendorStartUnused",
+        "OMX_VIDEO_CodingVC1",
+        "OMX_VIDEO_CodingFLV1",
+        "OMX_VIDEO_CodingDIVX",
+        "OMX_VIDEO_CodingHEVC",
+        "OMX_VIDEO_CodingFFMPEG",
+    };
+
+    CHECK_GE(type, OMX_VIDEO_CodingVendorStartUnused);
+
+    size_t index = (size_t)type - (size_t)OMX_VIDEO_CodingVendorStartUnused;
+
+    size_t numNames = sizeof(kVendorNames) / sizeof(kVendorNames[0]);
+
+    if (index >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kVendorNames[index];
+    }
+}
+
+static const char *videoCompressionFormatString(OMX_VIDEO_CODINGTYPE type) {
+    static const char *kNames[] = {
+        "OMX_VIDEO_CodingUnused",
+        "OMX_VIDEO_CodingAutoDetect",
+        "OMX_VIDEO_CodingMPEG2",
+        "OMX_VIDEO_CodingH263",
+        "OMX_VIDEO_CodingMPEG4",
+        "OMX_VIDEO_CodingWMV",
+        "OMX_VIDEO_CodingRV",
+        "OMX_VIDEO_CodingAVC",
+        "OMX_VIDEO_CodingMJPEG",
+        "OMX_VIDEO_CodingVPX",
+    };
+
+    if (type >= OMX_VIDEO_CodingVendorStartUnused) {
+        return vendorVideoCompressionFormatString(type);
+    }
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
+static const char *vendorAudioCodingTypeString(OMX_AUDIO_CODINGTYPE type) {
+    static const char *kVendorNames[] = {
+        "OMX_AUDIO_CodingVendorStartUnused",
+        "OMX_AUDIO_CodingMP2",
+        "OMX_AUDIO_CodingAC3",
+        "OMX_AUDIO_CodingAPE",
+        "OMX_AUDIO_CodingDTS",
+        "OMX_AUDIO_CodingFFMPEG",
+    };
+
+    CHECK_GE(type, OMX_AUDIO_CodingVendorStartUnused);
+
+    size_t index = (size_t)type - (size_t)OMX_AUDIO_CodingVendorStartUnused;
+
+    size_t numNames = sizeof(kVendorNames) / sizeof(kVendorNames[0]);
+
+    if (index >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kVendorNames[index];
+    }
+}
+
+static const char *audioCodingTypeString(OMX_AUDIO_CODINGTYPE type) {
+    static const char *kNames[] = {
+        "OMX_AUDIO_CodingUnused",
+        "OMX_AUDIO_CodingAutoDetect",
+        "OMX_AUDIO_CodingPCM",
+        "OMX_AUDIO_CodingADPCM",
+        "OMX_AUDIO_CodingAMR",
+        "OMX_AUDIO_CodingGSMFR",
+        "OMX_AUDIO_CodingGSMEFR",
+        "OMX_AUDIO_CodingGSMHR",
+        "OMX_AUDIO_CodingPDCFR",
+        "OMX_AUDIO_CodingPDCEFR",
+        "OMX_AUDIO_CodingPDCHR",
+        "OMX_AUDIO_CodingTDMAFR",
+        "OMX_AUDIO_CodingTDMAEFR",
+        "OMX_AUDIO_CodingQCELP8",
+        "OMX_AUDIO_CodingQCELP13",
+        "OMX_AUDIO_CodingEVRC",
+        "OMX_AUDIO_CodingSMV",
+        "OMX_AUDIO_CodingG711",
+        "OMX_AUDIO_CodingG723",
+        "OMX_AUDIO_CodingG726",
+        "OMX_AUDIO_CodingG729",
+        "OMX_AUDIO_CodingAAC",
+        "OMX_AUDIO_CodingMP3",
+        "OMX_AUDIO_CodingSBC",
+        "OMX_AUDIO_CodingVORBIS",
+        "OMX_AUDIO_CodingOPUS",
+        "OMX_AUDIO_CodingWMA",
+        "OMX_AUDIO_CodingRA",
+        "OMX_AUDIO_CodingMIDI",
+        "OMX_AUDIO_CodingFLAC",
+    };
+
+    if (type >= OMX_AUDIO_CodingVendorStartUnused) {
+        return vendorAudioCodingTypeString(type);
+    }
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
+static const char *audioPCMModeString(OMX_AUDIO_PCMMODETYPE type) {
+    static const char *kNames[] = {
+        "OMX_AUDIO_PCMModeLinear",
+        "OMX_AUDIO_PCMModeALaw",
+        "OMX_AUDIO_PCMModeMULaw",
+    };
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
+static const char *amrBandModeString(OMX_AUDIO_AMRBANDMODETYPE type) {
+    static const char *kNames[] = {
+        "OMX_AUDIO_AMRBandModeUnused",
+        "OMX_AUDIO_AMRBandModeNB0",
+        "OMX_AUDIO_AMRBandModeNB1",
+        "OMX_AUDIO_AMRBandModeNB2",
+        "OMX_AUDIO_AMRBandModeNB3",
+        "OMX_AUDIO_AMRBandModeNB4",
+        "OMX_AUDIO_AMRBandModeNB5",
+        "OMX_AUDIO_AMRBandModeNB6",
+        "OMX_AUDIO_AMRBandModeNB7",
+        "OMX_AUDIO_AMRBandModeWB0",
+        "OMX_AUDIO_AMRBandModeWB1",
+        "OMX_AUDIO_AMRBandModeWB2",
+        "OMX_AUDIO_AMRBandModeWB3",
+        "OMX_AUDIO_AMRBandModeWB4",
+        "OMX_AUDIO_AMRBandModeWB5",
+        "OMX_AUDIO_AMRBandModeWB6",
+        "OMX_AUDIO_AMRBandModeWB7",
+        "OMX_AUDIO_AMRBandModeWB8",
+    };
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
+static const char *amrFrameFormatString(OMX_AUDIO_AMRFRAMEFORMATTYPE type) {
+    static const char *kNames[] = {
+        "OMX_AUDIO_AMRFrameFormatConformance",
+        "OMX_AUDIO_AMRFrameFormatIF1",
+        "OMX_AUDIO_AMRFrameFormatIF2",
+        "OMX_AUDIO_AMRFrameFormatFSF",
+        "OMX_AUDIO_AMRFrameFormatRTPPayload",
+        "OMX_AUDIO_AMRFrameFormatITU",
+    };
+
+    size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
+
+    if (type < 0 || (size_t)type >= numNames) {
+        return "UNKNOWN";
+    } else {
+        return kNames[type];
+    }
+}
+
 void OMXCodec::dumpPortStatus(OMX_U32 portIndex) {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
@@ -4112,10 +5429,10 @@ void OMXCodec::dumpPortStatus(OMX_U32 portIndex) {
             printf("  nStride = %" PRIu32 "\n", imageDef->nStride);
 
             printf("  eCompressionFormat = %s\n",
-                   asString(imageDef->eCompressionFormat));
+                   imageCompressionFormatString(imageDef->eCompressionFormat));
 
             printf("  eColorFormat = %s\n",
-                   asString(imageDef->eColorFormat));
+                   colorFormatString(imageDef->eColorFormat));
 
             break;
         }
@@ -4131,10 +5448,10 @@ void OMXCodec::dumpPortStatus(OMX_U32 portIndex) {
             printf("  nStride = %" PRIu32 "\n", videoDef->nStride);
 
             printf("  eCompressionFormat = %s\n",
-                   asString(videoDef->eCompressionFormat));
+                   videoCompressionFormatString(videoDef->eCompressionFormat));
 
             printf("  eColorFormat = %s\n",
-                   asString(videoDef->eColorFormat));
+                   colorFormatString(videoDef->eColorFormat));
 
             break;
         }
@@ -4146,7 +5463,7 @@ void OMXCodec::dumpPortStatus(OMX_U32 portIndex) {
             printf("\n");
             printf("  // Audio\n");
             printf("  eEncoding = %s\n",
-                   asString(audioDef->eEncoding));
+                   audioCodingTypeString(audioDef->eEncoding));
 
             if (audioDef->eEncoding == OMX_AUDIO_CodingPCM) {
                 OMX_AUDIO_PARAM_PCMMODETYPE params;
@@ -4166,7 +5483,7 @@ void OMXCodec::dumpPortStatus(OMX_U32 portIndex) {
                        params.eNumData == OMX_NumericalDataSigned
                         ? "signed" : "unsigned");
 
-                printf("  ePCMMode = %s\n", asString(params.ePCMMode));
+                printf("  ePCMMode = %s\n", audioPCMModeString(params.ePCMMode));
             } else if (audioDef->eEncoding == OMX_AUDIO_CodingAMR) {
                 OMX_AUDIO_PARAM_AMRTYPE amr;
                 InitOMXParams(&amr);
@@ -4178,9 +5495,9 @@ void OMXCodec::dumpPortStatus(OMX_U32 portIndex) {
 
                 printf("  nChannels = %" PRIu32 "\n", amr.nChannels);
                 printf("  eAMRBandMode = %s\n",
-                        asString(amr.eAMRBandMode));
+                        amrBandModeString(amr.eAMRBandMode));
                 printf("  eAMRFrameFormat = %s\n",
-                        asString(amr.eAMRFrameFormat));
+                        amrFrameFormatString(amr.eAMRFrameFormat));
             }
 
             break;
@@ -4227,6 +5544,7 @@ void OMXCodec::initNativeWindowCrop() {
 }
 
 void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
+	ALOGE("PATCH:OMXCodec:initOutputFormat");
     mOutputFormat = new MetaData;
     mOutputFormat->setCString(kKeyDecoderComponent, mComponentName);
     if (mIsEncoder) {
@@ -4240,6 +5558,8 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
+	ALOGE("PATCH:OMXCodec:initOutputFormat getParameter OMX_IndexParamPortDefinition");
+	
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
@@ -4253,6 +5573,9 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
 
             mOutputFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_RAW);
             mOutputFormat->setInt32(kKeyColorFormat, imageDef->eColorFormat);
+			
+			ALOGE("PATCH:OMXCodec:initOutputFormat image set mageDef->eColorFormat = %i", imageDef->eColorFormat);
+			
             mOutputFormat->setInt32(kKeyWidth, imageDef->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, imageDef->nFrameHeight);
             break;
@@ -4280,14 +5603,14 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 inputFormat->findInt32(kKeySampleRate, &sampleRate);
 
                 if ((OMX_U32)numChannels != params.nChannels) {
-                    ALOGV("Codec outputs a different number of channels than "
+                    ALOGI("Codec outputs a different number of channels than "
                          "the input stream contains (contains %d channels, "
                          "codec outputs %ld channels).",
                          numChannels, params.nChannels);
                 }
 
                 if (sampleRate != (int32_t)params.nSamplingRate) {
-                    ALOGV("Codec outputs at different sampling rate than "
+                    ALOGI("Codec outputs at different sampling rate than "
                          "what the input stream contains (contains data at "
                          "%d Hz, codec outputs %lu Hz)",
                          sampleRate, params.nSamplingRate);
@@ -4353,8 +5676,30 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
             } else {
+                AString mimeType;
+                err = BAD_VALUE;
+#ifdef ENABLE_AV_ENHANCEMENTS
+                err = ExtendedCodec::handleSupportedAudioFormats(
+                        audio_def->eEncoding, &mimeType);
+#endif
+                if (err != OK) {
+                    err = FFMPEGSoftCodec::handleSupportedAudioFormats(
+                            audio_def->eEncoding, &mimeType);
+                }
+                if (err == OK) {
+                    mOutputFormat->setCString(
+                            kKeyMIMEType, mimeType.c_str());
+                    int32_t numChannels, sampleRate, bitRate;
+                    inputFormat->findInt32(kKeyChannelCount, &numChannels);
+                    inputFormat->findInt32(kKeySampleRate, &sampleRate);
+                    inputFormat->findInt32(kKeyBitRate, &bitRate);
+                    mOutputFormat->setInt32(kKeyChannelCount, numChannels);
+                    mOutputFormat->setInt32(kKeySampleRate, sampleRate);
+                    mOutputFormat->setInt32(kKeyBitRate, bitRate);
+                } else {
                 CHECK(!"Should not be here. Unknown audio encoding.");
             }
+            }
             break;
         }
 
@@ -4375,14 +5720,33 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
             } else {
+                AString mimeType;
+                err = BAD_VALUE;
+#ifdef ENABLE_AV_ENHANCEMENTS
+                err = ExtendedCodec::handleSupportedVideoFormats(
+                        video_def->eCompressionFormat, &mimeType);
+#endif
+                if (err != OK) {
+                    err = FFMPEGSoftCodec::handleSupportedVideoFormats(
+                            video_def->eCompressionFormat, &mimeType);
+                }
+                if (err == OK) {
+                    mOutputFormat->setCString(kKeyMIMEType, mimeType.c_str());
+                } else {
                 CHECK(!"Unknown compression format.");
             }
+            }
 
             mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
             mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
+            mOutputFormat->setInt32(kKeyStride, video_def->nStride);
+            mOutputFormat->setInt32(kKeySliceHeight, video_def->nSliceHeight);
+			
+			ALOGE("PATCH:OMXCodec:initOutputFormat video set video_def->eColorFormat = %i", video_def->eColorFormat);
 
             if (!mIsEncoder) {
+				ALOGE("PATCH:OMXCodec:initOutputFormat video no encoder");
                 OMX_CONFIG_RECTTYPE rect;
                 InitOMXParams(&rect);
                 rect.nPortIndex = kPortIndexOutput;
@@ -4422,9 +5786,13 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 }
 
                 if (mNativeWindow != NULL) {
+                     if (mInSmoothStreamingMode) {
+                         mOutputCropChanged = true;
+                     } else {
                      initNativeWindowCrop();
                 }
             }
+            }
             break;
         }
 
@@ -4445,11 +5813,66 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
 }
 
 status_t OMXCodec::pause() {
+	ALOGE("PATCH:OMXCodec:pause");
+   CODEC_LOGV("pause mState=%d", mState);
+
     Mutex::Autolock autoLock(mLock);
 
+   if (mState != EXECUTING) {
+       return UNKNOWN_ERROR;
+   }
+
+   while (isIntermediateState(mState)) {
+       mAsyncCompletion.wait(mLock);
+   }
+   if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
+       status_t err = mOMX->sendCommand(mNode,
+           OMX_CommandStateSet, OMX_StatePause);
+       CHECK_EQ(err, (status_t)OK);
+       setState(PAUSING);
+
+       mPaused = true;
+       while (mState != PAUSED && mState != ERROR) {
+           mAsyncCompletion.wait(mLock);
+       }
+       return mState == ERROR ? UNKNOWN_ERROR : OK;
+   } else {
     mPaused = true;
+       return OK;
+   }
 
+}
+
+status_t OMXCodec::resumeLocked(bool drainInputBuf) {
+	ALOGE("PATCH:OMXCodec:resumeLocked");
+   CODEC_LOGV("resume mState=%d", mState);
+
+   if (!strncmp(mComponentName, "OMX.qcom.", 9) && mPaused) {
+        while (isIntermediateState(mState)) {
+            mAsyncCompletion.wait(mLock);
+        }
+        if (mState == (status_t)EXECUTING) {
+            CODEC_LOGI("in EXECUTING state, return OK");
+            return OK;
+        }
+        CHECK_EQ(mState, (status_t)PAUSED);
+        status_t err = mOMX->sendCommand(mNode,
+        OMX_CommandStateSet, OMX_StateExecuting);
+        CHECK_EQ(err, (status_t)OK);
+        setState(IDLE_TO_EXECUTING);
+        mPaused = false;
+        while (mState != EXECUTING && mState != ERROR) {
+            mAsyncCompletion.wait(mLock);
+        }
+        if(drainInputBuf)
+            drainInputBuffers();
+        return mState == ERROR ? UNKNOWN_ERROR : OK;
+    } else {   // SW Codec
+        mPaused = false;
+        if(drainInputBuf)
+            drainInputBuffers();
     return OK;
+    }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -4458,6 +5881,8 @@ status_t QueryCodecs(
         const sp<IOMX> &omx,
         const char *mime, bool queryDecoders, bool hwCodecOnly,
         Vector<CodecCapabilities> *results) {
+	ALOGE("PATCH:OMXCodec:QueryCodecs");	
+			
     Vector<OMXCodec::CodecNameAndQuirks> matchingCodecs;
     results->clear();
 
@@ -4489,13 +5914,20 @@ status_t QueryCodec(
         const char *componentName, const char *mime,
         bool isEncoder,
         CodecCapabilities *caps) {
-    bool isVideo = !strncasecmp(mime, "video/", 6);
+    if (strncmp(componentName, "OMX.", 4)) {
+        // Not an OpenMax component but a software codec.
+        caps->mFlags = 0;
+        caps->mComponentName = componentName;
+        return OK;
+    }
 
     sp<OMXCodecObserver> observer = new OMXCodecObserver;
     IOMX::node_id node;
+	ALOGE("PATCH:OMXCodec:QueryCodecs[%s] allocateNode", componentName);
     status_t err = omx->allocateNode(componentName, observer, &node);
 
     if (err != OK) {
+		ALOGE("PATCH:OMXCodec:QueryCodecs[%s] allocateNode ERROR", componentName);
         return err;
     }
 
@@ -4504,19 +5936,21 @@ status_t QueryCodec(
     caps->mFlags = 0;
     caps->mComponentName = componentName;
 
-    // NOTE: OMX does not provide a way to query AAC profile support
-    if (isVideo) {
         OMX_VIDEO_PARAM_PROFILELEVELTYPE param;
         InitOMXParams(&param);
 
         param.nPortIndex = !isEncoder ? 0 : 1;
 
         for (param.nProfileIndex = 0;; ++param.nProfileIndex) {
+		
+		ALOGE("PATCH:OMXCodec:QueryCodec[%s]getParameter(OMX_IndexParamVideoProfileLevelQuerySupported)", componentName);
+		
             err = omx->getParameter(
                     node, OMX_IndexParamVideoProfileLevelQuerySupported,
                     &param, sizeof(param));
 
             if (err != OK) {
+			ALOGE("PATCH:OMXCodec:QueryCodec[%s]getParameter(OMX_IndexParamVideoProfileLevelQuerySupported) ERROR", componentName);
                 break;
             }
 
@@ -4524,6 +5958,9 @@ status_t QueryCodec(
             profileLevel.mProfile = param.eProfile;
             profileLevel.mLevel = param.eLevel;
 
+		ALOGE("PATCH:OMXCodec:QueryCodec[%s]getParameter(IndexParamVideoPortFormat) param.eProfile %i", componentName, param.eProfile);
+		ALOGE("PATCH:OMXCodec:QueryCodec[%s]getParameter(IndexParamVideoPortFormat) param.eLevel %i", componentName, param.eLevel);
+
             caps->mProfileLevels.push(profileLevel);
         }
 
@@ -4534,33 +5971,46 @@ status_t QueryCodec(
         InitOMXParams(&portFormat);
         portFormat.nPortIndex = !isEncoder ? 1 : 0;
         for (portFormat.nIndex = 0;; ++portFormat.nIndex)  {
+		
+		ALOGE("PATCH:OMXCodec:QueryCodec[%s]getParameter(IndexParamVideoPortFormat)", componentName);
+		
             err = omx->getParameter(
                     node, OMX_IndexParamVideoPortFormat,
                     &portFormat, sizeof(portFormat));
             if (err != OK) {
+			ALOGE("PATCH:OMXCodec:QueryCodec:[%s]getParameter(IndexParamVideoPortFormat) ERROR", componentName);
                 break;
             }
 
             OMX_U32 flexibleEquivalent;
             if (ACodec::isFlexibleColorFormat(
-                        omx, node, portFormat.eColorFormat, false /* usingNativeWindow */,
-                        &flexibleEquivalent)) {
+                    omx, node, portFormat.eColorFormat, &flexibleEquivalent)) {
+			ALOGE("PATCH:OMXCodec:QueryCodec[%s] isFlexibleColorFormat %i", componentName, portFormat.eColorFormat);			
                 bool marked = false;
                 for (size_t i = 0; i < caps->mColorFormats.size(); i++) {
                     if (caps->mColorFormats.itemAt(i) == flexibleEquivalent) {
                         marked = true;
+					ALOGE("PATCH:OMXCodec:QueryCodec[%s] isFlexibleColorFormat %i TRUE", componentName, portFormat.eColorFormat);	
                         break;
                     }
                 }
                 if (!marked) {
+				ALOGE("PATCH:OMXCodec:QueryCodec[%s] isFlexibleColorFormat %i FALSE", componentName, portFormat.eColorFormat);
                     caps->mColorFormats.push(flexibleEquivalent);
                 }
             }
+
+		if(portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+			ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) portFormat.eColorFormat %i SET %i", portFormat.eColorFormat, OMX_COLOR_FormatYUV420Planar);
+			caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+		}else{
+			ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) DEFAULT portFormat.eColorFormat %i", portFormat.eColorFormat);
             caps->mColorFormats.push(portFormat.eColorFormat);
         }
+
     }
 
-    if (isVideo && !isEncoder) {
+    if (!isEncoder && !strncmp(mime, "video/", 6)) {
         if (omx->storeMetaDataInBuffers(
                     node, 1 /* port index */, OMX_TRUE) == OK ||
             omx->prepareForAdaptivePlayback(
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f..307ceef 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -44,6 +44,7 @@ bool ColorConverter::isValid() const {
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+		case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -110,6 +111,10 @@ status_t ColorConverter::convert(
             err = convertCbYCrY(src, dst);
             break;
 
+		case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break;	
+
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
             break;
@@ -196,6 +201,71 @@ status_t ColorConverter::convertCbYCrY(
     return OK;
 }
 
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+		ALOGE("PATCH:ColorConverter:convertYCbYCr");
+    // XXX Untested
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+			signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
 status_t ColorConverter::convertYUV420Planar(
         const BitmapParams &src, const BitmapParams &dst) {
     if (!((src.mCropLeft & 1) == 0
diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 04467b9..4d2f250 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -101,10 +101,11 @@ void SoftwareRenderer::resetFormatIfChanged(const sp<AMessage> &format) {
     int halFormat;
     size_t bufWidth, bufHeight;
 
+	ALOGE("PATCH:SoftwareRenderer:resetFormatIfChanged: mColorFormat = %i", mColorFormat);
+
     switch (mColorFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
-        case OMX_COLOR_FormatYUV420SemiPlanar:
         {
             if (!runningInEmulator()) {
                 halFormat = HAL_PIXEL_FORMAT_YV12;
@@ -132,11 +133,20 @@ void SoftwareRenderer::resetFormatIfChanged(const sp<AMessage> &format) {
     CHECK(mCropHeight > 0);
     CHECK(mConverter == NULL || mConverter->isValid());
 
+#ifdef EXYNOS4_ENHANCEMENTS
+    CHECK_EQ(0,
+            native_window_set_usage(
+            mNativeWindow.get(),
+            GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_OFTEN
+            | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP
+            | GRALLOC_USAGE_HW_FIMC1 | GRALLOC_USAGE_HWC_HWOVERLAY));
+#else
     CHECK_EQ(0,
             native_window_set_usage(
             mNativeWindow.get(),
             GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_OFTEN
             | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP));
+#endif
 
     CHECK_EQ(0,
             native_window_set_scaling_mode(
@@ -181,7 +191,7 @@ void SoftwareRenderer::resetFormatIfChanged(const sp<AMessage> &format) {
 }
 
 void SoftwareRenderer::render(
-        const void *data, size_t size, int64_t timestampNs,
+        const void *data, size_t /*size*/, int64_t timestampNs,
         void* /*platformPrivate*/, const sp<AMessage>& format) {
     resetFormatIfChanged(format);
 
@@ -202,6 +212,7 @@ void SoftwareRenderer::render(
                 buf->handle, GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &dst));
 
     if (mConverter) {
+		ALOGE("PATCH:SoftwareRenderer:render: mConverter () mColorFormat = %i ", mColorFormat);
         mConverter->convert(
                 data,
                 mWidth, mHeight,
@@ -210,9 +221,7 @@ void SoftwareRenderer::render(
                 buf->stride, buf->height,
                 0, 0, mCropWidth - 1, mCropHeight - 1);
     } else if (mColorFormat == OMX_COLOR_FormatYUV420Planar) {
-        if ((size_t)mWidth * mHeight * 3 / 2 > size) {
-            goto skip_copying;
-        }
+		ALOGE("PATCH:SoftwareRenderer:render: mColorFormat = %i OMX_COLOR_FormatYUV420Planar", mColorFormat);
         const uint8_t *src_y = (const uint8_t *)data;
         const uint8_t *src_u = (const uint8_t *)data + mWidth * mHeight;
         const uint8_t *src_v = src_u + (mWidth / 2 * mHeight / 2);
@@ -232,19 +241,17 @@ void SoftwareRenderer::render(
         }
 
         for (int y = 0; y < (mCropHeight + 1) / 2; ++y) {
-            memcpy(dst_u, src_u, (mCropWidth + 1) / 2);
-            memcpy(dst_v, src_v, (mCropWidth + 1) / 2);
+            memcpy(dst_u, src_v, (mCropWidth + 1) / 2);
+            memcpy(dst_v, src_u, (mCropWidth + 1) / 2);
 
             src_u += mWidth / 2;
             src_v += mWidth / 2;
             dst_u += dst_c_stride;
             dst_v += dst_c_stride;
         }
-    } else if (mColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
-            || mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
-        if ((size_t)mWidth * mHeight * 3 / 2 > size) {
-            goto skip_copying;
-        }
+    } else {
+		ALOGE("PATCH:SoftwareRenderer:render: mColorFormat = %i OMX_TI_COLOR_FormatYUV420PackedSemiPlanar", mColorFormat);
+        CHECK_EQ(mColorFormat, OMX_TI_COLOR_FormatYUV420PackedSemiPlanar);
 
         const uint8_t *src_y =
             (const uint8_t *)data;
@@ -252,13 +259,25 @@ void SoftwareRenderer::render(
         const uint8_t *src_uv =
             (const uint8_t *)data + mWidth * (mHeight - mCropTop / 2);
 
-        uint8_t *dst_y = (uint8_t *)dst;
+#ifdef EXYNOS4_ENHANCEMENTS
+        void *pYUVBuf[3];
 
+        CHECK_EQ(0, mapper.unlock(buf->handle));
+        CHECK_EQ(0, mapper.lock(
+                buf->handle, GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_YUV_ADDR, bounds, pYUVBuf));
+
+        size_t dst_c_stride = buf->stride / 2;
+        uint8_t *dst_y = (uint8_t *)pYUVBuf[0];
+        uint8_t *dst_v = (uint8_t *)pYUVBuf[1];
+        uint8_t *dst_u = (uint8_t *)pYUVBuf[2];
+#else
         size_t dst_y_size = buf->stride * buf->height;
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
         size_t dst_c_size = dst_c_stride * buf->height / 2;
+        uint8_t *dst_y = (uint8_t *)dst;
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
+#endif
 
         for (int y = 0; y < mCropHeight; ++y) {
             memcpy(dst_y, src_y, mCropWidth);
@@ -278,11 +297,8 @@ void SoftwareRenderer::render(
             dst_u += dst_c_stride;
             dst_v += dst_c_stride;
         }
-    } else {
-        LOG_ALWAYS_FATAL("bad color format %#x", mColorFormat);
     }
 
-skip_copying:
     CHECK_EQ(0, mapper.unlock(buf->handle));
 
     if ((err = native_window_set_buffers_timestamp(mNativeWindow.get(),
